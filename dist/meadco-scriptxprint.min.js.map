{"version":3,"file":"meadco-scriptxprint.min.js","names":["extendMeadCoNamespace","version","htmlApiLocation","pdfApiLocation","directApiLocation","licenseApiLocation","printerApiLocation","printerName","magicPrintPreviewPrinter","jobNameWaitingForSend","jobNameSentWaitingResponse","jobNameHoldEnsureSpoolingStatus","enumMeasurementUnits","DEFAULT","INCHES","MM","AccessControl","cookie","deviceSettings","outerScope","this","activePrintQueue","servicesServer","serviceUrl","pendingUrl","failedUrl","verifiedUrl","orchestratorPort","orchestratorKey","portsToTry","verifying","trustVerifiedConnection","undoTrust","url","MeadCo","warn","that","verifyUrl","value","log","IsChangingServer","setUrlAsync","resolve","reject","bAsync","thatValue","window","setTimeout","IsFailedConnection","apiEndPoint","parseInt","length","jQuery","fetchEnabled","ajax","method","dataType","cache","async","done","data","HttpPort","urlHelper","URL","port","protocol","host","pathname","test","urlFound","errorThrown","fail","jqXhr","textStatus","msg","parseAjaxError","_","fetch","then","response","ok","Error","status","json","catch","error","serverUrl","nHuntAllowed","makeApiEndPoint","href","resolvedUrl","hostname","parseFetchError","call","sApi","oApiData","bLicensed","currentUrl","location","oPayload","jsonp","contentType","headers","Authorization","btoa","licenseGuid","IsEmptyPayload","JSON","stringify","always","dataOrjqXHR","jqXHRorErrorThrown","body","referrerPolicy","mode","credentials","redirect","keepalive","text","errorTxt","statusText","aServerUrl","newUrl","e","message","Object","keys","constructor","bConnected","bDoneAuto","availablePrinters","cachedServiceDescription","enumContentType","HTML","INNERHTML","STRING","enumResponseStatus","UNKNOWN","QUEUEDTODEVICE","QUEUEDTOFILE","SOFTERROR","OK","enumErrorAction","REPORT","THROW","errorAction","enumServiceClass","CLOUD","ONPREMISE","WINDOWSPC","enumPrintStatus","NOTSTARTED","QUEUED","STARTING","DOWNLOADING","DOWNLOADED","PRINTING","COMPLETED","PAUSED","PRINTPDF","ERROR","ABANDONED","enumCollateOptions","TRUE","FALSE","enumDuplexOptions","SIMPLEX","VERTICAL","HORIZONTAL","queueJob","push","jobIdentifier","jobName","jobCount","findJob","id","find","updateJob","j","forEach","key","removeJob","filter","previousPrintCallWasAt","progress","requestData","information","OnProgress","UserData","nextJobFileName","funcPrintHtmlAtServer","content","htmlPrintSettings","trackingData","fnDone","fnProgress","fnOnQueuedFileAvailable","devInfo","parse","ContentType","Content","Settings","Device","ProtectedContentAccess","fakeJob","Date","now","requiredOutputName","fnOnFileAvailable","printAtServer","err","ScriptX","Print","reportError","queuedToFile","monitorJob","api","queuedToDevice","softError","timeoutToJobStart","timeoutSpacingMSecs","jobGapResetTimeout","printHtmlAtServer","t","open","funcPrintPdfAtServer","document","pdfPrintSettings","Document","Description","jobDescription","jobTitle","printPdfAtServer","printDirectAtServer","PrinterName","setServer","clientLicenseGuid","connectToServer","getDeviceSettings","name","getFromServer","connectToServerAsync","foundUrl","responseInterface","callService","errMsg","onSuccess","onFail","httpMethod","processMonitorResponse","intervalId","jobId","timeOut","functionComplete","clearInterval","counter","interval","CODEEXEPTION","bWaiting","setInterval","addOrUpdateDeviceSettings","isDefault","i","oRequest","replace","encodeURIComponent","errTxt","getDeviceSettingsFor","sPrinterName","printerData","toLowerCase","eTxt","getDeviceSettingsForAsync","managePrinterConnection","sMethod","sShareName","console","sd","serviceDescription","serviceClass","serviceVersion","major","minor","managePrinterConnectionAsync","serviceDescriptionAsync","processAttributes","printHtml","printApi","licenseApi","Licensing","cloudOrOnPremise","querySelector","dataset","meadcoServer","meadcoPrinthtmlserver","meadcoSubscription","meadcoSyncinit","meadcoUsefetch","syncInit","sFetchDefined","server","connect","connectLite","wPC","meadcoLicense","meadcoLicensePath","meadcoLicenseRevision","meadcoOrchestrator","meadcoOrchestratorKey","meadcoTrustVerifiedConnection","meadcoReporterror","applyLicense","meadcoApplyLicense","apply","result","errorMessage","applyAsync","PrintStatus","ErrorAction","CollateOptions","DuplexOptions","MeasurementUnits","ServiceClasses","onErrorAction","action","orchestrator","nPort","sKey","authorisationCookie","deviceRequest","setSystemDefaultPrinterAsync","sName","serviceVersionAsync","settings","deviceSettingsFor","deviceSettingsForAsync","useAttributes","connectAsync","connectTestAsync","connectDeviceAndPrinters","deviceInfo","arPrinters","isConnected","availablePrinterNames","addPrinterConnection","removePrinterConnection","addPrinterConnectionAsync","removePrinterConnectionAsync","sPrintHtmlApi","requestHtmlPreview","fnReady","userPrinterName","printPdf","printDirect","logText","reportServerError","alert","reportFeatureNotImplemented","featureDescription","queue","activeJobs","clientSideJobs","noJobsWaitingDelivery","every","ensureSpoolingStatus","lock","freeSpoolStatus","isSpooling","waitForSpoolingComplete","iTimeout","fnComplete","startTime","waitForDeliveryComplete","waitForDeliveryCompleteAsync","Promise","queueTimeoutSpacing","msec","queueGapResetTime","jobFileName","sname","requestService","getService","postService","getServiceAsync","postServiceAsync"],"sources":["meadco-scriptxprint.js"],"mappings":"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","ignoreList":[],"sourcesContent":["/**\r\n * MeadCo.ScriptX.Print\r\n * \r\n * A static class wrapping calls to the server API. \r\n * \r\n * Requires: meadco-core.js\r\n * \r\n * Includes processing of calls to the print api that return \"printing to file\" including collecting the file output. \r\n * \r\n * Provides attribute based connection to the server.\r\n * \r\n * Synchronous AJAX calls are deprecated in all browsers but may be useful to \"quick start\" use of older code. It is recommended that code is moved\r\n * to using asynchronous calls as soon as practical. The MeadCoScriptXJS library can assist with this as it delivers promise rather than callback based code.\r\n * \r\n * AJAX calls can be made via jQuery or browser native fetch(). If jQuery is available it will be used by preference - if used jQuery v1.19 or later is required.\r\n * \r\n * jQuery is required for synchronous AJAX calls.\r\n * \r\n * To use fetch, even if jQuery is available then set MeadCo.fetchEnabled to false. \r\n * \r\n * This can be done using an attribute: data-meadco-usefetch=\"true\" or declare var MeadCo = { useFetch: true } before including this library\r\n * This is useful if a very old version of jQuery is required for UI.\r\n *\r\n * @namespace MeadCoScriptXPrint\r\n */\r\n\r\n; (function (name, definition) {\r\n    extendMeadCoNamespace(name, definition);\r\n})('MeadCo.ScriptX.Print', function () {\r\n    // module version and the api we are coded for\r\n    const version = \"1.16.1.4\";\r\n    const htmlApiLocation = \"v1/printHtml\";\r\n    const pdfApiLocation = \"v1/printPdf\";\r\n    const directApiLocation = \"v1/printDirect\";\r\n    const licenseApiLocation = \"v1/licensing\";\r\n    const printerApiLocation = \"v1/printer\";\r\n\r\n    // default printer \r\n    let printerName = \"\";\r\n\r\n    // using this printername causes ScriptX.Services to select \r\n    // a printer that prints to a PDF file.\r\n    const magicPrintPreviewPrinter = \"ScriptX.Services//PrintPreview.1\"\r\n\r\n    const jobNameWaitingForSend = \"[hold.clientside]\";\r\n    const jobNameSentWaitingResponse = \"[wait.response]\";\r\n    const jobNameHoldEnsureSpoolingStatus = \"[hold.ensureSpoolStatus]\";\r\n\r\n    /**\r\n     * Enum to describe the units used on measurements. Please be aware that (sadly) these enum values do *not* match  \r\n     * the values by the MeadCo ScriptX COM Servers. Please use MeadCo.ScriptX.MeasurementUnits (declared in MeadCoScriptJS) for compatibility\r\n     *\r\n     * @memberof MeadCoScriptXPrint\r\n     * @typedef {number} MeasurementUnits\r\n     * @enum {MeasurementUnits}\r\n     * @readonly\r\n     * @property {number} DEFAULT 0 use the default at the print server\r\n     * @property {number} INCHES 1 \r\n     * @property {number} MM 2 millimeters\r\n     */\r\n    const enumMeasurementUnits = {\r\n        DEFAULT: 0,\r\n        INCHES: 1,\r\n        MM: 2\r\n    };\r\n\r\n    /**\r\n     * Describe the size of a page by its width and height.\r\n     * \r\n     * @typedef PageSize\r\n     * @memberof MeadCoScriptXPrint\r\n     * @property {number} width width of paper in requested units\r\n     * @property {number} height height of paper in requested units\r\n     * */\r\n    var PageSize;  // for doc generator\r\n\r\n    /**\r\n     * Describe the margins within which to print.\r\n     * \r\n     * @typedef Margins\r\n     * @memberof MeadCoScriptXPrint\r\n     * @property {number} left left margin in requested units\r\n     * @property {number} top top margin in requested units\r\n     * @property {number} right right margin in requested units\r\n     * @property {number} bottom bottom margin in requested units\r\n     * */\r\n    var Margins;  // for doc generator\r\n\r\n    /**\r\n     * Information about and the settings to use with an output printing device\r\n     * See also: https://www.meadroid.com/Developers/KnowledgeBank/TechnicalReference/ScriptXServices/WebServiceAPIReference/PrintHtml/deviceinfoGET\r\n     * \r\n     * @typedef DeviceSettingsObject\r\n     * @memberof MeadCoScriptXPrint\r\n     * @property {string} printerName The name of the printer\r\n     * @property {string} printToFileName The name of a the file to send print output to (for Windows PC and )\r\n     * @property {string} paperSizeName The descriptive name of the papersize, e.g. \"A4\"\r\n     * @property {string} paperSourceName The descriptive name of the paper source, e.g. \"Upper tray\"\r\n     * @property {CollateOptions} collate The collation to use when printing\r\n     * @property {number} copies The number of copies to print\r\n     * @property {DuplexOptions} duplex The dulex printing option\r\n     * @property {MeasurementUnits} units Measurement units for papersize and margins\r\n     * @property {PageSize} paperPageSize The size of the paper (in requested units)\r\n     * @property {Margins} unprintableMargins The margin that cannot be printed in (in requested units)\r\n     * @property {number} status Status code for the status of the device. Note this is not reliable, it is the cached return from the first server enquiry only.\r\n     * @property {string} port Printer connection port name/description\r\n     * @property {number} attributes Printer attributes\r\n     * @property {string} serverName Name of the server to which the printer is connected\r\n     * @property {string} shareName Name of the share \r\n     * @property {string} location description of the location of the printer\r\n     * @property {boolean} isLocal true if the printer is local to the server\r\n     * @property {boolean} isNetwork true if the server is on the network\r\n     * @property {boolean} isShared true if the printer is shared \r\n     * @property {boolean} isDefault true if this is the default printer on the service\r\n     * @property {Array.<string>} bins Array of the names of the available paper sources\r\n     * @property {Array.<string>} forms Array of the names of the avbailable paper sizes\r\n     * */\r\n    var DeviceSettingsObject; // for doc generator\r\n\r\n    /**\r\n     * Provide authorisation details to access protected content. \r\n     * \r\n     * @typedef AccessControl\r\n     * @memberof MeadCoScriptXPrint\r\n     * @property {string} cookie The authorisation cookie in the form name=value|name2=value2\r\n     * */\r\n    var AccessControl = {\r\n        cookie: \"\"\r\n    };\r\n\r\n    /**\r\n     * Description of a code version. Semver is used \r\n     * \r\n     * @typedef VersionObject\r\n     * @memberof MeadCoScriptXPrint\r\n     * @property {int} major The major version  \r\n     * @property {int} minor The minor version \r\n     * @property {int} build The patch/hotfix version\r\n     * @property {int} revision Internal revisions of a build/patch/hotfix\r\n     * @property {int} majorRevision ignore\r\n     * @property {int} minorRevision ignore \r\n     * */\r\n    var VersionObject; // for doc generator\r\n\r\n    let deviceSettings = {};\r\n    const outerScope = this;\r\n\r\n    let activePrintQueue = []; // current job queue\r\n\r\n    // singleton wrapper to the server\r\n    //\r\n    // servicesServer.url\r\n    // servicesServer.test\r\n    // servicesServer.call\r\n    //\r\n    const servicesServer = {\r\n\r\n        serviceUrl: \"\",\r\n        pendingUrl: \"\",\r\n        failedUrl: \"\",\r\n        verifiedUrl: \"\",\r\n        orchestratorPort: 0,\r\n        orchestratorKey: \"\",\r\n        portsToTry: 10,\r\n        verifying: false,\r\n        trustVerifiedConnection: true, // if true then once a connection has been found, trust that it will be valid for the page lifetime\r\n\r\n        undoTrust: function () {\r\n            if (!this.trustVerifiedConnection && this.serviceUrl !== \"\") {\r\n                this.verifiedUrl = this.serviceUrl;\r\n                this.pendingUrl = this.serviceUrl;\r\n                this.serviceUrl = \"\";\r\n            }\r\n        },\r\n\r\n        get url() {\r\n\r\n            if (this.verifiedUrl !== \"\") {\r\n                return this.verifiedUrl;\r\n            }\r\n\r\n            if (this.serviceUrl === \"\" && this.pendingUrl !== \"\") {\r\n                MeadCo.warn(\"[GET] servicesServer.url is not ready, performing synchronous search. Recommend code re-org to resolve the server earlier and asynchronously.\")\r\n                var that = this;\r\n                this.verifyUrl(this.pendingUrl, false, function () {\r\n                    return that.serviceUrl;\r\n                }, function () {\r\n                    return \"\";\r\n                });\r\n            }\r\n\r\n            return this.serviceUrl;\r\n\r\n        },\r\n\r\n        // essentially synchronous set url, we set the pending value so the code \r\n        // executes synchronously here and there may then be an asynchronous sorting\r\n        // out when an api call is made (see implementation of call : function())\r\n        set url(value) {\r\n            MeadCo.log(\"servicesServer::setUrl: \" + value);\r\n            if (this.IsChangingServer(value)) {\r\n                MeadCo.log(\"note set as pending\");\r\n                this.serviceUrl = \"\";\r\n                this.pendingUrl = value;\r\n            }\r\n        },\r\n\r\n        setUrlAsync: function (value, resolve, reject) {\r\n            MeadCo.log(\"servicesServer::urlAsync: \" + value);\r\n            this.verifyUrl(value, true, resolve, reject);\r\n        },\r\n\r\n        verifyUrl: function (value, bAsync, resolve, reject) {\r\n\r\n            if (this.verifying && bAsync) {\r\n                MeadCo.warn(\"Verify called and verify in progress ....\");\r\n                var that = this;\r\n                var thatValue = value;\r\n                window.setTimeout(function () { that.verifyUrl(thatValue, bAsync, resolve, reject); }, 1000);\r\n                return;\r\n            }\r\n\r\n            if (this.IsChangingServer(value) && !this.IsFailedConnection(value)) {\r\n\r\n                var that = this;\r\n                var thatValue = value;\r\n\r\n                MeadCo.log(\"servicesServer::verifyurl: \" + value + \", async: \" + bAsync);\r\n\r\n                // if an orchestrator has been defined then ask it for the current users port\r\n                if (typeof this.orchestratorPort !== \"number\") {\r\n                    this.orchestratorPort = parseInt(\"\" + this.orchestratorPort);\r\n                }\r\n\r\n                if (this.orchestratorPort > 0) {\r\n                    MeadCo.log(\"Using request to Orchestrator on port: \" + this.orchestratorPort);\r\n                    that.verifying = true;\r\n\r\n                    // by definition Orchestrator is local.\r\n                    var apiEndPoint;\r\n                    if (typeof this.orchestratorKey === \"string\" && this.orchestratorKey.length > 0) {\r\n                        apiEndPoint = \"/api/v2?key=\" + this.orchestratorKey;\r\n                    }\r\n                    else {\r\n                        apiEndPoint = \"/api/v1\";\r\n                    }\r\n\r\n                    MeadCo.log(\"servicesServer::querying orchestrator: \" + \"http://127.0.0.1:\" + this.orchestratorPort + apiEndPoint);\r\n\r\n                    if (outerScope.jQuery && !MeadCo.fetchEnabled) {\r\n                        outerScope.jQuery.ajax(\"http://127.0.0.1:\" + this.orchestratorPort + apiEndPoint,\r\n                            {\r\n                                method: \"GET\",\r\n                                dataType: \"json\",\r\n                                cache: false,\r\n                                async: bAsync\r\n                            }).done(function (data) {\r\n\r\n                                MeadCo.log(\"orchestrator returned ScriptX.Services port: \" + data.HttpPort)\r\n\r\n                                var urlHelper = new URL(thatValue);\r\n                                urlHelper.port = data.HttpPort;\r\n                                thatValue = urlHelper.protocol + \"//\" + urlHelper.host + urlHelper.pathname\r\n\r\n                                that.test(thatValue, 0, bAsync, function (urlFound) {\r\n                                    that.serviceUrl = urlFound;\r\n                                    that.pendingUrl = \"\";\r\n                                    that.verifying = false;\r\n                                    resolve(urlFound, true);\r\n                                }, function (errorThrown) {\r\n                                    that.serviceUrl = \"\";\r\n                                    that.pendingUrl = \"\";\r\n                                    that.failedUrl = thatValue;\r\n                                    that.verifying = false;\r\n                                    if (typeof reject === \"function\") {\r\n                                        reject(errorThrown);\r\n                                    }\r\n                                });\r\n\r\n                            })\r\n                            .fail(function (jqXhr, textStatus, errorThrown) {\r\n                                that.verifying = false;\r\n                                that.serviceUrl = \"\";\r\n                                that.pendingUrl = \"\";\r\n\r\n                                const msg = MeadCo.parseAjaxError(\"Failed to connect with Orchestrator: \", jqXhr, textStatus, errorThrown);\r\n                                MeadCo.warn(msg);\r\n\r\n                                try {\r\n                                    let t = new URL(thatValue);\r\n                                    that.failedUrl = thatValue;\r\n                                }\r\n                                catch (_) { }\r\n\r\n                                if (typeof reject === \"function\") {\r\n                                    reject(\"ScriptX.Services (Orchestrator) could not be found at \\\"\" + thatValue + \"\\\". Is it installed and running?\");\r\n                                }\r\n                            });\r\n                    }\r\n                    else {\r\n                        fetch(\"http://127.0.0.1:\" + this.orchestratorPort + apiEndPoint)\r\n                            .then((response) => {\r\n                                if (!response.ok) {\r\n                                    throw new Error(`HTTP Error: ${response.status}`)\r\n                                }\r\n                                return response.json();\r\n                            })\r\n                            .then(data => {\r\n                                MeadCo.log(\"orchestrator returned ScriptX.Services port: \" + data.HttpPort)\r\n\r\n                                var urlHelper = new URL(thatValue);\r\n                                urlHelper.port = data.HttpPort;\r\n                                thatValue = urlHelper.protocol + \"//\" + urlHelper.host + urlHelper.pathname\r\n\r\n                                that.test(thatValue, 0, bAsync, function (urlFound) {\r\n                                    that.serviceUrl = urlFound;\r\n                                    that.pendingUrl = \"\";\r\n                                    that.verifying = false;\r\n                                    resolve(urlFound, true);\r\n                                }, function (errorThrown) {\r\n                                    that.serviceUrl = \"\";\r\n                                    that.pendingUrl = \"\";\r\n                                    that.failedUrl = thatValue;\r\n                                    that.verifying = false;\r\n                                    if (typeof reject === \"function\") {\r\n                                        reject(errorThrown);\r\n                                    }\r\n                                });\r\n                            })\r\n                            .catch(error => {\r\n                                that.verifying = false;\r\n                                that.serviceUrl = \"\";\r\n                                that.pendingUrl = \"\";\r\n\r\n                                try {\r\n                                    let t = new URL(thatValue);\r\n                                    that.failedUrl = thatValue;\r\n                                }\r\n                                catch (_) { }\r\n\r\n                                if (typeof reject === \"function\") {\r\n                                    reject(\"ScriptX.Services (Orchestrator) could not be found at \\\"\" + thatValue + \"\\\". Is it installed and running?\");\r\n                                }\r\n                            });\r\n                    }\r\n                }\r\n                else {\r\n                    that.verifying = true;\r\n                    that.test(thatValue, that.portsToTry, bAsync, function (urlFound) {\r\n                        that.serviceUrl = urlFound;\r\n                        that.pendingUrl = \"\";\r\n                        that.verifying = false;\r\n                        resolve(urlFound, false);\r\n                    }, function (errorThrown) {\r\n                        that.serviceUrl = \"\";\r\n                        that.pendingUrl = \"\";\r\n                        that.verifying = false;\r\n\r\n                        try {\r\n                            let t = new URL(thatValue);\r\n                            that.failedUrl = thatValue;\r\n                        }\r\n                        catch (_) { }\r\n\r\n                        if (typeof reject === \"function\") {\r\n                            reject(\"ScriptX.Services could not be found at \\\"\" + thatValue + \"\\\". Is it installed and running?\");\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n            else {\r\n                if (this.IsFailedConnection(value)) {\r\n                    if (typeof reject === \"function\") {\r\n                        reject(\"ScriptX.Services connection to: \" + value + \" is either invalid or has already failed and will not be re-tried.\")\r\n                    }\r\n                    else {\r\n                        MeadCo.warn(\"ScriptX.Services connection to: \" + value + \" has already failed and will not be re-tried.\")\r\n                    }\r\n                }\r\n                else\r\n                    resolve(this.serviceUrl, this.orchestratorPort > 0);\r\n            }\r\n        },\r\n\r\n        // test\r\n        //\r\n        // Can we ask something and get a response, without using a license - checks the server is there.\r\n        //\r\n        // Will perform port hunt (increment the port number) when attempting to connect to\r\n        // ScriptX.Services for Windows PC\r\n        //\r\n        test: function (serverUrl, nHuntAllowed, bAsync, resolve, reject) {\r\n            if (serverUrl.length > 0) {\r\n                const that = this;\r\n                let urlHelper;\r\n\r\n                try {\r\n                    urlHelper = new URL(serverUrl);\r\n                    if (urlHelper.protocol !== 'http:' && urlHelper.protocol !== 'https:') {\r\n                        reject(\"Invalid protocol: \" + serverUrl);\r\n                        return;\r\n                    }\r\n                } catch (_) {\r\n                    reject(\"Invalid URL: \" + serverUrl);\r\n                    return;\r\n                }\r\n\r\n                MeadCo.log(\"Test server requested: \" + serverUrl + \", port: \" + urlHelper.port);\r\n\r\n                // use the license API\r\n                const serviceUrl = MeadCo.makeApiEndPoint(urlHelper.href, licenseApiLocation + \"/ping\");\r\n\r\n                if (outerScope.jQuery && !MeadCo.fetchEnabled) {\r\n                    MeadCo.log(\".ajax() get: \" + serviceUrl);\r\n                    outerScope.jQuery.ajax(serviceUrl,\r\n                        {\r\n                            method: \"GET\",\r\n                            dataType: \"json\",\r\n                            cache: false,\r\n                            async: bAsync\r\n                        }).done(function (data) {\r\n                            const resolvedUrl = urlHelper.protocol + \"//\" + urlHelper.host + urlHelper.pathname;\r\n                            MeadCo.log(\"Test server succeed, resolve(\" + resolvedUrl + \")\")\r\n                            resolve(resolvedUrl);\r\n                        })\r\n                        .fail(function (jqXhr, textStatus, errorThrown) {\r\n                            // only do hunting with 4WPC and that must be on 127.0.0.1 or localhost\r\n                            MeadCo.log(\"Test server failed: [\" + errorThrown + \"], \" + nHuntAllowed + \", on: \" + urlHelper.hostname);\r\n                            if (nHuntAllowed > 0 && (urlHelper.hostname === \"localhost\" || urlHelper.hostname == \"127.0.0.1\")) {\r\n                                urlHelper.port++;\r\n                                outerScope.setTimeout(that.test(urlHelper.protocol + \"//\" + urlHelper.host + urlHelper.pathname, --nHuntAllowed, bAsync, resolve, reject), 1);\r\n                            }\r\n                            else {\r\n                                errorThrown = MeadCo.parseAjaxError(\"MeadCo.ScriptX.Print.servicesServer.test:\", jqXhr, textStatus, errorThrown);\r\n                                if (typeof reject === \"function\") {\r\n                                    MeadCo.log(\"rejecting with: \" + errorThrown);\r\n                                    reject(errorThrown);\r\n                                }\r\n                                else {\r\n                                    MeadCo.warn(\"failed with no reject function\");\r\n                                }\r\n                            }\r\n                        });\r\n                }\r\n                else {\r\n                    MeadCo.log(\"fetch get: \" + serviceUrl);\r\n                    if (bAsync) {\r\n                        fetch(serviceUrl)\r\n                            .then((response) => {\r\n                                if (!response.ok) {\r\n                                    throw new Error(`HTTP Error: ${response.status}`)\r\n                                }\r\n                                return response.json();\r\n                            })\r\n                            .then(data => {\r\n                                const resolvedUrl = urlHelper.protocol + \"//\" + urlHelper.host + urlHelper.pathname;\r\n                                MeadCo.log(\"Test server succeed, resolve(\" + resolvedUrl + \")\")\r\n                                resolve(resolvedUrl);\r\n                            })\r\n                            .catch((error) => {\r\n                                // only do hunting with 4WPC and that must be on 127.0.0.1 or localhost\r\n                                MeadCo.log(\"Test server failed: [\" + error + \"], \" + nHuntAllowed + \", on: \" + urlHelper.hostname);\r\n                                if (nHuntAllowed > 0 && (urlHelper.hostname === \"localhost\" || urlHelper.hostname == \"127.0.0.1\")) {\r\n                                    urlHelper.port++;\r\n                                    outerScope.setTimeout(that.test(urlHelper.protocol + \"//\" + urlHelper.host + urlHelper.pathname, --nHuntAllowed, bAsync, resolve, reject), 1);\r\n                                }\r\n                                else {\r\n                                    errorThrown = MeadCo.parseFetchError(\"MeadCo.ScriptX.Print.servicesServer.test:\", error);\r\n                                    if (typeof reject === \"function\") {\r\n                                        MeadCo.log(\"rejecting with: \" + errorThrown);\r\n                                        reject(errorThrown);\r\n                                    }\r\n                                    else {\r\n                                        MeadCo.warn(\"failed with no reject function\");\r\n                                    }\r\n                                }\r\n\r\n                            });\r\n                    }\r\n                    else {\r\n                        MeadCo.error(\"Synchronous Ajax calls requires jQuery\");\r\n                        if (typeof reject === \"function\") {\r\n                            reject(\"Synchronous Ajax calls requires jQuery\");\r\n                        }\r\n                    }\r\n                }\r\n\r\n            }\r\n        },\r\n\r\n        // send a method request to an end point\r\n        //\r\n        call: function (sApi, method, oApiData, bLicensed, bAsync, resolve, reject) {\r\n\r\n            const that = this;\r\n\r\n            if (this.serviceUrl === \"\" && this.pendingUrl !== \"\") {\r\n\r\n                this.verifyUrl(this.pendingUrl, bAsync, function () {\r\n                    if (that.url !== \"\") {\r\n                        that.call(sApi, method, oApiData, bLicensed, bAsync, resolve, reject);\r\n                    }\r\n                    else {\r\n                        if (typeof reject === \"function\") {\r\n                            reject(\"Server url verification failed to set url\");\r\n                        }\r\n                    }\r\n                }, reject);\r\n            }\r\n            else {\r\n                if (this.serviceUrl !== \"\") {\r\n                    const serviceUrl = MeadCo.makeApiEndPoint(this.serviceUrl, sApi);\r\n                    const currentUrl = window.location.href;\r\n                    MeadCo.log(\"servicesServer.call() \" + method + \": \" + serviceUrl);\r\n                    let oPayload = {\r\n                        method: method,\r\n                        cache: false,\r\n                        async: bAsync,\r\n                        jsonp: false,\r\n                        dataType: \"json\",\r\n                        contentType: \"application/json\"\r\n                    };\r\n\r\n                    if (bLicensed) {\r\n                        oPayload.headers = {\r\n                            \"Authorization\": \"Basic \" + btoa(licenseGuid + \":\"),\r\n                            \"X-Meadroid-Path\": currentUrl\r\n                        }\r\n                    }\r\n                    else {\r\n                        oPayload.headers = {\r\n                            \"X-Meadroid-Path\": currentUrl\r\n                        }\r\n                    }\r\n\r\n                    if (!this.IsEmptyPayload(oApiData)) {\r\n                        MeadCo.log(\"payload defined.\");\r\n                        oPayload.data = JSON.stringify(oApiData);\r\n                    }\r\n\r\n                    if (outerScope.jQuery && !MeadCo.fetchEnabled) {\r\n                        outerScope.jQuery.ajax(serviceUrl, oPayload)\r\n                            .done(function (data) {\r\n                                if (typeof resolve === \"function\") {\r\n                                    resolve(data);\r\n                                }\r\n                                return data;\r\n                            })\r\n                            .fail(function (jqXhr, textStatus, errorThrown) {\r\n                                errorThrown = MeadCo.parseAjaxError(\"MeadCo.ScriptX.Print:\" + sApi + method, jqXhr, textStatus, errorThrown);\r\n                                if (typeof reject === \"function\")\r\n                                    reject(errorThrown);\r\n                                else {\r\n                                    throw new Error(errorThrown);\r\n                                }\r\n                            })\r\n                            .always(function (dataOrjqXHR, textStatus, jqXHRorErrorThrown) {\r\n                                that.undoTrust();\r\n                            });\r\n                    }\r\n                    else {\r\n                        if (bAsync) {\r\n                            if (bLicensed) {\r\n                                oPayload.headers = {\r\n                                    \"Authorization\": \"Basic \" + btoa(licenseGuid + \":\"),\r\n                                    \"X-Meadroid-Path\": currentUrl,\r\n                                    \"Content-type\": \"application/json\"\r\n                                }\r\n                            }\r\n                            else {\r\n                                oPayload.headers = {\r\n                                    \"X-Meadroid-Path\": currentUrl,\r\n                                    \"Content-type\": \"application/json\"\r\n                                }\r\n                            }\r\n\r\n                            const netcall = fetch(serviceUrl, {\r\n                                method: oPayload.method,\r\n                                headers: oPayload.headers,\r\n                                body: oPayload.data,\r\n                                referrerPolicy: \"origin-when-cross-origin\",\r\n                                mode: \"cors\",\r\n                                credentials: \"omit\",\r\n                                cache: \"no-store\",\r\n                                redirect: \"error\",\r\n                                keepalive: false\r\n                            })\r\n                                .then((response) => {\r\n                                    that.undoTrust();\r\n                                    if (!response.ok) {\r\n                                        // throw new Error(`HTTP Error: ${response.status}`)\r\n                                        if (response.status == 500 || response.status == 404) {\r\n                                            const err = response.text()\r\n                                                .then(errorTxt => {\r\n                                                    const errorThrown = MeadCo.parseFetchError(\"MeadCo.ScriptX.Print:\" + sApi + method, errorTxt);\r\n                                                    if (typeof reject === \"function\")\r\n                                                        reject(errorThrown);\r\n                                                    else {\r\n                                                        throw new Error(errorThrown);\r\n                                                    }\r\n                                                });\r\n                                        }\r\n                                        else {\r\n                                            if (typeof reject === \"function\")\r\n                                                reject(response.statusText);\r\n                                            else {\r\n                                                throw new Error(response.statusText);\r\n                                            }\r\n                                        }\r\n                                        return;\r\n                                    }\r\n                                    return response.json();\r\n                                })\r\n                                .then(data => {\r\n                                    if (data && typeof resolve === \"function\") {\r\n                                        resolve(data);\r\n                                    }\r\n                                })\r\n                                .catch((error) => {\r\n                                    const errorThrown = MeadCo.parseFetchError(\"MeadCo.ScriptX.Print:\" + sApi + method, error);\r\n                                    if (typeof reject === \"function\")\r\n                                        reject(errorThrown);\r\n                                    else {\r\n                                        throw new Error(errorThrown);\r\n                                    }\r\n                                });\r\n                        }\r\n                        else {\r\n                            if (typeof reject === \"function\") {\r\n                                reject(\"Synchronous Ajax calls requires jQuery\");\r\n                            }\r\n                            else\r\n                                throw new Error(\"Synchronous Ajax calls requires jQuery\");\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    if (typeof reject === \"function\") {\r\n                        reject(\"MeadCo.ScriptX.Print : server connection is not defined.\");\r\n                    }\r\n                    else\r\n                        throw new Error(\"MeadCo.ScriptX.Print : server connection is not defined.\");\r\n                }\r\n            }\r\n\r\n            return true;\r\n        },\r\n\r\n        // determine if the server is changing - domain or port has changed when not using orchestrator\r\n        IsChangingServer: function (aServerUrl) {\r\n            if (this.serviceUrl !== \"\") {\r\n\r\n                try {\r\n                    var currentUrl = new URL(this.serviceUrl);\r\n                    var newUrl = new URL(aServerUrl);\r\n\r\n                    return currentUrl.hostname != newUrl.hostname || (currentUrl.port != newUrl.port && this.orchestratorPort == 0);\r\n                } catch (e) {\r\n                    MeadCo.error(\"Failed to construct URL(): \" + e.message + \", from: \" + this.serviceUrl + \", or: \" + aServerUrl);\r\n                    MeadCo.error(\"Many errors will ensue\");\r\n                    return false; // will stop attempts to use something bad.\r\n                }\r\n            }\r\n\r\n            return true;\r\n        },\r\n\r\n        IsEmptyPayload(oPayload) {\r\n            return oPayload === null || (Object.keys(oPayload).length === 0 && oPayload.constructor === Object);\r\n        },\r\n\r\n        // bad news to retest ports on a host that has already been tried, in a page lifetime, it isnt going to get any better.\r\n        IsFailedConnection: function (aServerUrl) {\r\n            if (this.failedUrl.length > 0) {\r\n                try {\r\n                    var failedUrl = new URL(this.failedUrl);\r\n                    var newUrl = new URL(aServerUrl);\r\n\r\n                    if (failedUrl.hostname === newUrl.hostname) {\r\n                        MeadCo.warn(\"Attempt to use: \" + aServerUrl + \" is noted as a failed connection and will not be retried\");\r\n                        return true;\r\n                    }\r\n\r\n                    return false;\r\n                } catch (e) {\r\n                    MeadCo.error(\"Testing IsFailed unable to construct URL(): \" + e.message + \", from: \" + this.failedUrl + \", or: \" + aServerUrl);\r\n                    return true; // will stop attempts to use something bad.\r\n                }\r\n            }\r\n\r\n            return false;\r\n        }\r\n    };\r\n\r\n    var licenseGuid = \"\";\r\n    var bConnected = false; // true when default device settings have been obtained from a .services server\r\n\r\n    var bDoneAuto = false;\r\n\r\n    var availablePrinters = [];\r\n\r\n    var cachedServiceDescription = null; // cached description of service server connected to \r\n\r\n    /**\r\n     * Enum for type of content being posted to printHtml API\r\n     *\r\n     * @memberof MeadCoScriptXPrint    \r\n     * @typedef {number} ContentType\r\n     * @enum {ContentType}\r\n     * @readonly\r\n     * @property {number} URL 1 the url will be downloaded and printed\r\n     * @property {number} HTML 2 the passed string is assumed to be a complete html document .. <html>..</html>\r\n     * @property {number} INNERHTML 4 the passed string is a complete html document but missing the html tags\r\n     * @property {number} STRING 8 the passed string is assumed to contain no html but may contain other language such as ZPL (for direct printing)\r\n     */\r\n    var enumContentType = {\r\n        URL: 1, // the url will be downloaded and printed (for html and direct printing)\r\n        HTML: 2, // the passed string is assumed to be a complete html document .. <html>..</html>\r\n        INNERHTML: 4, // the passed string is a complete html document but missing the html tags\r\n        STRING: 8 // the passed string is assumed to contain no html but may contain other language such as ZPL (for direct printing)\r\n    };\r\n\r\n    var enumResponseStatus = {\r\n        UNKNOWN: 0,\r\n        QUEUEDTODEVICE: 1,\r\n        QUEUEDTOFILE: 2,\r\n        SOFTERROR: 3,\r\n        OK: 4\r\n    };\r\n\r\n    /**\r\n     * Enum for required behaviour when an error occurs. \r\n     *\r\n     * @memberof MeadCoScriptXPrint    \r\n     * @typedef {number} ErrorAction\r\n     * @enum {ErrorAction}\r\n     * @readonly\r\n     * @property {number} REPORT 1 Call MeadCo.ScriptX.Print.reportServerError(errMsg)\r\n     * @property {number} THROW 2 throw an error : throw errMsg\r\n     */\r\n    var enumErrorAction = {\r\n        REPORT: 1,\r\n        THROW: 2\r\n    };\r\n    var errorAction = enumErrorAction.REPORT;\r\n\r\n    /**\r\n     * Enum for the class of service connected to.\r\n     * \r\n     * @memberof MeadCoScriptXPrint\r\n     * @typedef { number } ServiceClasses\r\n     * @enum { ServiceClasses }\r\n     * @readonly \r\n     * @property { number } CLOUD 1 MeadCo Cloud Service \r\n     * @property { number } ONPREMISE 2 ScriptX.Services for On Premise Devices\r\n     * @property { number } WINDOWSPC 3 ScriptX.Services for Windows PC\r\n     * */\r\n    var enumServiceClass = {\r\n        CLOUD: 1,\r\n        ONPREMISE: 2,\r\n        WINDOWSPC: 3\r\n    };\r\n\r\n    /**\r\n     * Information about the service that is connected to - version detail and facilities available\r\n     * See also: https://www.meadroid.com/Developers/KnowledgeBank/TechnicalReference/ScriptXServices/WebServiceAPIReference/ServiceDescription/GET\r\n     * \r\n     * @typedef ServiceDescriptionObject\r\n     * @memberof MeadCoScriptXPrint\r\n     * @property {ServiceClasses} serviceClass the class of the service; cloud, onpremise, pc\r\n     * @property {string} currentAPIVersion the latest version implemented (eg 'v1' or 'v2' etc)\r\n     * @property {VersionObject} serviceVersion implementation version of the service\r\n     * @property {VersionObject} serverVersion The version of ScriptX Server used by the service\r\n     * @property {VersionObject} serviceUpgrade The latest version of the service that is available and later than ServiceVersion/me \r\n     * @property {Array.<string>} availablePrinters Array of the names of the available printers\r\n     * @property {boolean} printHTML Printing of HTML is supported\r\n     * @property {boolean} printPDF Printing of PDF documents is supported\r\n     * @property {boolean} printDIRECT Direct printing to a print device is supported\r\n     * */\r\n    var ServiceDescriptionObject; // for Doc Generator\r\n\r\n    /**\r\n     * Enum for status code returned to print progress callbacks\r\n     *\r\n     * @memberof MeadCoScriptXPrint    \r\n     * @typedef {number} PrintStatus\r\n     * @enum {PrintStatus}\r\n     * @readonly\r\n     * @property {number} NOTSTARTED 0\r\n     * @property {number} QUEUED 1\r\n     * @property {number} STARTING 2\r\n     * @property {number} DOWNLOADING 3\r\n     * @property {number} DOWNLOADED 4\r\n     * @property {number} PRINTING 5\r\n     * @property {number} COMPLETED 6\r\n     * @property {number} PAUSED 7\r\n     * @property {number} PRINTPDF 8\r\n     * @property {number} ERROR -1\r\n     * @property {number} ABANDONED -2\r\n     *\r\n     * These are internal and should not be seen. However it is known CODEEXEPTION can leak and be seen.\r\n     * @property {number} COLLECTED 100\r\n     * @property {number} CODEEXEPTION 101\r\n     * @property {number} COMPLETEDWAITINGFORCOLLECTION 102\r\n     */\r\n    var enumPrintStatus = {\r\n        NOTSTARTED: 0,\r\n\r\n        // queue call back opcodes ...\r\n        QUEUED: 1,\r\n        STARTING: 2,\r\n        DOWNLOADING: 3,\r\n        DOWNLOADED: 4,\r\n        PRINTING: 5,\r\n        COMPLETED: 6,\r\n        PAUSED: 7,\r\n        PRINTPDF: 8,\r\n\r\n        ERROR: -1,\r\n        ABANDONED: -2\r\n    };\r\n\r\n    /**\r\n     * Enum to describe the collation option when printing \r\n     *\r\n     * @memberof MeadCoScriptXPrint   \r\n     * @typedef {number} CollateOptions\r\n     * @enum {CollateOptions}\r\n     * @readonly\r\n     * @property {number} DEFAULT 0 use the default at the print server\r\n     * @property {number} TRUE 1 collate pages when printing\r\n     * @property {number} FALSE 2 do not collate pages\r\n     */\r\n    var enumCollateOptions = {\r\n        DEFAULT: 0,\r\n        TRUE: 1,\r\n        FALSE: 2\r\n    };\r\n\r\n    /**\r\n     * Enum to describe the duplex print option to use when printing \r\n     *\r\n     * @memberof MeadCoScriptXPrint\r\n     * @typedef {number} DuplexOptions\r\n     * @enum {DuplexOptions}\r\n     * @readonly\r\n     * @property {number} DEFAULT 0 use the default at the print server\r\n     * @property {number} SIMPLEX 1 \r\n     * @property {number} VERTICAL 2 \r\n     * @property {number} HORIZONTAL 3\r\n     */\r\n    var enumDuplexOptions = {\r\n        DEFAULT: 0,\r\n        SIMPLEX: 1,\r\n        VERTICAL: 2,\r\n        HORIZONTAL: 3\r\n    };\r\n\r\n    function queueJob(data) {\r\n        activePrintQueue.push(data);\r\n        MeadCo.log(\"ScriptX.Print queueJob: \" + data.jobIdentifier + \", name: \" + data.jobName + \", jobCount: \" + activePrintQueue.length);\r\n    }\r\n\r\n    function jobCount() {\r\n        MeadCo.log(\"ScriptX.Print jobCount: \" + activePrintQueue.length);\r\n        return activePrintQueue.length;\r\n    }\r\n\r\n    function findJob(id) {\r\n        return activePrintQueue.find(e => e.jobIdentifier === id);\r\n    }\r\n\r\n    function updateJob(data) {\r\n        let j = findJob(data.jobIdentifier);\r\n        if (j) {\r\n            Object.keys(data).forEach(function (key) {\r\n                j[key] = data[key];\r\n            });\r\n            return;\r\n        }\r\n\r\n        MeadCo.warn(\"Unable to find job: \" + data.jobIdentifier + \" to update it\");\r\n    }\r\n\r\n    function removeJob(id) {\r\n\r\n        activePrintQueue = activePrintQueue.filter(e => e.jobIdentifier !== id);\r\n        MeadCo.log(`ScriptX.Print removed job: ${id}, jobCount: ${activePrintQueue.length}`);\r\n        // no jobs being processed, allow next immediate start\r\n        if (activePrintQueue.length == 0) previousPrintCallWasAt = 0;\r\n\r\n    }\r\n\r\n    function progress(requestData, status, information) {\r\n        if (typeof requestData.OnProgress === \"function\") {\r\n            requestData.OnProgress(status, information, requestData.UserData);\r\n        }\r\n    }\r\n\r\n    // funcPrintHtmlAtServer\r\n    //\r\n    // Create a closure on all the data for a print job which can be used with timeout.\r\n    //\r\n    var nextJobFileName = \"\";\r\n    function funcPrintHtmlAtServer(contentType, content, htmlPrintSettings, trackingData, fnDone, fnProgress, fnOnQueuedFileAvailable) {\r\n        MeadCo.log(\"started MeadCo.ScriptX.Print.print.printHtmlAtServer() Type: \" + contentType);\r\n        if (contentType === enumContentType.URL) {\r\n            MeadCo.log(\".. request print url: \" + content);\r\n        }\r\n\r\n        // must deepclone objects not values by reference.\r\n        var devInfo;\r\n        if (printerName === \"\") {\r\n            devInfo = {};\r\n        } else {\r\n            if (printerName === magicPrintPreviewPrinter) {\r\n                devInfo = JSON.parse(JSON.stringify({\r\n                    printerName: printerName\r\n                }));\r\n            }\r\n            else\r\n                devInfo = JSON.parse(JSON.stringify(deviceSettings[printerName]));\r\n        }\r\n\r\n        var requestData = {\r\n            ContentType: contentType,\r\n            Content: content,\r\n            Settings: JSON.parse(JSON.stringify(htmlPrintSettings)),\r\n            Device: devInfo,\r\n            ProtectedContentAccess: AccessControl,\r\n            OnProgress: fnProgress,\r\n            UserData: trackingData\r\n        };\r\n\r\n        var fakeJob = {\r\n            jobIdentifier: Date.now(),\r\n            printerName: requestData.Device.printerName,\r\n            jobName: jobNameWaitingForSend\r\n        };\r\n        queueJob(fakeJob); // essentially a lock on the queue to stop it looking empty until this job is processed\r\n\r\n        var requiredOutputName = nextJobFileName;\r\n        nextJobFileName = \"\";\r\n\r\n        var fnOnFileAvailable = fnOnQueuedFileAvailable;\r\n\r\n        return function () {\r\n            removeJob(fakeJob.jobIdentifier);\r\n            return printAtServer(htmlApiLocation, requestData,\r\n                {\r\n                    fail: function (err) {\r\n                        progress(requestData, enumPrintStatus.ERROR, err);\r\n                        MeadCo.ScriptX.Print.reportError(err);\r\n                        if (typeof fnDone === \"function\") {\r\n                            fnDone(\"Server error\");\r\n                        }\r\n                    },\r\n\r\n                    queuedToFile: function (data) {\r\n                        MeadCo.log(\"print is being queued to a file\");\r\n                        progress(requestData, enumPrintStatus.QUEUED);\r\n                        monitorJob(htmlApiLocation, requestData, data.jobIdentifier,\r\n                            -1,\r\n                            function (data) {\r\n                                if (data !== null) {\r\n                                    MeadCo.log(\"download printed file is available\");\r\n                                    progress(requestData, enumPrintStatus.COMPLETED);\r\n\r\n                                    var api = MeadCo.makeApiEndPoint(servicesServer.url, htmlApiLocation + \"/download/\" + data.jobIdentifier);\r\n                                    if (requiredOutputName.length > 0) {\r\n                                        api += \"/\" + requiredOutputName;\r\n                                    }\r\n                                    fnOnFileAvailable(api, data.jobIdentifier);\r\n                                }\r\n\r\n                                if (typeof fnDone === \"function\") {\r\n                                    fnDone(data === null ? \"Server error\" : null);\r\n                                }\r\n                            });\r\n                    },\r\n\r\n                    queuedToDevice: function (data) {\r\n                        MeadCo.log(\"print was queued to device\");\r\n                        progress(requestData, enumPrintStatus.QUEUED);\r\n                        monitorJob(htmlApiLocation, requestData, data.jobIdentifier,\r\n                            -1,\r\n                            function (data) {\r\n                                if (data !== null) {\r\n                                    progress(requestData, enumPrintStatus.COMPLETED);\r\n                                }\r\n\r\n                                if (typeof fnDone === \"function\") {\r\n                                    fnDone(data === null ? \"Server error\" : null);\r\n                                }\r\n                            });\r\n                    },\r\n\r\n                    softError: function (data) {\r\n                        progress(requestData, enumPrintStatus.ERROR, data.message);\r\n                        MeadCo.ScriptX.Print.reportError(data.message);\r\n                        MeadCo.log(\"print has soft error\");\r\n                        removeJob(data.jobIdentifier);\r\n                        if (typeof fnDone === \"function\") {\r\n                            MeadCo.log(\"Call fnDone\");\r\n                            fnDone(data.message);\r\n                        }\r\n                    },\r\n\r\n                    ok: function (data) {\r\n                        progress(requestData, enumPrintStatus.COMPLETED);\r\n                        MeadCo.log(\"printed ok, no further information\");\r\n                        removeJob(data.jobIdentifier);\r\n                        if (typeof fnDone === \"function\") {\r\n                            fnDone(null);\r\n                        }\r\n                    }\r\n                })\r\n        };\r\n    }\r\n\r\n\r\n    /**\r\n     * Post a request to the server api/v1/print to print some html and monitor the print job \r\n     * to completion. If the server prints to file then the file is returned as a download.\r\n     * \r\n     * There is no guarantee of the order of outgoing calls, no guarantee they will ber processed in \r\n     * order at the server if they go from the client very quickly. ScriptX.Addon printHtml() was \r\n     * deterministic in its order - jobs were printed in the order of the calls. In order to \r\n     * achieve this without a push pull queue rapid calls are spaced a part via settimeout()\r\n     * \r\n     * @function printHtmlAtServer\r\n     * @memberof MeadCoScriptXPrint\r\n\r\n     * @param {ContentType} contentType enum type of content given (html snippet, url)\r\n     * @param {string} content the content - a url, html snippet or complete html\r\n     * @param {object} htmlPrintSettings the settings to use - page and html such as headers and footers\r\n     * @param {function({string})} fnDone function to call when printing complete (and output returned), arg is null on no error, else error message\r\n     * @param {function(status,sInformation,data)} fnProgress function to call when job status is updated\r\n     * @param {any} trackingData object to give pass to fnProgress\r\n     * @return {boolean} - true if a print was started (otherwise an error will be thrown)\r\n     * @private\r\n     */\r\n    var timeoutToJobStart = 0;\r\n    var previousPrintCallWasAt = 0;\r\n    var timeoutSpacingMSecs = 750;\r\n    var jobGapResetTimeout = 10000;\r\n    function printHtmlAtServer(contentType, content, htmlPrintSettings, fnDone, fnProgress, trackingData) {\r\n\r\n        if (!content || (typeof content === \"string\" && content.length === 0)) {\r\n            MeadCo.ScriptX.Print.reportError(\"Request to print no content - access denied?\");\r\n            if (typeof fnDone === \"function\") {\r\n                fnDone(\"Request to print no content\");\r\n            }\r\n            return false;\r\n        }\r\n\r\n        // if previous call was over (default) 10 seconds ago, reset\r\n        var t = Date.now();\r\n        if ((t - previousPrintCallWasAt) > jobGapResetTimeout) {\r\n            timeoutToJobStart = 0;\r\n        }\r\n        previousPrintCallWasAt = t;\r\n        setTimeout(funcPrintHtmlAtServer(contentType, content, htmlPrintSettings, trackingData, fnDone, fnProgress, function (sApi) {\r\n            window.open(sApi, \"_self\");\r\n        }), timeoutToJobStart);\r\n        timeoutToJobStart += timeoutSpacingMSecs;\r\n        return true;\r\n    }\r\n\r\n    // funcPrintPdfAtServer\r\n    //\r\n    // Create a closure on all the data for a print job which can be used with timeout.\r\n    //\r\n    function funcPrintPdfAtServer(document, pdfPrintSettings, fnDone, fnProgress, data) {\r\n\r\n        MeadCo.log(\"started MeadCo.ScriptX.Print.print.printPdfAtServer() document: \" + document + \", printerName: \" + printerName);\r\n\r\n        let devInfo;\r\n        // deep clones of objects\r\n        if (printerName === \"\") {\r\n            devInfo = {};\r\n        } else {\r\n            devInfo = JSON.parse(JSON.stringify(deviceSettings[printerName]));\r\n        }\r\n\r\n        const requestData = {\r\n            Document: document,\r\n            Description: pdfPrintSettings.jobDescription,\r\n            Settings: JSON.parse(JSON.stringify(pdfPrintSettings)),\r\n            Device: devInfo,\r\n            ProtectedContentAccess: AccessControl,\r\n            OnProgress: fnProgress,\r\n            UserData: data\r\n        };\r\n\r\n        // used/required by printAtServer ...\r\n        requestData.Settings.jobTitle = pdfPrintSettings.jobDescription;\r\n\r\n        const fakeJob = {\r\n            jobIdentifier: Date.now(),\r\n            printerName: requestData.Device.printerName,\r\n            jobName: jobNameWaitingForSend\r\n        };\r\n        queueJob(fakeJob); // essentially a lock on the queue to stop it looking empty until this job is processed\r\n\r\n        var requiredOutputName = nextJobFileName;\r\n        nextJobFileName = \"\";\r\n\r\n        return function () {\r\n            removeJob(fakeJob.jobIdentifier);\r\n            return printAtServer(pdfApiLocation, requestData,\r\n                {\r\n                    fail: function (err) {\r\n                        progress(requestData, enumPrintStatus.ERROR, err);\r\n                        MeadCo.ScriptX.Print.reportError(err);\r\n                        if (typeof fnDone === \"function\") {\r\n                            fnDone(\"Server error\");\r\n                        }\r\n                    },\r\n\r\n                    queuedToFile: function (data) {\r\n                        MeadCo.log(\"default handler on queued to file response\");\r\n                        progress(requestData, enumPrintStatus.QUEUED);\r\n                        monitorJob(pdfApiLocation, requestData, data.jobIdentifier,\r\n                            -1,\r\n                            function (data) {\r\n                                if (data !== null) {\r\n                                    MeadCo.log(\"Will download printed file\");\r\n                                    progress(requestData, enumPrintStatus.COMPLETED);\r\n                                    let api = MeadCo.makeApiEndPoint(servicesServer.url, pdfApiLocation + \"/download/\" + data.jobIdentifier);\r\n                                    if (requiredOutputName.length > 0) {\r\n                                        api += \"/\" + requiredOutputName;\r\n                                    }\r\n                                    window.open(api, \"_self\");\r\n                                }\r\n\r\n                                if (typeof fnDone === \"function\") {\r\n                                    fnDone(data === null ? \"Server error\" : null);\r\n                                }\r\n                            });\r\n                    },\r\n\r\n                    queuedToDevice: function (data) {\r\n                        MeadCo.log(\"print was queued to device\");\r\n                        progress(requestData, enumPrintStatus.QUEUED);\r\n                        monitorJob(pdfApiLocation, requestData, data.jobIdentifier,\r\n                            -1,\r\n                            function (data) {\r\n                                if (data !== null) {\r\n                                    progress(requestData, enumPrintStatus.COMPLETED);\r\n                                }\r\n\r\n                                if (typeof fnDone === \"function\") {\r\n                                    fnDone(data === null ? \"Server error\" : null);\r\n                                }\r\n                            });\r\n                    },\r\n\r\n                    softError: function (data) {\r\n                        progress(requestData, enumPrintStatus.ERROR, data.message);\r\n                        MeadCo.ScriptX.Print.reportError(data.message);\r\n                        MeadCo.log(\"printpdf call has soft error, remove job: \" + data.jobIdentifier);\r\n                        removeJob(data.jobIdentifier);\r\n                        if (typeof fnDone === \"function\") {\r\n                            MeadCo.log(\"Call fnDone\");\r\n                            fnDone(\"Server error\");\r\n                        }\r\n                    },\r\n\r\n                    ok: function (data) {\r\n                        progress(requestData, enumPrintStatus.COMPLETED);\r\n                        MeadCo.log(\"printed ok, no further information\");\r\n                        removeJob(data.jobIdentifier);\r\n                        if (typeof fnDone === \"function\") {\r\n                            fnDone(null);\r\n                        }\r\n                    }\r\n                });\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Post a request to the server api/v1/print to print a pdf document and monitor the print job \r\n     * to completion. If the server prints to file then the file is returned as a download\r\n     * \r\n     * @function printPdfAtServer\r\n     * @memberof MeadCoScriptXPrint\r\n     * @param {string} document full url to the pdf document to be printed\r\n     * @param {object} pdfPrintSettings the settings to use such as rotation, scaling. device settings (printer to use, copies etc) are taken from this static\r\n     * @param {function({string})} fnDone function to call when printing complete (and output returned), arg is null on no error, else error message.\r\n     * @param {function(status,sInformation,data)} fnProgress function to call when job status is updated\r\n     * @param {any} data object to give pass to fnProgress\r\n     * @return {boolean} - true if a print was started (otherwise an error will be thrown)\r\n     * @private\r\n     */\r\n    function printPdfAtServer(document, pdfPrintSettings, fnDone, fnProgress, data) {\r\n\r\n        if (!document || (typeof document === \"string\" && document.length === 0)) {\r\n            MeadCo.ScriptX.Print.reportError(\"The document to print must be given.\");\r\n            if (typeof fnDone === \"function\") {\r\n                fnDone(\"Request to print no content\");\r\n            }\r\n            return false;\r\n        }\r\n\r\n        // if previous call was over (default) 10 seconds ago, reset\r\n        const t = Date.now();\r\n        if ((t - previousPrintCallWasAt) > jobGapResetTimeout) {\r\n            timeoutToJobStart = 0;\r\n        }\r\n        previousPrintCallWasAt = t;\r\n        setTimeout(funcPrintPdfAtServer(document, pdfPrintSettings, fnDone, fnProgress, data), timeoutToJobStart);\r\n        timeoutToJobStart += timeoutSpacingMSecs;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n      * Post a request to the server api/v1/printDirect to print a string directly to the current printer. The print is synchronous at the server\r\n      * and is completed (sent to the printer) when the api returns.\r\n      * \r\n      * @function printDirectAtServer\r\n      * @memberof MeadCoScriptXPrint\r\n \r\n      * @param {ContentType} contentType enum type of content given (string or url)\r\n      * @param {string} content the content - a url, or string containing e.g. zpl.\r\n      * @param {function({string})} fnDone function to call when printing complete, arg is null on no error, else error message\r\n      * @return {boolean} - true if a print was started (otherwise an error will be thrown)\r\n      * @private\r\n      */\r\n    function printDirectAtServer(contentType, content, fnDone) {\r\n        MeadCo.log(\"started MeadCo.ScriptX.Print.print.printDirectAtServer() Type: \" + contentType + \", printerName: \" + printerName);\r\n        if (contentType === enumContentType.URL) {\r\n            MeadCo.log(\".. request print url: \" + content);\r\n        }\r\n        else {\r\n            if (contentType !== enumContentType.STRING) {\r\n                MeadCo.ScriptX.Print.reportError(\"Bad content type for direct printing\");\r\n                if (typeof fnDone === \"function\") {\r\n                    fnDone(\"Bad content type for direct printing\");\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n\r\n        if (!content || (typeof content === \"string\" && content.length === 0)) {\r\n            MeadCo.ScriptX.Print.reportError(\"Request to print no content - access denied?\");\r\n            if (typeof fnDone === \"function\") {\r\n                fnDone(\"Request to print no content\");\r\n            }\r\n            return false;\r\n        }\r\n\r\n        if (printerName === \"\") {\r\n            MeadCo.ScriptX.Print.reportError(\"Request to print but no current printer defined.\");\r\n            if (typeof fnDone === \"function\") {\r\n                fnDone(\"Request to print but no current printer defined.\");\r\n            }\r\n            return false;\r\n        }\r\n\r\n        const requestData = {\r\n            ContentType: contentType,\r\n            Content: content,\r\n            PrinterName: printerName,\r\n            Settings: {\r\n                jobTitle: \"Direct print\" // not required by the server .. used by printAtServer()\r\n            },\r\n            Device: deviceSettings[printerName] // not required by the server .. used by printAtServer()\r\n        };\r\n\r\n        return printAtServer(directApiLocation, requestData,\r\n            {\r\n                fail: function (err) {\r\n                    MeadCo.ScriptX.Print.reportError(err);\r\n                    if (typeof fnDone === \"function\") {\r\n                        fnDone(\"Server error\");\r\n                    }\r\n                },\r\n\r\n                softError: function (data) {\r\n                    MeadCo.ScriptX.Print.reportError(data.message);\r\n                    MeadCo.log(\"print has soft error\");\r\n                    removeJob(data.jobIdentifier);\r\n                    if (typeof fnDone === \"function\") {\r\n                        MeadCo.log(\"Call fnDone\");\r\n                        fnDone(data.message);\r\n                    }\r\n                },\r\n\r\n                ok: function (data) {\r\n                    MeadCo.log(\"printed ok, no further information\");\r\n                    removeJob(data.jobIdentifier); // for direct, by definition there is no queued response\r\n                    if (typeof fnDone === \"function\") {\r\n                        fnDone(null);\r\n                    }\r\n                }\r\n            });\r\n    }\r\n\r\n    // set the ScriptX.Services server to use and the client license/subscription id\r\n    //\r\n    // Both arguments are optional, leaving the current values in place.\r\n    //\r\n    // All connection etc calls route to here, so here is the place to determine the port\r\n    // number to use.\r\n    //\r\n    function setServer(serverUrl, clientLicenseGuid, resolve, reject) {\r\n        if (typeof serverUrl === \"string\" && serverUrl.length > 0) {\r\n            MeadCo.log(\"Print server requested: \" + serverUrl + \" with license: \" + clientLicenseGuid);\r\n\r\n            licenseGuid = typeof clientLicenseGuid === \"string\" && clientLicenseGuid.length > 0 ? clientLicenseGuid : licenseGuid;\r\n            printerName = \"\";\r\n            deviceSettings = {};\r\n            activePrintQueue = []; // warning, will kill any current monitoring\r\n            bConnected = false;\r\n            availablePrinters = [];\r\n\r\n            if (typeof resolve == \"function\") {\r\n                servicesServer.setUrlAsync(serverUrl, resolve, reject);\r\n            }\r\n            else {\r\n                servicesServer.url = serverUrl;\r\n            }\r\n        }\r\n        else {\r\n            MeadCo.log(\"Print server retained in setServer: \" + servicesServer.url + \" may update with license: {\" + clientLicenseGuid + \"} (if provided)\");\r\n            licenseGuid = typeof clientLicenseGuid === \"string\" && clientLicenseGuid.length > 0 ? clientLicenseGuid : licenseGuid;\r\n        }\r\n    }\r\n\r\n    function connectToServer(serverUrl, clientLicenseGuid) {\r\n        setServer(serverUrl, clientLicenseGuid);\r\n        // note that this will silently fail if no advanced printing license\r\n        getDeviceSettings({ name: \"systemdefault\", async: false });\r\n\r\n        // also (async) cache server description\r\n        getFromServer(\"\", true,\r\n            function (data) {\r\n                cachedServiceDescription = data;\r\n            });\r\n    }\r\n\r\n    function connectToServerAsync(serverUrl, clientLicenseGuid, resolve, reject) {\r\n        setServer(serverUrl, clientLicenseGuid, function (foundUrl) {\r\n            // note that this will silently fail if no advanced printing license\r\n            getDeviceSettings({\r\n                name: \"systemdefault\",\r\n                done: resolve,\r\n                async: true,\r\n                fail: reject\r\n            });\r\n\r\n            // also (async) cache server description\r\n            getFromServer(\"\", true,\r\n                function (data) {\r\n                    cachedServiceDescription = data;\r\n                });\r\n        }, reject);\r\n    }\r\n\r\n    /**\r\n     * Post a request to print\r\n     * \r\n     * @param {string} sApi The server api endpoint (e.g. api/printhtml). The method '/print' will be added. \r\n     * @param {object} requestData The data to be posted\r\n     * @param {functionList} responseInterface Callbacks to process responses\r\n     * @returns {bool} true if request sent\r\n     */\r\n    function printAtServer(sApi, requestData, responseInterface) {\r\n\r\n        const fakeJob = {\r\n            jobIdentifier: Date.now(),\r\n            printerName: requestData.Device.printerName,\r\n            jobName: jobNameSentWaitingResponse\r\n        };\r\n\r\n        MeadCo.log(\"printAtServer using: \" + sApi);\r\n\r\n        queueJob(fakeJob); // essentially a lock on the queue to stop it looking empty while we await the result\r\n\r\n        return callService(sApi + \"/print\", \"POST\", requestData, true, true, (data) => {\r\n            MeadCo.log(\"Success response: \" + data.status);\r\n            data.printerName = requestData.Device.printerName;\r\n            data.jobName = typeof requestData.Settings.jobTitle === \"string\" && requestData.Settings.jobTitle.length > 0 ? requestData.Settings.jobTitle : \"server job\";\r\n            queueJob(data);\r\n            removeJob(fakeJob.jobIdentifier);\r\n            switch (data.status) {\r\n                case enumResponseStatus.QUEUEDTOFILE:\r\n                    responseInterface.queuedToFile(data);\r\n                    break;\r\n\r\n                case enumResponseStatus.QUEUEDTODEVICE:\r\n                    responseInterface.queuedToDevice(data);\r\n                    break;\r\n\r\n                case enumResponseStatus.SOFTERROR:\r\n                case enumResponseStatus.UNKNOWN:\r\n                    responseInterface.softError(data);\r\n                    break;\r\n\r\n                case enumResponseStatus.OK:\r\n                    responseInterface.ok(data);\r\n                    break;\r\n            }\r\n        },\r\n            (errMsg) => {\r\n                removeJob(fakeJob.jobIdentifier);\r\n                if (typeof responseInterface.fail === \"function\") {\r\n                    responseInterface.fail(errMsg);\r\n                }\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Call an API on the server with GET\r\n     * \r\n     * @function getFromServer\r\n     * @memberof MeadCoScriptXPrint\r\n     * @param {string} sApi the api to call on the connected server\r\n     * @param {bool} async true for asynchronous call, false for synchronous \r\n     * @param {function} onSuccess function to call on success\r\n     * @param {function(errorText)} onFail function to call on failure\r\n     * @private\r\n     */\r\n    function getFromServer(sApi, async, onSuccess, onFail) {\r\n        return callService(sApi, \"GET\", null, true, async, onSuccess, onFail);\r\n    }\r\n\r\n    function callService(sApi, httpMethod, oApiData, bLicensed, bAsync, resolve, reject) {\r\n        return servicesServer.call(sApi, httpMethod, oApiData, bLicensed, bAsync, resolve, reject);\r\n    }\r\n\r\n    function processMonitorResponse(requestData, data, intervalId, jobId, timeOut, functionComplete) {\r\n        MeadCo.log(\"processMonitorResponse::jobStatus: \" + data.status);\r\n        switch (data.status) {\r\n            case enumPrintStatus.COMPLETED:\r\n                MeadCo.log(\"clear interval: \" + intervalId);\r\n                window.clearInterval(intervalId);\r\n                removeJob(jobId);\r\n                functionComplete(data);\r\n                break;\r\n\r\n            case enumPrintStatus.NOTSTARTED:\r\n            case enumPrintStatus.DOWNLOADED:\r\n            case enumPrintStatus.DOWNLOADING:\r\n            case enumPrintStatus.PRINTING:\r\n            case enumPrintStatus.QUEUED:\r\n            case enumPrintStatus.STARTING:\r\n            case enumPrintStatus.PAUSED:\r\n            case enumPrintStatus.PRINTPDF:\r\n                progress(requestData, data.status, data.message);\r\n                updateJob(data);\r\n                // keep going\r\n                if (timeOut > 0 && (++counter * interval) > timeOut) {\r\n                    window.clearInterval(intervalId);\r\n                    MeadCo.ScriptX.Print.reportError(\"unknown failure while printing.\");\r\n                }\r\n                break;\r\n\r\n            case enumPrintStatus.ERROR:\r\n            case enumPrintStatus.ABANDONED:\r\n            case enumPrintStatus.CODEEXEPTION:\r\n                MeadCo.log(\"error status in processMonitorResponse so clear interval: \" + intervalId);\r\n                progress(requestData, data.status, data.message);\r\n                removeJob(jobId);\r\n                window.clearInterval(intervalId);\r\n                MeadCo.ScriptX.Print.reportError(\"The print failed with the error: \" + data.message);\r\n                functionComplete(null);\r\n                break;\r\n\r\n            default:\r\n                progress(requestData, data.status, data.message);\r\n                MeadCo.log(\"unknown status in processMonitorResponse so clear interval: \" + intervalId);\r\n                removeJob(jobId);\r\n                window.clearInterval(intervalId);\r\n                functionComplete(null);\r\n                break;\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * Monitor a job that has been known to start  on the server. Get job status from the server and record in the job queue \r\n     * and process status appropriately. Progress callbacks will occur.\r\n     * \r\n     * @function monitorJob\r\n     * @memberof MeadCoScriptXPrint\r\n     * @param {string} serverAndApi The server api endpoint (e.g. api/printhtml). The method '/status/' will be added.\r\n     * @param {string} requestData The original data sent with the print request\r\n     * @param {string} jobId The id return from the server for the job (to be monitored)\r\n     * @param {number} timeOut Time give the job to complete or assume has got stuck, -1 means no timeout.\r\n     * @param {function({object})} functionComplete function to call when job is complete. Argument is null on error, the data returned from the status call on success,.\r\n     * @private\r\n     */\r\n    function monitorJob(sApi, requestData, jobId, timeOut, functionComplete) {\r\n        MeadCo.log(\"monitorJob: \" + jobId);\r\n        const interval = 1000;\r\n        let bWaiting = false;\r\n        let intervalId = window.setInterval(function () {\r\n            if (!bWaiting) {\r\n                bWaiting = true; // ensure if the interval fires again before the last call response has been dealt with, wait till next interval until it has been dealt with\r\n                getFromServer(sApi + \"/status/\" + jobId, true, (data) => {\r\n                    processMonitorResponse(requestData, data, intervalId, jobId, timeOut, functionComplete);\r\n                    bWaiting = false;\r\n                },\r\n                    (errorThrown) => {\r\n                        MeadCo.log(\"error: \" + errorThrown + \" in monitorJob so clear interval: \" + intervalId);\r\n                        progress(requestData, enumPrintStatus.ERROR, errorThrown);\r\n                        removeJob(jobId);\r\n                        window.clearInterval(intervalId);\r\n                        functionComplete(null);\r\n                        bWaiting = false;\r\n                    });\r\n            } else {\r\n                MeadCo.log(\"** info : still waiting for last status request to complete\");\r\n            }\r\n        }, interval);\r\n\r\n        MeadCo.log(\"intervalId: \" + intervalId);\r\n    }\r\n\r\n    function addOrUpdateDeviceSettings(data) {\r\n        if (typeof data.printerName === \"string\") {\r\n            if (data.isDefault) {\r\n                for (var i = 0; i < deviceSettings.length; i++) {\r\n                    deviceSettings[i].isDefault = false;\r\n                }\r\n            }\r\n\r\n            deviceSettings[data.printerName] = data;\r\n            if (data.isDefault && printerName.length === 0) {\r\n                printerName = data.printerName;\r\n            }\r\n        }\r\n    }\r\n\r\n    function getDeviceSettings(oRequest) {\r\n        oRequest.name = oRequest.name.replace(/\\\\/g, \"||\");\r\n        MeadCo.log(\"Request get device info: \" + oRequest.name);\r\n\r\n        getFromServer(htmlApiLocation + \"/deviceinfo/\" + encodeURIComponent(oRequest.name) + \"/0\", oRequest.async,\r\n            function (data) {\r\n                bConnected = true;\r\n                addOrUpdateDeviceSettings(data);\r\n                if (typeof oRequest.done === \"function\") {\r\n                    oRequest.done(data);\r\n                }\r\n            },\r\n            function (errTxt) {\r\n                if (oRequest.name === \"systemdefault\") {\r\n                    MeadCo.warn(\"request for systemdefault printer failed - please update to ScriptX.Services 2.11.1\");\r\n                    oRequest.name = \"default\";\r\n                    getDeviceSettings(oRequest);\r\n                }\r\n                else {\r\n                    MeadCo.log(\"failed to getdevice: \" + errTxt);\r\n\r\n                    if (typeof oRequest.fail === \"function\") {\r\n                        oRequest.fail(errTxt);\r\n                    }\r\n                }\r\n            }\r\n        );\r\n\r\n    }\r\n\r\n    function getDeviceSettingsFor(sPrinterName) {\r\n        if (typeof sPrinterName === \"string\" && sPrinterName !== \"\") {\r\n            if (typeof deviceSettings[sPrinterName] === \"undefined\") {\r\n                getDeviceSettings({\r\n                    name: sPrinterName,\r\n                    async: false,\r\n                    done: function (printerData) {\r\n                        if (sPrinterName.toLowerCase() === \"systemdefault\") {\r\n                            sPrinterName = printerData.printerName;\r\n                        }\r\n                    },\r\n                    fail: function (eTxt) { MeadCo.ScriptX.Print.reportError(eTxt); }\r\n                });\r\n            }\r\n\r\n            return deviceSettings[sPrinterName];\r\n        }\r\n\r\n        return {};\r\n    }\r\n\r\n    function getDeviceSettingsForAsync(sPrinterName, resolve, reject) {\r\n        if (typeof sPrinterName === \"string\" && sPrinterName !== \"\") {\r\n            if (typeof deviceSettings[sPrinterName] === \"undefined\") {\r\n                getDeviceSettings({\r\n                    name: sPrinterName,\r\n                    async: true,\r\n                    done: function (printerData) {\r\n                        if (sPrinterName.toLowerCase() === \"systemdefault\") {\r\n                            sPrinterName = printerData.printerName;\r\n                        }\r\n                        resolve(deviceSettings[sPrinterName])\r\n                    },\r\n                    fail: function (eTxt) { reject(eTxt); }\r\n                });\r\n            }\r\n            else\r\n                resolve(deviceSettings[sPrinterName]);\r\n        }\r\n        else\r\n            reject(\"a printer name is required\");\r\n    }\r\n\r\n    function managePrinterConnection(sMethod, sShareName) {\r\n        console.warn(\"Synchronous calls to add/remove printer connections are not recommeneded as this will lock the browser UI. Consider using the asynchronous versions when working with in ScriptX.Services\");\r\n        var sd = MeadCo.ScriptX.Print.serviceDescription();\r\n        if (sd.serviceClass == enumServiceClass.WINDOWSPC && sd.serviceVersion.major >= 2 && sd.serviceVersion.minor >= 19) {\r\n            callService(printerApiLocation + \"/Connection/\" + encodeURIComponent(sShareName), sMethod, null, true, false);\r\n        }\r\n        else {\r\n            MeadCo.error(\"ScriptX.Services for Windows PC 2.19 or later is required for add/remove PrinterConnection()\");\r\n        }\r\n    }\r\n\r\n    function managePrinterConnectionAsync(sMethod, sShareName, onSuccess, onFail) {\r\n        MeadCo.ScriptX.Print.serviceDescriptionAsync(\r\n            function (sd) {\r\n                if (sd.serviceClass == enumServiceClass.WINDOWSPC && sd.serviceVersion.major >= 2 && sd.serviceVersion.minor >= 19) {\r\n                    callService(printerApiLocation + \"/Connection/\" + encodeURIComponent(sShareName), sMethod, null, true, true, onSuccess, onFail);\r\n                }\r\n                else {\r\n                    MeadCo.error(\"ScriptX.Services for Windows PC 2.19 or later is required for add/remove PrinterConnection()\");\r\n                    onFail(\"add/remove PrinterConnection is not supported\");\r\n                }\r\n            },\r\n            onFail\r\n        );\r\n    }\r\n\r\n    // look for auto-processing attributes that define the server to connect to and the\r\n    // license/subscription to be used. \r\n    //\r\n    // This implementation is called by the public api useAttributes (called by factory and secmgr implementations)\r\n    //\r\n    function processAttributes() {\r\n        MeadCo.log(\"MeadCo.ScriptX.Print ... looking for auto connect, already found?: \" + bDoneAuto);\r\n\r\n        if (!bDoneAuto) {\r\n            // protected API\r\n            var printHtml = MeadCo.ScriptX.Print.HTML;\r\n            var printApi = MeadCo.ScriptX.Print;\r\n            var licenseApi = MeadCo.ScriptX.Print.Licensing;\r\n\r\n            const cloudOrOnPremise = document.querySelector('[data-meadco-subscription]');\r\n            if (cloudOrOnPremise) {\r\n                const data = cloudOrOnPremise.dataset;\r\n                MeadCo.log(\"Auto connect susbcription to: \" +\r\n                    data.meadcoServer + \", or \" + data.meadcoPrinthtmlserver +\r\n                    \", with subscription: \" +\r\n                    data.meadcoSubscription +\r\n                    \", sync: \" +\r\n                    data.meadcoSyncinit +\r\n                    \", usefetch: \" +\r\n                    data.meadcoUsefetch\r\n                );\r\n                const syncInit = (\"\" + data.meadcoSyncinit)\r\n                    .toLowerCase() !==\r\n                    \"false\"; // defaults to true if not specified\r\n\r\n                if (!syncInit) {\r\n                    const sFetchDefined = (\"\" + data.meadcoUsefetch);\r\n                    if (sFetchDefined.length > 0)\r\n                        MeadCo.fetchEnabled = sFetchDefined.toLowerCase() === \"true\";\r\n                }\r\n                else\r\n                    MeadCo.fetchEnabled = false;\r\n\r\n                const server = data.meadcoServer;\r\n                if (typeof server === \"undefined\") {\r\n                    server = data.meadcoPrinthtmlserver;\r\n                }\r\n\r\n                if (typeof server === \"undefined\") {\r\n                    MeadCo.error(\"No server specified\");\r\n                } else {\r\n                    // in case there will be a request for the subnscription info ..\r\n                    if (typeof licenseApi !== \"undefined\")\r\n                        licenseApi.connect(server, data.meadcoSubscription);\r\n\r\n                    if (!syncInit) {\r\n                        MeadCo.log(\"Async connectlite...\");\r\n                        printApi.connectLite(server, data.meadcoSubscription);\r\n                    } else {\r\n                        MeadCo\r\n                            .warn(\"Synchronous connection is deprecated.jQuery is required for synchronous behaviour.To update to asynchronous behaviour please use data - meadco - syncinit='false'. Note that this may require additional code changes. Please see: https://www.meadroid.com/Developers/KnowledgeBank/HowToGuides/ScriptXServices/ThenToNow/Stage6\");\r\n                        printHtml.connect(server, data.meadcoSubscription);\r\n                    }\r\n                    bDoneAuto = true;\r\n                }\r\n            }\r\n            else {\r\n                const wPC = document.querySelector('[data-meadco-license]');\r\n\r\n                if (wPC) {\r\n                    if (typeof printApi === \"undefined\" || typeof printHtml === \"undefined\" || typeof licenseApi === \"undefined\") {\r\n                        MeadCo.log(\"Not auto-connecting client license as print or printHtml or license API not present. Should be present on next attempt.\");\r\n                    } else {\r\n                        const data = wPC.dataset;\r\n                        MeadCo.log(\"Auto connect client license to: \" +\r\n                            data.meadcoServer +\r\n                            \", with license: \" +\r\n                            data.meadcoLicense +\r\n                            \", path: \" +\r\n                            data.meadcoLicensePath +\r\n                            \", revision: \" +\r\n                            data.meadcoLicenseRevision +\r\n                            \", sync: \" +\r\n                            data.meadcoSyncinit +\r\n                            \", useFetch: \" +\r\n                            data.meadcoUsefetch +\r\n                            \", orchestrator: \" +\r\n                            data.meadcoOrchestrator +\r\n                            \", orchestratorKey: \" +\r\n                            data.meadcoOrchestratorKey +\r\n                            \", trustVerifiedConnection: \" +\r\n                            data.meadcoTrustVerifiedConnection);\r\n\r\n                        const syncInit = (\"\" + data.meadcoSyncinit)\r\n                            .toLowerCase() !==\r\n                            \"false\"; // defaults to true if not specified\r\n                        const reportError = (\"\" + data.meadcoReporterror)\r\n                            .toLowerCase() !==\r\n                            \"false\"; // defaults to true if not specified\r\n                        const applyLicense = (\"\" + data.meadcoApplyLicense)\r\n                            .toLowerCase() ==\r\n                            \"true\"; // only applies to async, defaults to false if not specified; if MeadCo ScriptXJS is in use, it will do the apply. Set true if it is not being used.\r\n\r\n                        const server = data.meadcoServer;\r\n\r\n                        servicesServer.orchestratorPort = data.meadcoOrchestrator;\r\n                        servicesServer.orchestratorKey = data.meadcoOrchestratorKey;\r\n                        servicesServer.trustVerifiedConnection = (\"\" + data.meadcoTrustVerifiedConnection)\r\n                            .toLowerCase() !==\r\n                            \"false\"; // defaults to true if not specified\r\n\r\n\r\n                        if (!syncInit) {\r\n                            MeadCo.log(\"Async connectlite...\");\r\n                            const sFetchDefined = (\"\" + data.meadcoUsefetch);\r\n                            if (sFetchDefined.length > 0)\r\n                                MeadCo.fetchEnabled = sFetchDefined.toLowerCase() === \"true\";\r\n\r\n                            licenseApi.connectLite(server, data.meadcoLicense,\r\n                                data.meadcoLicenseRevision,\r\n                                data.meadcoLicensePath);\r\n                            printApi.connectLite(server, data.meadcoLicense);\r\n\r\n                            if (applyLicense) {\r\n                                licenseApi.applyAsync(data.meadcoLicense, data.meadcoLicenseRevision, data.meadcoLicensePath,\r\n                                    () => {\r\n                                        MeadCo.log(\"NOTE: license has been applied successfully from async processing of attribute with values\");\r\n                                    },\r\n                                    (e) => {\r\n                                        MeadCo.error(`Failed to apply the license: ${e}, error is: ${licenseApi.errorMessage}`);\r\n                                        if (reportError) {\r\n                                            MeadCo.ScriptX.Print.reportError(licenseApi.errorMessage);\r\n                                        }\r\n                                    }\r\n                                );\r\n                            }\r\n                        } else {\r\n                            MeadCo\r\n                                .warn(\"Synchronous connection is deprecated. jQuery is required for synchronous behaviour. To update to asynchronous behaviour please use data-meadco-syncinit='false'. Note that this may require additional code changes. Please see: https://www.meadroid.com/Developers/KnowledgeBank/HowToGuides/ScriptXServices/ThenToNow/Stage6\");\r\n                            MeadCo.fetchEnabled = false;\r\n                            licenseApi.connect(server, data.meadcoLicense);\r\n                            if (typeof data.meadcoLicensePath !== \"undefined\" &&\r\n                                typeof data\r\n                                    .meadcoLicenseRevision !==\r\n                                \"undefined\") { // if these are not defined then you must use meadco-secmgr.js\r\n                                licenseApi.apply(data.meadcoLicense,\r\n                                    data.meadcoLicenseRevision,\r\n                                    data.meadcoLicensePath);\r\n\r\n                                if (licenseApi.result != 0 && reportError) {\r\n                                    MeadCo.ScriptX.Print.reportError(licenseApi.errorMessage);\r\n                                }\r\n                            }\r\n                            printHtml.connect(server, data.meadcoLicense);\r\n                        }\r\n                        bDoneAuto = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    MeadCo.log(\"MeadCo.ScriptX.Print \" + version + \" loaded.\");\r\n\r\n    //////////////////////////////////////////////////\r\n    // public API\r\n    return {\r\n        /*\r\n         * Enum for type of content being posted to printHtml API\r\n         * @readonly\r\n         * @memberof MeadCoScriptXPrint\r\n         * @enum { ContentType }\r\n         * \r\n         * URL: 1 a get request will be issued to the url and the returned content will be printed\r\n         * HTML: 2 the passed string is assumed to be a complete html document .. <html>..</html>\r\n         * INNERTHTML: 4 the passed string is a complete html document but missing the html tags\r\n         */\r\n        ContentType: enumContentType,\r\n\r\n        /* \r\n         * Enum for status code returned to print progress callbacks\r\n         * @readonly\r\n         * @memberof MeadCoScriptXPrint\r\n         * @enum PrintStatus { number }\r\n         */\r\n        PrintStatus: enumPrintStatus,\r\n\r\n        ErrorAction: enumErrorAction,\r\n\r\n        CollateOptions: enumCollateOptions,\r\n        DuplexOptions: enumDuplexOptions,\r\n        MeasurementUnits: enumMeasurementUnits,\r\n        ServiceClasses: enumServiceClass,\r\n\r\n        /**\r\n         * Get/set the action to take when an error occurs\r\n         * \r\n         * @memberof MeadCoScriptXPrint\r\n         * @property {ErrorAction} onErrorAction - the action\r\n         */\r\n        get onErrorAction() {\r\n            return errorAction;\r\n        },\r\n\r\n        set onErrorAction(action) {\r\n            errorAction = action;\r\n        },\r\n\r\n        /**\r\n         * Get/set the PORT number of the ScriptX.Services Orchestrator ('reverse proxy') to use. By definition orchestrator only listens\r\n         * on the local-loopback address.\r\n         * \r\n         * This is only useful in uses cases of multiple users are simultaneously logged in to an instance of Windows.\r\n         * In these cases, the port number used by ScriptX.Services for Windows PC will be unqiue for each user.\r\n         * \r\n         * The port number for the orchestrator is the same for each user as the orchestrator server is only active while the\r\n         * user is active. \r\n         */\r\n        get orchestrator() {\r\n            return servicesServer.orchestratorPort;\r\n        },\r\n\r\n        set orchestrator(nPort) {\r\n            servicesServer.orchestratorPort = \"\" + nPort;\r\n        },\r\n\r\n        /**\r\n         * Get/set the key to use with Orchestrator Service for ScriptX.Services for Windows PC to recover the port registered for use with the same key.\r\n         * Typically, this will be the user name but can be any value.\r\n         * */\r\n        get orchestratorKey() {\r\n            return servicesServer.orchestratorKey;\r\n        },\r\n\r\n        set orchestratorKey(sKey) {\r\n            servicesServer.orchestratorKey = sKey;\r\n        },\r\n\r\n        /**\r\n         * Get/set the cookie to be used to authorise access to protected content\r\n         * \r\n         * @memberof MeadCoScriptXPrint\r\n         * @property {string} authorisationCookie - the cookie in the form name=value\r\n         */\r\n        get authorisationCookie() {\r\n            return AccessControl.cookie;\r\n        },\r\n\r\n        set authorisationCookie(cookie) {\r\n            AccessControl.cookie = cookie;\r\n        },\r\n\r\n        /** \r\n         *  Get/set the currently active printer\r\n         *  @memberof MeadCoScriptXPrint\r\n         *  @property {string} printerName - The name of the current printer in use.\r\n         */\r\n        get printerName() {\r\n            return printerName;\r\n        },\r\n\r\n        set printerName(deviceRequest) {\r\n            if (!(deviceRequest === printerName || deviceRequest.name === printerName)) {\r\n                if (typeof deviceRequest === \"string\") {\r\n\r\n                    if (typeof deviceSettings[deviceRequest] === \"undefined\") {\r\n                        // not already cached, get (synchronously) if synchronous is available\r\n                        // if synchronous is not available then getDeviceSettingsAsync() must be called \r\n                        // We have no choice but to fail this call. \r\n                        if (outerScope.jQuery && !MeadCo.fetchEnabled) {\r\n                            getDeviceSettings({\r\n                                name: deviceRequest,\r\n                                done: function (data) {\r\n                                    printerName = data.printerName;\r\n                                },\r\n                                async: false,\r\n                                fail: function (eTxt) {\r\n                                    MeadCo.ScriptX.Print.reportError(eTxt);\r\n                                }\r\n                            });\r\n                        }\r\n                        else {\r\n                            MeadCo.error(\"Asynchronous processing of set printerName required, synchronous calls to obtain device details will fail until this completes.\")\r\n                            getDeviceSettingsForAsync(deviceRequest,\r\n                                (data) => { printerName = data.printerName; },\r\n                                (eTxt) => { MeadCo.ScriptX.Print.reportError(eTxt); }\r\n                            );\r\n\r\n                            // awful, solely to not break backwards compatibility\r\n                            if (servicesServer.serviceUrl === \"\")\r\n                                MeadCo.ScriptX.Print.reportError(\"MeadCo.ScriptX.Print : server connection is not defined.\");\r\n                            else\r\n                                MeadCo.ScriptX.Print.reportError(\"Not Found\");\r\n                        }\r\n                    }\r\n                    else {\r\n                        printerName = deviceRequest;\r\n                    }\r\n\r\n                } else {\r\n                    getDeviceSettings(deviceRequest);\r\n                }\r\n            }\r\n        },\r\n\r\n        setSystemDefaultPrinterAsync: function (sName, resolve, reject) {\r\n            if (typeof deviceSettings[\"systemdefault\"] !== \"undefined\" && deviceSettings[\"systemdefault\"] == sName) {\r\n                MeadCo.log(\"setSystemDefaultPrinterAsync() does NOT need to do anything\");\r\n                resolve();\r\n                return;\r\n            }\r\n\r\n            sName = \"system::\" + sName;\r\n            sName = sName.replace(/\\\\/g, \"||\");\r\n            MeadCo.log(\"Request systemDefaultPrinterAsync: \" + sName);\r\n            callService(htmlApiLocation + \"/CurrentPrinter/\" + encodeURIComponent(sName), \"PUT\", null, true, true, resolve, reject);\r\n        },\r\n\r\n        /**\r\n         * Get the version of this module as a string major.minor.hotfix.build\r\n         * @property {string} version\r\n         * @memberof MeadCoScriptXPrint\r\n         */\r\n        get version() {\r\n            return version;\r\n        },\r\n\r\n        /**\r\n         * Get the full url of the ScriptX.Services server connected to \r\n         * \r\n         * @property {string} serviceUrl\r\n         * @memberof MeadCoScriptXPrint         \r\n         */\r\n        get serviceUrl() {\r\n            return servicesServer.url;\r\n        },\r\n\r\n        /**\r\n         * Get the version of the service connected to.\r\n         * \r\n         * @function serviceVersion\r\n         * @memberof MeadCoScriptXPrint\r\n         * @returns {VersionObject} the version\r\n         */\r\n        serviceVersion: function () {\r\n            return this.serviceDescription().serviceVersion;\r\n        },\r\n\r\n        /**\r\n         * Get the version of the service connected to.\r\n         * \r\n         * @function serviceVersionAsync\r\n         * @memberof MeadCoScriptXPrint\r\n         * @param {function({VersionObject})} resolve function to call on success\r\n         * @param {function({errorText})} reject function to call on failure\r\n         */\r\n        serviceVersionAsync: function (resolve, reject) {\r\n            this.serviceDescriptionAsync(function (sd) { resolve(sd.serviceVersion); }, reject);\r\n        },\r\n\r\n        /**\r\n         * Get/set the cached device settings (papersize etc) for the currently active printer\r\n         * @memberof MeadCoScriptXPrint\r\n         * @property {DeviceSettingsObject} deviceSettings (see API /api/vi/printhtml/deviceInfo/ )\r\n         */\r\n        get deviceSettings() {\r\n            return printerName !== \"\" ? deviceSettings[printerName] : {};\r\n        },\r\n\r\n        set deviceSettings(settings) {\r\n            addOrUpdateDeviceSettings(settings);\r\n        },\r\n\r\n        /**\r\n         * Get the device settings (papersize etc) for the named printer. This call is synchronous \r\n         * and not recommended. \r\n         * \r\n         * @function deviceSettingsFor\r\n         * @memberof MeadCoScriptXPrint\r\n         * @param {string} sPrinterName the name of the printer device to return the settings for \r\n         * @returns {DeviceSettingsObject} object with properties\r\n         */\r\n        deviceSettingsFor: function (sPrinterName) {\r\n            return getDeviceSettingsFor(sPrinterName);\r\n        },\r\n\r\n        /**\r\n         * Get the device settings (papersize etc) for the named printer. If not already downloaded\r\n         * this function is asynchronous. \r\n         * \r\n         * @function deviceSettingsForAsync\r\n         * @memberof MeadCoScriptXPrint\r\n         * @param {string} sPrinterName the name of the printer device to return the settings for \r\n         * @param {function({DeviceSettingsObject})} resolve function to call on success\r\n         * @param {function({errorText})} reject function to call on failure\r\n         */\r\n        deviceSettingsForAsync: function (sPrinterName, resolve, reject) {\r\n            getDeviceSettingsForAsync(sPrinterName, resolve, reject);\r\n        },\r\n\r\n        /**\r\n         * search for processing attibutes for connection and subscription/license and process them. The attibutes can be on any element. This function is called automatically by factory emulation and licensing emulation scripts so does not usually \r\n         * need to be called by document script.\r\n         * \r\n         * Please note synchronous AJAX calls are deprecated in all browsers but may be useful to \"quick start\" use of older code. It is recommended that code is moved\r\n         * to using asynchronous calls as soon as practical. The MeadCoScriptXJS library can assist with this as it delivers promise rather than callback based code.\r\n         * \r\n         * @function useAttributes\r\n         * @memberof MeadCoScriptXPrint\r\n         * @example\r\n         * \r\n         * <!-- an example connection to an On Premise server for ScriptX.Services -->\r\n         * <script src=\"lib/meadco-scriptxservicesprintUI.min.js\" \r\n         *      data-meadco-server=\"https://app.corpservices/\" \r\n         *      data-meadco-subscription=\"\" data-meadco-syncinit=\"false\">\r\n         * </script>;\r\n         * \r\n         * <!-- an example connection to ScriptX.Services for Windows PC -->\r\n         * <script src=\"lib/meadco-scriptxservicesUI.min.js\"\r\n         *      data-meadco-server=\"http://127.0.0.1:41191\" \r\n         *      data-meadco-license=\"{6BC6808B-D645-40B6-AE80-E9D0825797EF}\" \r\n         *      data-meadco-syncinit=\"false\" \r\n         *      data-meadco-license-path=\"warehouse\"\r\n         *      data-meadco-license-revision=\"3\">\r\n         * </script>\r\n         * \r\n         * data-meadco-server value is the root url, api/v1/printhtml, api/v1/licensing will be added by the library\r\n         * data-meadco-syncinit default is true for synchronous calls to the server, value 'false' to use asynchronous calls to the server\r\n         * \r\n         * data-meadco-subscription present => cloud/on premise service, value is the subscription GUID\r\n         * data-meadco-license present => for Windows PC service, value is the license GUID\r\n         *\r\n         * If data-meadco-license is present then the following additional attributes can be used:\r\n         * \r\n         * data-meadco-license-revision, value is the revision number of the license\r\n         * data-meadco-license-path, value is the path to the license file (sxlic.mlf). A value of \"warehouse\" will cause the license to be downloaded from MeadCo's License Warehouse\r\n         * data-meadco-reporterror, default is \"true\", value \"false\" suppresses error messages during the initial connection to the service (only)\r\n         * \r\n         */\r\n        useAttributes: function () {\r\n            processAttributes();\r\n        },\r\n\r\n        /**\r\n         * Specify the server to use and the subscription/license id. \r\n         * \r\n         * Attempt to connect to the defined ScriptX.Services server and obtain\r\n         * the device settings for the default printer. This call is synchronous \r\n         * and therefore not recommended. Use connectAsync()\r\n         * \r\n         * @function connect\r\n         * @memberof MeadCoScriptXPrint\r\n         * @param {string} serverUrl the 'root' url to the server (the api path will be added by the library)\r\n         * @param {string} licenseGuid the license/subscription identifier\r\n         */\r\n        connect: function (serverUrl, licenseGuid) {\r\n            connectToServer(serverUrl, licenseGuid);\r\n        },\r\n\r\n        /**\r\n         * Specify the server and the subscription/license id to use on AJAX calls. No call is made in this function\r\n         *\r\n         * @function connectLite\r\n         * @memberof MeadCoScriptXPrint\r\n         * @param {string} serverUrl the 'root' url to the server (the api path will be added by the library)\r\n         * @param {string} licenseGuid the license/subscription identifier\r\n         */\r\n        connectLite: function (serverUrl, licenseGuid) {\r\n            // factory polyfill initialisation will result in a call with empty string\r\n            // values for both arguments via printHtml.connectAsync() as it doesnt \r\n            // know the values so we assume a connectLite has already been called\r\n            // and dont overwrite with empty values.\r\n            setServer(serverUrl, licenseGuid);\r\n        },\r\n\r\n        /**\r\n         * Specify the server to use and the subscription/license id.\r\n         *\r\n         * Attempt to connect to the defined ScriptX.Services server and obtain\r\n         * the device settings for the default printer. \r\n         *\r\n         * @function connectAsync\r\n         * @memberof MeadCoScriptXPrint\r\n         * @param {string} serverUrl the 'root' url to the server (the api path will be added by the library)\r\n         * @param {string} licenseGuid the license/subscription identifier\r\n         * @param {function({dataObject})} resolve function to call on success, dataObject contains the device settings for the default device.\r\n         * @param {function} reject function to call on failure\r\n         */\r\n        connectAsync: function (serverUrl, licenseGuid, resolve, reject) {\r\n            connectToServerAsync(serverUrl, licenseGuid, resolve, reject);\r\n        },\r\n\r\n        /**\r\n         * Test if there is a MeadCo PrintHtml API server at the url\r\n         * \r\n         * @function connectTestAsync\r\n         * @memberof MeadCoScriptXPrint\r\n         * @param {string} serverUrl the 'root' url to the server (the api path will be added by the library)\r\n         * @param {function({foundServerUrl})} resolve function to call on success\r\n         * @param {function({errorText})} reject function to call on failure\r\n         */\r\n        connectTestAsync: function (serverUrl, resolve, reject) {\r\n            servicesServer.verifyUrl(serverUrl, true, resolve, reject);\r\n        },\r\n\r\n        /**\r\n         * Obtain the description of the service provided by the server\r\n         *\r\n         * @function serviceDescription\r\n         * @memberof MeadCoScriptXPrint\r\n         * @returns {ServiceDescriptionObject} serviceDescription\r\n         */\r\n        serviceDescription: function () {\r\n\r\n            if (!cachedServiceDescription) {\r\n                getFromServer(\"\", false,\r\n                    function (data) { cachedServiceDescription = data; },\r\n                    function (e) {\r\n                        MeadCo.ScriptX.Print.reportError(e.message);\r\n                    });\r\n            }\r\n            return cachedServiceDescription;\r\n        },\r\n\r\n        /**\r\n         * Obtain the description of the service provided by the server\r\n         *\r\n         * @function serviceDescriptionAsync\r\n         * @memberof MeadCoScriptXPrint\r\n         * @param {function(ServiceDescriptionObject)} resolve function to call on success\r\n         * @param {function(errorText)} reject function to call on failure\r\n         */\r\n        serviceDescriptionAsync: function (resolve, reject) {\r\n\r\n            if (!cachedServiceDescription) {\r\n                getFromServer(\"\", true,\r\n                    function (data) {\r\n                        cachedServiceDescription = data;\r\n                        resolve(data);\r\n                    }, reject);\r\n            }\r\n            else {\r\n                resolve(cachedServiceDescription);\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Cache the given device info and available printers in this static class instance\r\n         * \r\n         * Used by libraries that call api/v1/printHtml/htmlPrintDefaults\r\n         * \r\n         * @function connectDeviceAndPrinters\r\n         * @memberof MeadCoScriptXPrint\r\n         * @param {object} deviceInfo the device name and settings (papersize etc)\r\n         * @param {array} arPrinters the names of the available printers\r\n         */\r\n        connectDeviceAndPrinters: function (deviceInfo, arPrinters) {\r\n            bConnected = true;\r\n            addOrUpdateDeviceSettings(deviceInfo);\r\n            availablePrinters = arPrinters;\r\n        },\r\n\r\n        /**\r\n         * true if the library has succesfully connected to a server and the default device settings obtained.\r\n         * \r\n         * @memberof MeadCoScriptXPrint\r\n         * @property {bool} isConnected true if the library has succesfully connected to a server.\r\n         * @readonly\r\n         */\r\n        get isConnected() {\r\n            return bConnected;\r\n        },\r\n\r\n        /**\r\n         * Get the list of printers availablefrom the server.\r\n         * \r\n         * @property {string[]} availablePrinterNames an array of strings of the names of the available printers\r\n         * @memberof MeadCoScriptXPrint\r\n         * @readonly\r\n         */\r\n        get availablePrinterNames() {\r\n            return availablePrinters;\r\n        },\r\n\r\n        /**\r\n         * Add a printer for the user. The printer driver must already be available. \r\n         * \r\n         * @function addPrinterConnection\r\n         * @memberof MeadCoScriptXPrint\r\n         * @param {any} sShareName - \r\n         */\r\n        addPrinterConnection: function (sShareName) {\r\n            managePrinterConnection(\"PUT\", sShareName);\r\n        },\r\n\r\n        /**\r\n         * Add a printer for the user. The printer driver must already be available. \r\n         * \r\n         * @function removePrinterConnection\r\n         * @memberof MeadCoScriptXPrint\r\n         * @param {any} sShareName - \r\n         */\r\n        removePrinterConnection: function (sShareName) {\r\n            managePrinterConnection(\"DELETE\", sShareName);\r\n        },\r\n\r\n        /**\r\n         * Add a printer for the user. The printer driver must already be available. \r\n         * \r\n         * @function addPrinterConnectionAsync\r\n         * @memberof MeadCoScriptXPrint\r\n         * @param {any} sShareName - \r\n         * @param {any} onSuccess\r\n         * @param {any} onFail\r\n         */\r\n        addPrinterConnectionAsync: function (sShareName, onSuccess, onFail) {\r\n            managePrinterConnectionAsync(\"PUT\", sShareName, onSuccess, onFail);\r\n        },\r\n\r\n        /**\r\n         * Add a printer for the user. The printer driver must already be available. \r\n         * \r\n         * @function removePrinterConnectionAsync\r\n         * @memberof MeadCoScriptXPrint\r\n         * @param {any} sShareName - \r\n         * @param {any} onSuccess\r\n         * @param {any} onFail\r\n         */\r\n        removePrinterConnectionAsync: function (sShareName, onSuccess, onFail) {\r\n            managePrinterConnectionAsync(\"DELETE\", sShareName, onSuccess, onFail);\r\n        },\r\n\r\n        /**\r\n         * Call a /printHtml API on the server with GET\r\n         * \r\n         * @function getFromServer\r\n         * @memberof MeadCoScriptXPrint\r\n         * @param {string} sPrintHtmlApi the api to call on the connected server\r\n         * @param {bool} async true for asynchronous call, false for synchronous \r\n         * @param {function} onSuccess function to call on success\r\n         * @param {function(errorText)} onFail function to call on failure\r\n         */\r\n        getFromServer: function (sPrintHtmlApi, async, onSuccess, onFail) {\r\n            getFromServer(htmlApiLocation + sPrintHtmlApi, async, onSuccess, onFail);\r\n        },\r\n\r\n        /**\r\n         * Post a request to the server to print some html and monitor the print job \r\n         * to completion. If the server prints to file then the file is opened for the user (in a new window)\r\n         * \r\n         * @function printHtml\r\n         * @memberof MeadCoScriptXPrint\r\n\r\n         * @param {ContentType} contentType enum type of content given (html snippet, url)\r\n         * @param {string} content the content - a url, html snippet or complete html\r\n         * @param {object} htmlPrintSettings the html settings to use such as headers and footers, device settings (printer to use, copies etc) are taken from this static \r\n         * @param {function({string})} fnDone function to call when printing complete (and output returned), arg is null on no error, else error message.\r\n         * @param {function(status,sInformation,data)} fnProgress function to call when job status is updated\r\n         * @param {any} data object to give pass to fnProgress\r\n         * @return {boolean} - true if a print was started (otherwise an error will be thrown)\r\n         */\r\n        printHtml: printHtmlAtServer,\r\n\r\n        /**\r\n         * Post a request to the server to generate a preview. When ready the url from which the preview can be downloaded\r\n         * is passed to the fnReady function.\r\n         * \r\n         * @function requestHtmlPreview\r\n         * @memberof MeadCoScriptXPrint\r\n         * \r\n         * @param {ContentType} contentType enum type of content given (html snippet, url)\r\n         * @param {string} content the content - a url, html snippet or complete html\r\n         * @param {object} htmlPrintSettings the html settings to use such as headers and footers, device settings (printer to use, copies etc) are taken from this static\r\n         * @param {function({string})} fnDone function to call when processing is complete arg is null on no error, else error message.\r\n         * @param {function({string})} fnReady function to call when the preview is available to download\r\n         */\r\n        requestHtmlPreview: function (contentType, content, htmlPrintSettings, fnDone, fnReady) {\r\n            var userPrinterName = printerName;\r\n            printerName = magicPrintPreviewPrinter;\r\n\r\n            funcPrintHtmlAtServer(contentType, content, htmlPrintSettings, {}, fnDone, function () { }, fnReady)();\r\n            printerName = userPrinterName;\r\n        },\r\n\r\n        /**\r\n         * Post a request to the server to print some html and monitor the print job \r\n         * to completion. If the server prints to file then the file is opened for the user (in a new window)\r\n         * \r\n         * @function printPdf\r\n         * @memberof MeadCoScriptXPrint\r\n\r\n         * @param {string} document full url to the pdf document to be printed\r\n         * @param {object} pdfPrintSettings the settings to use such as rotation, scaling. device settings (printer to use, copies etc) are taken from this static\r\n         * @param {function({string})} fnDone function to call when printing complete (and output returned), arg is null on no error, else error message.\r\n         * @param {function(status,sInformation,data)} fnProgress function to call when job status is updated\r\n         * @param {any} data object to give pass to fnProgress\r\n         * @return {boolean} - true if a print was started (otherwise an error will be thrown)\r\n         */\r\n        printPdf: printPdfAtServer,\r\n\r\n        /**\r\n         * Post a request to the server to print a string directly to the current printer. The print is synchronous at the server\r\n         * and is completed (sent to the printer) when the api returns.\r\n         *\r\n         * @function printDirect\r\n         * @memberof MeadCoScriptXPrint\r\n         *\r\n         * @param {ContentType} contentType enum type of content given (string or url)\r\n         * @param {string} content the content - a url, or string containing e.g. zpl.\r\n         * @param {function({string})} fnDone function to call when printing complete, arg is null on no error, else error message\r\n         * @return {boolean} - true if a print was started (otherwise an error will be thrown)         *\r\n         */\r\n        printDirect: printDirectAtServer,\r\n\r\n        /**\r\n         * Extract the error text from jQuery AJAX response\r\n         * \r\n         * @function parseAjaxError\r\n         * @memberof MeadCoScriptXPrint\r\n         * \r\n         * @param {string} logText The lead-in text for a console.log entry\r\n         * @param {object} jqXhr jQuery ajax header\r\n         * @param {string} textStatus textStatus result determined by jQuery\r\n         * @param {string} errorThrown The server exception dewtermined by jQuery\r\n         * @returns {string} The error text to display\r\n         */\r\n        parseAjaxError: function (logText, jqXhr, textStatus, errorThrown) {\r\n            return MeadCo.parseAjaxError(logText, jqXhr, textStatus, errorThrown);\r\n        },\r\n\r\n        /**\r\n         * Extract the error text from browser fetch response\r\n         * \r\n         * @function parseFetchError\r\n         * @memberof MeadCoScriptXPrint\r\n         * \r\n         * @param {object} errorThrown error caught from fetch \r\n         * @returns {string} The error text to display\r\n         */\r\n        parseFetchError: function (logText, errorThrown) {\r\n            return MeadCo.parseFetchError(logText, errorThrown);\r\n        },\r\n\r\n        /**\r\n         * 'derived' classes call this function to report errors, will either throw or report depending on \r\n         * value of onErrorAction.\r\n         * \r\n         * @memberof MeadCoScriptXPrint\r\n         * @function reportError \r\n         * @param {string} errorTxt the error text to display\r\n         * \r\n         */\r\n        reportError: function (errorTxt) {\r\n            MeadCo.error(\"ReportError: \" + errorTxt);\r\n            switch (errorAction) {\r\n                case enumErrorAction.REPORT:\r\n                    MeadCo.ScriptX.Print.reportServerError(errorTxt);\r\n                    break;\r\n\r\n                case enumErrorAction.THROW:\r\n                    throw new Error(errorTxt);\r\n            }\r\n        },\r\n\r\n        /**\r\n         * overridable function for reporting an error. 'derived' classes call this\r\n         * function to report errors.\r\n         * \r\n         * @memberof MeadCoScriptXPrint\r\n         * @function reportServerError \r\n         * @param {string} errorTxt the error text to display\r\n         * \r\n         * ```js\r\n         * // overload cloud print library report error\r\n         * MeadCo.ScriptX.Print.reportServerError = function (errorTxt) {\r\n         *    app.Messages.PrintErrorBox(errorTxt);\r\n         * }\r\n         * ```\r\n         */\r\n        reportServerError: function (errorTxt) {\r\n            alert(\"There was an error in the printing service\\n\\n\" + errorTxt);\r\n        },\r\n\r\n        /**\r\n         * overridable function for reporting an implementation isnt available. 'derived' classes call this\r\n         * function to report functions that are not yet implemented.\r\n         * \r\n         * @memberof MeadCoScriptXPrint\r\n         * @function reportFeatureNotImplemented\r\n         * @param {string} featureDescription descriptn of the feature that isnt available\r\n         * \r\n         * ```js\r\n         * // overload cloud print library report error\r\n         * MeadCo.ScriptX.Print.reportFeatureNotImplemented = function (featureDescription) {\r\n         *   app.Messages.PrintErrorBox(featureDescription + \" is not available yet with the ScriptX.Services.\\n\\nThis feature will be implemented soon.\");\r\n         * }\r\n         * ```\r\n         */\r\n        reportFeatureNotImplemented: function (featureDescription) {\r\n            MeadCo.log(\"Call to not implemented: \" + featureDescription);\r\n            alert(featureDescription + \"\\n\\nis not available.\");\r\n        },\r\n\r\n        /**\r\n         * The list of jobs currently active at this client or server (client 'jobs' are those waiting to be \r\n         * delivered to the server and 'locks' while asychronous UI is in progress).\r\n         * \r\n         * @memberof MeadCoScriptXPrint\r\n         * @property {object[]} queue array of jobs \r\n         * @readonly\r\n         */\r\n        get queue() {\r\n            return activePrintQueue;\r\n        },\r\n\r\n        /**\r\n         * The number of jobs there are active *at the server* for this client\r\n         * \r\n         * @memberof MeadCoScriptXPrint\r\n         * @property {int} activeJobs the number of jobs\r\n         * @readonly\r\n         */\r\n        get activeJobs() {\r\n            return this.queue.filter(j => j.jobName !== jobNameWaitingForSend && j.jobName !== jobNameSentWaitingResponse && j.jobName !== jobNameHoldEnsureSpoolingStatus).length;\r\n        },\r\n\r\n        /**\r\n         * The number of client only jobs (locks and those waiting for delivery to the server) active at this client\r\n         * \r\n         * @memberof MeadCoScriptXPrint\r\n         * @property {int} clientSideJobs the number of jobs\r\n         * @readonly\r\n         */\r\n        get clientSideJobs() {\r\n            return this.queue.filter(j => j.jobName == jobNameWaitingForSend || j.jobName == jobNameSentWaitingResponse || j.jobName == jobNameHoldEnsureSpoolingStatus).length;\r\n        },\r\n\r\n        /**\r\n         * Check if there are no jobs waiting for delivery to the server (faster than clientSideJobs==0)\r\n         * \r\n         * @memberof MeadCoScriptXPrint\r\n         * @property {bool} noJobsWaitingDelivery true if no jobs waiting\r\n         * @readonly\r\n         */\r\n        get noJobsWaitingDelivery() {\r\n            return this.queue.every(j => j.jobName !== jobNameWaitingForSend && j.jobName !== jobNameSentWaitingResponse && j.jobName !== jobNameHoldEnsureSpoolingStatus);\r\n        },\r\n\r\n        /**\r\n         * Make sure that spooling status is locked active while asynchronous UI that may start\r\n         * printing is displayed by placing a lock on the queue.\r\n         * \r\n         * @memberof MeadCoScriptXPrint\r\n         * @function ensureSpoolingStatus\r\n         * @returns {object} a fake job to lock the spooling status on\r\n         * \r\n         * @example\r\n         * var lock = MeadCo.ScriptX.Print.ensureSpoolingStatus\r\n         * ShowAsyncUI(function() {\r\n         *  MeadCo.ScriptX.Print.freeSpoolStatus(lock);\r\n         * });\r\n         */\r\n        ensureSpoolingStatus: function () {\r\n            var lock = { jobIdentifier: Date.now(), printerName: \"ensureJobsPrinter\", jobName: jobNameHoldEnsureSpoolingStatus };\r\n            queueJob(lock);\r\n            return lock;\r\n        },\r\n\r\n        /**\r\n         * Remove a lock on the queue that was created by a call to ensureSpoolingStatus().\r\n         * \r\n         * @memberof MeadCoScriptXPrint\r\n         * @function freeSpoolStatus\r\n         * @param {object} lock the lock object returned by ensureSpoolingStatus()\r\n         */\r\n        freeSpoolStatus: function (lock) {\r\n            removeJob(lock.jobIdentifier);\r\n        },\r\n\r\n        /**\r\n         * Get if print is still 'spooling', in other words still queued at the server\r\n         * \r\n         * @memberof MeadCoScriptXPrint\r\n         * @property {bool} isSpooling\r\n         * @readonly\r\n         */\r\n        get isSpooling() {\r\n            return jobCount() > 0;\r\n        },\r\n\r\n        /**\r\n         * Start (asynchronous) monitor to observe until no more jobs spooling/waiting at the server\r\n         * then call the given callback function\r\n         * \r\n         * @memberof MeadCoScriptXPrint\r\n         * @function waitForSpoolingComplete\r\n         * @param {int} iTimeout wait until complete or timeout (in ms) -1 => infinite\r\n         * @param {function({bool})} fnComplete callback function, arg is true if all jobs complete\r\n         */\r\n        waitForSpoolingComplete: function (iTimeout, fnComplete) {\r\n            MeadCo.log(\"Started WaitForSpoolingComplete(\" + iTimeout + \")\");\r\n            if (typeof fnComplete !== \"function\") {\r\n                throw \"WaitForSpoolingComplete requires a completion callback\";\r\n            }\r\n\r\n            var startTime = Date.now();\r\n            var interval = 250;\r\n\r\n            var intervalId = window.setInterval(function () {\r\n                if (jobCount() === 0) {\r\n                    MeadCo.log(\"WaitForSpoolingComplete - complete\");\r\n                    window.clearInterval(intervalId);\r\n                    fnComplete(true);\r\n                } else {\r\n                    if (iTimeout >= 0 && Date.now() - startTime > iTimeout) {\r\n                        MeadCo.log(\"WaitForSpoolingComplete - timeout\");\r\n                        window.clearInterval(intervalId);\r\n                        fnComplete(jobCount() === 0);\r\n                    }\r\n                }\r\n            }, interval);\r\n        },\r\n\r\n        /**\r\n         * Start (asynchronous) monitor to observe until all submitted jobs have been\r\n         * delivered to the server, there will probably be jobs still waiting to process/spool\r\n         * at the server. It is not safe to close the browser window until this function \r\n         * indicates completion\r\n         * \r\n         * @memberof MeadCoScriptXPrint\r\n         * @function waitForDeliveryComplete\r\n         * @param {int} iTimeout wait until complete or timeout (in ms) -1 => infinite\r\n         * @param {function({bool})} fnComplete callback function, arg is true if all jobs delivered\r\n\r\n         */\r\n        waitForDeliveryComplete: function (iTimeout, fnComplete) {\r\n            MeadCo.log(\"Started waitForDeliveryComplete(\" + iTimeout + \")\");\r\n            if (typeof fnComplete !== \"function\") {\r\n                throw \"waitForDeliveryComplete requires a completion callback\";\r\n            }\r\n\r\n            const startTime = Date.now();\r\n            const interval = 250;\r\n            const that = this;\r\n\r\n            const intervalId = window.setInterval(() => {\r\n                if (that.noJobsWaitingDelivery) {\r\n                    MeadCo.log(\"waitForDeliveryComplete - complete\");\r\n                    window.clearInterval(intervalId);\r\n                    fnComplete(true);\r\n                } else {\r\n                    if (iTimeout >= 0 && Date.now() - startTime > iTimeout) {\r\n                        MeadCo.log(\"waitForDeliveryComplete - timeout\");\r\n                        window.clearInterval(intervalId);\r\n                        fnComplete(false);\r\n                    }\r\n                }\r\n            }, interval);\r\n\r\n        },\r\n\r\n        /**\r\n          * Waits for all pending operations originated with Print, PrintHTML and BatchPrintPDF to be delivered to the server. This is useful\r\n          * to determine when it is safe to call window.close() and not loose jobs and is a significantly shorter period than waitForSpoolingComplete()\r\n          * \r\n          * @function waitForDeliveryCompleteAsync\r\n          * @memberof MeadCoScriptXPrint\r\n          * @returns {Promise} Promise object represents boolean with value true if all jobs have been delivered.\r\n          * @example \r\n          * MeadCo.ScriptX.PrintPage(false);\r\n          * await MeadCo.ScriptX.Print.waitForDeliveryCompleteAsync();\r\n          * self.close();\r\n          */\r\n        waitForDeliveryCompleteAsync: function () {\r\n            const that = this;\r\n            return new Promise(function (resolve, reject) {\r\n                that.waitForDeliveryComplete(-1, resolve);\r\n            });\r\n        },\r\n\r\n        /**\r\n         * Get/set the timeout between jobs when there is a series of print calls and maintaining the output order is required.\r\n         * The default is 750ms. On slow systems/slow connections this may need to be increased.\r\n         * \r\n         * @memberof MeadCoScriptXPrint\r\n         * @property {number} queueTimeoutSpacing\r\n         */\r\n        get queueTimeoutSpacing() {\r\n            return timeoutSpacingMSecs;\r\n        },\r\n\r\n        set queueTimeoutSpacing(msec) {\r\n            timeoutSpacingMSecs = msec;\r\n        },\r\n\r\n        /**\r\n         * Get/set the time since last print call after which the job spacing timeout is reset\r\n         * \r\n         * @memberof MeadCoScriptXPrint\r\n         * @property {number} queueGapResetTime\r\n         */\r\n        get queueGapResetTime() {\r\n            return jobGapResetTimeout;\r\n        },\r\n\r\n        set queueGapResetTime(msec) {\r\n            jobGapResetTimeout = msec;\r\n        },\r\n\r\n        /**\r\n         * Get/set the name to use on the next job\r\n         * \r\n         * @memberof MeadCoScriptXPrint\r\n         * @property {string} jobFileName\r\n         */\r\n        get jobFileName() {\r\n            return nextJobFileName;\r\n        },\r\n\r\n        set jobFileName(sname) {\r\n            nextJobFileName = sname;\r\n        },\r\n\r\n        requestService: function (sApi, method, oApiData, bLicensed, bAsync, resolve, reject) {\r\n            return callService(sApi, method, oApiData, bLicensed, bAsync, resolve, reject);\r\n        },\r\n\r\n        getService: function (sApi, oApiData, bLicensed) {\r\n            return callService(sApi, \"GET\", oApiData, bLicensed, false);\r\n        },\r\n\r\n        postService: function (sApi, oApiData, bLicensed) {\r\n            return callService(sApi, \"POST\", oApiData, bLicensed, false);\r\n        },\r\n\r\n        getServiceAsync: function (sApi, oApiData, bLicensed, resolve, reject) {\r\n            return callService(sApi, \"GET\", oApiData, bLicensed, true, resolve, reject);\r\n        },\r\n\r\n        postServiceAsync: function (sApi, oApiData, bLicensed, resolve, reject) {\r\n            return callService(sApi, \"POST\", oApiData, bLicensed, true, resolve, reject);\r\n        }\r\n\r\n    };\r\n\r\n});\r\n"]}