{"version":3,"file":"meadco-scriptxprint.min.js","names":["extendMeadCoNamespace","version","htmlApiLocation","pdfApiLocation","directApiLocation","licenseApiLocation","printerApiLocation","printerName","magicPrintPreviewPrinter","jobNameWaitingForSend","jobNameSentWaitingResponse","jobNameHoldEnsureSpoolingStatus","enumMeasurementUnits","DEFAULT","INCHES","MM","AccessControl","cookie","deviceSettings","outerScope","this","activePrintQueue","servicesServer","serviceUrl","pendingUrl","failedUrl","verifiedUrl","orchestratorPort","orchestratorKey","portsToTry","verifying","trustVerifiedConnection","undoTrust","url","MeadCo","warn","that","verifyUrl","value","log","IsChangingServer","setUrlAsync","resolve","reject","bAsync","thatValue","window","setTimeout","IsFailedConnection","apiEndPoint","parseInt","length","jQuery","fetchEnabled","ajax","method","dataType","cache","async","done","data","HttpPort","urlHelper","URL","port","protocol","host","pathname","test","urlFound","errorThrown","fail","jqXhr","textStatus","msg","parseAjaxError","fetch","then","response","ok","Error","status","json","catch","error","parseFetchError","_","serverUrl","nHuntAllowed","makeApiEndPoint","href","resolvedUrl","hostname","call","sApi","oApiData","bLicensed","oPayload","jsonp","contentType","headers","Authorization","btoa","licenseGuid","IsEmptyPayload","JSON","stringify","always","dataOrjqXHR","jqXHRorErrorThrown","body","referrerPolicy","mode","credentials","redirect","keepalive","text","errorTxt","statusText","aServerUrl","currentUrl","newUrl","e","message","Object","keys","constructor","bConnected","bDoneAuto","availablePrinters","cachedServiceDescription","enumContentType","HTML","INNERHTML","STRING","enumResponseStatus","UNKNOWN","QUEUEDTODEVICE","QUEUEDTOFILE","SOFTERROR","OK","enumErrorAction","REPORT","THROW","errorAction","enumServiceClass","CLOUD","ONPREMISE","WINDOWSPC","enumPrintStatus","NOTSTARTED","QUEUED","STARTING","DOWNLOADING","DOWNLOADED","PRINTING","COMPLETED","PAUSED","PRINTPDF","ERROR","ABANDONED","enumCollateOptions","TRUE","FALSE","enumDuplexOptions","SIMPLEX","VERTICAL","HORIZONTAL","queueJob","push","jobIdentifier","jobName","jobCount","findJob","id","find","updateJob","j","forEach","key","removeJob","filter","previousPrintCallWasAt","progress","requestData","information","OnProgress","UserData","nextJobFileName","funcPrintHtmlAtServer","content","htmlPrintSettings","trackingData","fnDone","fnProgress","fnOnQueuedFileAvailable","devInfo","parse","ContentType","Content","Settings","Device","ProtectedContentAccess","fakeJob","Date","now","requiredOutputName","fnOnFileAvailable","printAtServer","err","ScriptX","Print","reportError","queuedToFile","monitorJob","api","queuedToDevice","softError","timeoutToJobStart","timeoutSpacingMSecs","jobGapResetTimeout","printHtmlAtServer","t","open","funcPrintPdfAtServer","document","pdfPrintSettings","Document","Description","jobDescription","jobTitle","printPdfAtServer","printDirectAtServer","PrinterName","setServer","clientLicenseGuid","connectToServer","getDeviceSettings","name","getFromServer","connectToServerAsync","foundUrl","responseInterface","callService","errMsg","onSuccess","onFail","httpMethod","processMonitorResponse","intervalId","jobId","timeOut","functionComplete","clearInterval","counter","interval","bWaiting","setInterval","addOrUpdateDeviceSettings","isDefault","i","oRequest","replace","encodeURIComponent","errTxt","getDeviceSettingsFor","sPrinterName","printerData","toLowerCase","eTxt","getDeviceSettingsForAsync","managePrinterConnection","sMethod","sShareName","console","sd","serviceDescription","serviceClass","serviceVersion","major","minor","managePrinterConnectionAsync","serviceDescriptionAsync","processAttributes","printHtml","printApi","licenseApi","Licensing","cloudOrOnPremise","querySelector","dataset","meadcoServer","meadcoPrinthtmlserver","meadcoSubscription","meadcoSyncinit","meadcoUsefetch","syncInit","sFetchDefined","server","connect","connectLite","wPC","meadcoLicense","meadcoLicensePath","meadcoLicenseRevision","meadcoOrchestrator","meadcoOrchestratorKey","meadcoTrustVerifiedConnection","meadcoReporterror","applyLicense","meadcoApplyLicense","apply","result","errorMessage","applyAsync","PrintStatus","ErrorAction","CollateOptions","DuplexOptions","MeasurementUnits","ServiceClasses","onErrorAction","action","orchestrator","nPort","sKey","authorisationCookie","deviceRequest","setSystemDefaultPrinterAsync","sName","serviceVersionAsync","settings","deviceSettingsFor","deviceSettingsForAsync","useAttributes","connectAsync","connectTestAsync","connectDeviceAndPrinters","deviceInfo","arPrinters","isConnected","availablePrinterNames","addPrinterConnection","removePrinterConnection","addPrinterConnectionAsync","removePrinterConnectionAsync","sPrintHtmlApi","requestHtmlPreview","fnReady","userPrinterName","printPdf","printDirect","logText","reportServerError","alert","reportFeatureNotImplemented","featureDescription","queue","activeJobs","clientSideJobs","noJobsWaitingDelivery","every","ensureSpoolingStatus","lock","freeSpoolStatus","isSpooling","waitForSpoolingComplete","iTimeout","fnComplete","startTime","waitForDeliveryComplete","waitForDeliveryCompleteAsync","Promise","queueTimeoutSpacing","msec","queueGapResetTime","jobFileName","sname","requestService","getService","postService","getServiceAsync","postServiceAsync"],"sources":["meadco-scriptxprint.js"],"mappings":"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","ignoreList":[],"sourcesContent":["/**\r\n * MeadCo.ScriptX.Print\r\n * \r\n * A static class wrapping calls to the server API. \r\n * \r\n * Requires: meadco-core.js\r\n * \r\n * Includes processing of calls to the print api that return \"printing to file\" including collecting the file output. \r\n * \r\n * Provides attribute based connection to the server.\r\n * \r\n * Synchronous AJAX calls are deprecated in all browsers but may be useful to \"quick start\" use of older code. It is recommended that code is moved\r\n * to using asynchronous calls as soon as practical. The MeadCoScriptXJS library can assist with this as it delivers promise rather than callback based code.\r\n * \r\n * AJAX calls can be made via jQuery or browser native fetch(). If jQuery is available it will be used by preference - if used jQuery v1.19 or later is required.\r\n * \r\n * jQuery is required for synchronous AJAX calls.\r\n * \r\n * To use fetch, even if jQuery is available then set MeadCo.fetchEnabled to false. \r\n * \r\n * This can be done using an attribute: data-meadco-usefetch=\"true\" or declare var MeadCo = { useFetch: true } before including this library\r\n * This is useful if a very old version of jQuery is required for UI.\r\n *\r\n * @namespace MeadCoScriptXPrint\r\n */\r\n\r\n; (function (name, definition) {\r\n    extendMeadCoNamespace(name, definition);\r\n})('MeadCo.ScriptX.Print', function () {\r\n    // module version and the api we are coded for\r\n    const version = \"1.15.2.4\";\r\n    const htmlApiLocation = \"v1/printHtml\";\r\n    const pdfApiLocation = \"v1/printPdf\";\r\n    const directApiLocation = \"v1/printDirect\";\r\n    const licenseApiLocation = \"v1/licensing\";\r\n    const printerApiLocation = \"v1/printer\";\r\n\r\n    // default printer \r\n    let printerName = \"\";\r\n\r\n    // using this printername causes ScriptX.Services to select \r\n    // a printer that prints to a PDF file.\r\n    const magicPrintPreviewPrinter = \"ScriptX.Services//PrintPreview.1\"\r\n\r\n    const jobNameWaitingForSend = \"[hold.clientside]\";\r\n    const jobNameSentWaitingResponse = \"[wait.response]\";\r\n    const jobNameHoldEnsureSpoolingStatus = \"[hold.ensureSpoolStatus]\";\r\n\r\n    /**\r\n     * Enum to describe the units used on measurements. Please be aware that (sadly) these enum values do *not* match  \r\n     * the values by the MeadCo ScriptX COM Servers. Please use MeadCo.ScriptX.MeasurementUnits (declared in MeadCoScriptJS) for compatibility\r\n     *\r\n     * @memberof MeadCoScriptXPrint\r\n     * @typedef {number} MeasurementUnits\r\n     * @enum {MeasurementUnits}\r\n     * @readonly\r\n     * @property {number} DEFAULT 0 use the default at the print server\r\n     * @property {number} INCHES 1 \r\n     * @property {number} MM 2 millimeters\r\n     */\r\n    const enumMeasurementUnits = {\r\n        DEFAULT: 0,\r\n        INCHES: 1,\r\n        MM: 2\r\n    };\r\n\r\n    /**\r\n     * Describe the size of a page by its width and height.\r\n     * \r\n     * @typedef PageSize\r\n     * @memberof MeadCoScriptXPrint\r\n     * @property {number} width width of paper in requested units\r\n     * @property {number} height height of paper in requested units\r\n     * */\r\n    var PageSize;  // for doc generator\r\n\r\n    /**\r\n     * Describe the margins within which to print.\r\n     * \r\n     * @typedef Margins\r\n     * @memberof MeadCoScriptXPrint\r\n     * @property {number} left left margin in requested units\r\n     * @property {number} top top margin in requested units\r\n     * @property {number} right right margin in requested units\r\n     * @property {number} bottom bottom margin in requested units\r\n     * */\r\n    var Margins;  // for doc generator\r\n\r\n    /**\r\n     * Information about and the settings to use with an output printing device\r\n     * See also: https://www.meadroid.com/Developers/KnowledgeBank/TechnicalReference/ScriptXServices/WebServiceAPIReference/PrintHtml/deviceinfoGET\r\n     * \r\n     * @typedef DeviceSettingsObject\r\n     * @memberof MeadCoScriptXPrint\r\n     * @property {string} printerName The name of the printer\r\n     * @property {string} printToFileName The name of a the file to send print output to (for Windows PC and )\r\n     * @property {string} paperSizeName The descriptive name of the papersize, e.g. \"A4\"\r\n     * @property {string} paperSourceName The descriptive name of the paper source, e.g. \"Upper tray\"\r\n     * @property {CollateOptions} collate The collation to use when printing\r\n     * @property {number} copies The number of copies to print\r\n     * @property {DuplexOptions} duplex The dulex printing option\r\n     * @property {MeasurementUnits} units Measurement units for papersize and margins\r\n     * @property {PageSize} paperPageSize The size of the paper (in requested units)\r\n     * @property {Margins} unprintableMargins The margin that cannot be printed in (in requested units)\r\n     * @property {number} status Status code for the status of the device. Note this is not reliable, it is the cached return from the first server enquiry only.\r\n     * @property {string} port Printer connection port name/description\r\n     * @property {number} attributes Printer attributes\r\n     * @property {string} serverName Name of the server to which the printer is connected\r\n     * @property {string} shareName Name of the share \r\n     * @property {string} location description of the location of the printer\r\n     * @property {boolean} isLocal true if the printer is local to the server\r\n     * @property {boolean} isNetwork true if the server is on the network\r\n     * @property {boolean} isShared true if the printer is shared \r\n     * @property {boolean} isDefault true if this is the default printer on the service\r\n     * @property {Array.<string>} bins Array of the names of the available paper sources\r\n     * @property {Array.<string>} forms Array of the names of the avbailable paper sizes\r\n     * */\r\n    var DeviceSettingsObject; // for doc generator\r\n\r\n    /**\r\n     * Provide authorisation details to access protected content. \r\n     * \r\n     * @typedef AccessControl\r\n     * @memberof MeadCoScriptXPrint\r\n     * @property {string} cookie The authorisation cookie in the form name=value|name2=value2\r\n     * */\r\n    var AccessControl = {\r\n        cookie: \"\"\r\n    };\r\n\r\n    /**\r\n     * Description of a code version. Semver is used \r\n     * \r\n     * @typedef VersionObject\r\n     * @memberof MeadCoScriptXPrint\r\n     * @property {int} major The major version  \r\n     * @property {int} minor The minor version \r\n     * @property {int} build The patch/hotfix version\r\n     * @property {int} revision Internal revisions of a build/patch/hotfix\r\n     * @property {int} majorRevision ignore\r\n     * @property {int} minorRevision ignore \r\n     * */\r\n    var VersionObject; // for doc generator\r\n\r\n    let deviceSettings = {};\r\n    const outerScope = this;\r\n\r\n    let activePrintQueue = []; // current job queue\r\n\r\n    // singleton wrapper to the server\r\n    //\r\n    // servicesServer.url\r\n    // servicesServer.test\r\n    // servicesServer.call\r\n    //\r\n    const servicesServer = {\r\n\r\n        serviceUrl: \"\",\r\n        pendingUrl: \"\",\r\n        failedUrl: \"\",\r\n        verifiedUrl: \"\",\r\n        orchestratorPort: 0,\r\n        orchestratorKey: \"\",\r\n        portsToTry: 10,\r\n        verifying: false,\r\n        trustVerifiedConnection: true, // if true then once a connection has been found, trust that it will be valid for the page lifetime\r\n\r\n        undoTrust: function () {\r\n            if (!this.trustVerifiedConnection && this.serviceUrl !== \"\") {\r\n                this.verifiedUrl = this.serviceUrl;\r\n                this.pendingUrl = this.serviceUrl;\r\n                this.serviceUrl = \"\";\r\n            }\r\n        },\r\n\r\n        get url() {\r\n\r\n            if (this.verifiedUrl !== \"\") {\r\n                return this.verifiedUrl;\r\n            }\r\n\r\n            if (this.serviceUrl === \"\" && this.pendingUrl !== \"\") {\r\n                MeadCo.warn(\"[GET] servicesServer.url is not ready, performing synchronous search. Recommend code re-org to resolve the server earlier and asynchronously.\")\r\n                var that = this;\r\n                this.verifyUrl(this.pendingUrl, false, function () {\r\n                    return that.serviceUrl;\r\n                }, function () {\r\n                    return \"\";\r\n                });\r\n            }\r\n\r\n            return this.serviceUrl;\r\n\r\n        },\r\n\r\n        // essentially synchronous set url, we set the pending value so the code \r\n        // executes synchronously here and there may then be an asynchronous sorting\r\n        // out when an api call is made (see implementation of call : function())\r\n        set url(value) {\r\n            MeadCo.log(\"servicesServer::setUrl: \" + value);\r\n            if (this.IsChangingServer(value)) {\r\n                MeadCo.log(\"note set as pending\");\r\n                this.serviceUrl = \"\";\r\n                this.pendingUrl = value;\r\n            }\r\n        },\r\n\r\n        setUrlAsync: function (value, resolve, reject) {\r\n            MeadCo.log(\"servicesServer::urlAsync: \" + value);\r\n            this.verifyUrl(value, true, resolve, reject);\r\n        },\r\n\r\n        verifyUrl: function (value, bAsync, resolve, reject) {\r\n\r\n            if (this.verifying && bAsync) {\r\n                MeadCo.warn(\"Verify called and verify in progress ....\");\r\n                var that = this;\r\n                var thatValue = value;\r\n                window.setTimeout(function () { that.verifyUrl(thatValue, bAsync, resolve, reject); }, 1000);\r\n                return;\r\n            }\r\n\r\n            if (this.IsChangingServer(value) && !this.IsFailedConnection(value)) {\r\n\r\n                var that = this;\r\n                var thatValue = value;\r\n\r\n                MeadCo.log(\"servicesServer::verifyurl: \" + value + \", async: \" + bAsync);\r\n\r\n                // if an orchestrator has been defined then ask it for the current users port\r\n                if (typeof this.orchestratorPort !== \"number\") {\r\n                    this.orchestratorPort = parseInt(\"\" + this.orchestratorPort);\r\n                }\r\n\r\n                if (this.orchestratorPort > 0) {\r\n                    MeadCo.log(\"Using request to Orchestrator on port: \" + this.orchestratorPort);\r\n                    that.verifying = true;\r\n\r\n                    // by definition Orchestrator is local.\r\n                    var apiEndPoint;\r\n                    if (typeof this.orchestratorKey === \"string\" && this.orchestratorKey.length > 0) {\r\n                        apiEndPoint = \"/api/v2?key=\" + this.orchestratorKey;\r\n                    }\r\n                    else {\r\n                        apiEndPoint = \"/api/v1\";\r\n                    }\r\n\r\n                    MeadCo.log(\"servicesServer::querying orchestrator: \" + \"http://127.0.0.1:\" + this.orchestratorPort + apiEndPoint);\r\n\r\n                    if (outerScope.jQuery && !MeadCo.fetchEnabled) {\r\n                        outerScope.jQuery.ajax(\"http://127.0.0.1:\" + this.orchestratorPort + apiEndPoint,\r\n                            {\r\n                                method: \"GET\",\r\n                                dataType: \"json\",\r\n                                cache: false,\r\n                                async: bAsync\r\n                            }).done(function (data) {\r\n\r\n                                MeadCo.log(\"orchestrator returned ScriptX.Services port: \" + data.HttpPort)\r\n\r\n                                var urlHelper = new URL(thatValue);\r\n                                urlHelper.port = data.HttpPort;\r\n                                thatValue = urlHelper.protocol + \"//\" + urlHelper.host + urlHelper.pathname\r\n\r\n                                that.test(thatValue, 0, bAsync, function (urlFound) {\r\n                                    that.serviceUrl = urlFound;\r\n                                    that.pendingUrl = \"\";\r\n                                    that.verifying = false;\r\n                                    resolve(urlFound, true);\r\n                                }, function (errorThrown) {\r\n                                    that.serviceUrl = \"\";\r\n                                    that.pendingUrl = \"\";\r\n                                    that.failedUrl = thatValue;\r\n                                    that.verifying = false;\r\n                                    if (typeof reject === \"function\") {\r\n                                        reject(errorThrown);\r\n                                    }\r\n                                });\r\n\r\n                            })\r\n                            .fail(function (jqXhr, textStatus, errorThrown) {\r\n                                that.verifying = false;\r\n                                that.serviceUrl = \"\";\r\n                                that.pendingUrl = \"\";\r\n                                that.failedUrl = thatValue;\r\n\r\n                                const msg = MeadCo.parseAjaxError(\"Failed to connect with Orchestrator: \", jqXhr, textStatus, errorThrown);\r\n                                MeadCo.warn(msg);\r\n\r\n                                if (typeof reject === \"function\") {\r\n                                    reject(\"Failed to connect with Orchestrator: \" + msg);\r\n                                }\r\n                            });\r\n                    }\r\n                    else {\r\n                        fetch(\"http://127.0.0.1:\" + this.orchestratorPort + apiEndPoint)\r\n                            .then((response) => {\r\n                                if (!response.ok) {\r\n                                    throw new Error(`HTTP Error: ${response.status}`)\r\n                                }\r\n                                return response.json();\r\n                            })\r\n                            .then(data => {\r\n                                MeadCo.log(\"orchestrator returned ScriptX.Services port: \" + data.HttpPort)\r\n\r\n                                var urlHelper = new URL(thatValue);\r\n                                urlHelper.port = data.HttpPort;\r\n                                thatValue = urlHelper.protocol + \"//\" + urlHelper.host + urlHelper.pathname\r\n\r\n                                that.test(thatValue, 0, bAsync, function (urlFound) {\r\n                                    that.serviceUrl = urlFound;\r\n                                    that.pendingUrl = \"\";\r\n                                    that.verifying = false;\r\n                                    resolve(urlFound, true);\r\n                                }, function (errorThrown) {\r\n                                    that.serviceUrl = \"\";\r\n                                    that.pendingUrl = \"\";\r\n                                    that.failedUrl = thatValue;\r\n                                    that.verifying = false;\r\n                                    if (typeof reject === \"function\") {\r\n                                        reject(errorThrown);\r\n                                    }\r\n                                });\r\n                            })\r\n                            .catch(error => {\r\n                                that.verifying = false;\r\n                                that.serviceUrl = \"\";\r\n                                that.pendingUrl = \"\";\r\n                                that.failedUrl = thatValue;\r\n\r\n                                const errorThrown = MeadCo.parseFetchError(\"MeadCo.ScriptX.Print:verifyUrl - \" + value, error);\r\n\r\n                                if (typeof reject === \"function\") {\r\n                                    reject(\"Failed to connect with Orchestrator: \" + errorThrown);\r\n                                }\r\n                            });\r\n                    }\r\n                }\r\n                else {\r\n                    that.verifying = true;\r\n                    that.test(thatValue, that.portsToTry, bAsync, function (urlFound) {\r\n                        that.serviceUrl = urlFound;\r\n                        that.pendingUrl = \"\";\r\n                        that.verifying = false;\r\n                        resolve(urlFound, false);\r\n                    }, function (errorThrown) {\r\n                        that.serviceUrl = \"\";\r\n                        that.pendingUrl = \"\";\r\n                        that.verifying = false;\r\n\r\n                        try {\r\n                            let t = new URL(thatValue);\r\n                            that.failedUrl = thatValue;\r\n                        }\r\n                        catch (_) { }\r\n\r\n                        if (typeof reject === \"function\") {\r\n                            reject(\"ScriptX.Services could not be found at \\\"\" + thatValue + \"\\\". Is it installed and running?\");\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n            else {\r\n                if (this.IsFailedConnection(value)) {\r\n                    if (typeof reject === \"function\") {\r\n                        reject(\"ScriptX.Services connection to: \" + value + \" is either invalid or has already failed and will not be re-tried.\")\r\n                    }\r\n                    else {\r\n                        MeadCo.warn(\"ScriptX.Services connection to: \" + value + \" has already failed and will not be re-tried.\")\r\n                    }\r\n                }\r\n                else\r\n                    resolve(this.serviceUrl, this.orchestratorPort > 0);\r\n            }\r\n        },\r\n\r\n        // test\r\n        //\r\n        // Can we ask something and get a response, without using a license - checks the server is there.\r\n        //\r\n        // Will perform port hunt (increment the port number) when attempting to connect to\r\n        // ScriptX.Services for Windows PC\r\n        //\r\n        test: function (serverUrl, nHuntAllowed, bAsync, resolve, reject) {\r\n            if (serverUrl.length > 0) {\r\n                const that = this;\r\n                let urlHelper;\r\n\r\n                try {\r\n                    urlHelper = new URL(serverUrl);\r\n                    if (urlHelper.protocol !== 'http:' && urlHelper.protocol !== 'https:') {\r\n                        reject(\"Invalid protocol: \" + serverUrl);\r\n                        return;\r\n                    }\r\n                } catch (_) {\r\n                    reject(\"Invalid URL: \" + serverUrl);\r\n                    return;\r\n                }\r\n\r\n                MeadCo.log(\"Test server requested: \" + serverUrl + \", port: \" + urlHelper.port);\r\n\r\n                // use the license API\r\n                const serviceUrl = MeadCo.makeApiEndPoint(urlHelper.href, licenseApiLocation + \"/ping\");\r\n\r\n                if (outerScope.jQuery && !MeadCo.fetchEnabled) {\r\n                    MeadCo.log(\".ajax() get: \" + serviceUrl);\r\n                    outerScope.jQuery.ajax(serviceUrl,\r\n                        {\r\n                            method: \"GET\",\r\n                            dataType: \"json\",\r\n                            cache: false,\r\n                            async: bAsync\r\n                        }).done(function (data) {\r\n                            const resolvedUrl = urlHelper.protocol + \"//\" + urlHelper.host + urlHelper.pathname;\r\n                            MeadCo.log(\"Test server succeed, resolve(\" + resolvedUrl + \")\")\r\n                            resolve(resolvedUrl);\r\n                        })\r\n                        .fail(function (jqXhr, textStatus, errorThrown) {\r\n                            // only do hunting with 4WPC and that must be on 127.0.0.1 or localhost\r\n                            MeadCo.log(\"Test server failed: [\" + errorThrown + \"], \" + nHuntAllowed + \", on: \" + urlHelper.hostname);\r\n                            if (nHuntAllowed > 0 && (urlHelper.hostname === \"localhost\" || urlHelper.hostname == \"127.0.0.1\")) {\r\n                                urlHelper.port++;\r\n                                outerScope.setTimeout(that.test(urlHelper.protocol + \"//\" + urlHelper.host + urlHelper.pathname, --nHuntAllowed, bAsync, resolve, reject), 1);\r\n                            }\r\n                            else {\r\n                                errorThrown = MeadCo.parseAjaxError(\"MeadCo.ScriptX.Print.servicesServer.test:\", jqXhr, textStatus, errorThrown);\r\n                                if (typeof reject === \"function\") {\r\n                                    MeadCo.log(\"rejecting with: \" + errorThrown);\r\n                                    reject(errorThrown);\r\n                                }\r\n                                else {\r\n                                    MeadCo.warn(\"failed with no reject function\");\r\n                                }\r\n                            }\r\n                        });\r\n                }\r\n                else {\r\n                    MeadCo.log(\"fetch get: \" + serviceUrl);\r\n                    if (bAsync) {\r\n                        fetch(serviceUrl)\r\n                            .then((response) => {\r\n                                if (!response.ok) {\r\n                                    throw new Error(`HTTP Error: ${response.status}`)\r\n                                }\r\n                                return response.json();\r\n                            })\r\n                            .then(data => {\r\n                                const resolvedUrl = urlHelper.protocol + \"//\" + urlHelper.host + urlHelper.pathname;\r\n                                MeadCo.log(\"Test server succeed, resolve(\" + resolvedUrl + \")\")\r\n                                resolve(resolvedUrl);\r\n                            })\r\n                            .catch((error) => {\r\n                                // only do hunting with 4WPC and that must be on 127.0.0.1 or localhost\r\n                                MeadCo.log(\"Test server failed: [\" + error + \"], \" + nHuntAllowed + \", on: \" + urlHelper.hostname);\r\n                                if (nHuntAllowed > 0 && (urlHelper.hostname === \"localhost\" || urlHelper.hostname == \"127.0.0.1\")) {\r\n                                    urlHelper.port++;\r\n                                    outerScope.setTimeout(that.test(urlHelper.protocol + \"//\" + urlHelper.host + urlHelper.pathname, --nHuntAllowed, bAsync, resolve, reject), 1);\r\n                                }\r\n                                else {\r\n                                    errorThrown = MeadCo.parseFetchError(\"MeadCo.ScriptX.Print.servicesServer.test:\", error);\r\n                                    if (typeof reject === \"function\") {\r\n                                        MeadCo.log(\"rejecting with: \" + errorThrown);\r\n                                        reject(errorThrown);\r\n                                    }\r\n                                    else {\r\n                                        MeadCo.warn(\"failed with no reject function\");\r\n                                    }\r\n                                }\r\n\r\n                            });\r\n                    }\r\n                    else {\r\n                        MeadCo.error(\"Synchronous Ajax calls requires jQuery\");\r\n                        if (typeof reject === \"function\") {\r\n                            reject(\"Synchronous Ajax calls requires jQuery\");\r\n                        }\r\n                    }\r\n                }\r\n\r\n            }\r\n        },\r\n\r\n        // send a method request to an end point\r\n        //\r\n        call: function (sApi, method, oApiData, bLicensed, bAsync, resolve, reject) {\r\n\r\n            const that = this;\r\n\r\n            if (this.serviceUrl === \"\" && this.pendingUrl !== \"\") {\r\n\r\n                this.verifyUrl(this.pendingUrl, bAsync, function () {\r\n                    if (that.url !== \"\") {\r\n                        that.call(sApi, method, oApiData, bLicensed, bAsync, resolve, reject);\r\n                    }\r\n                    else {\r\n                        if (typeof reject === \"function\") {\r\n                            reject(\"Server url verification failed to set url\");\r\n                        }\r\n                    }\r\n                }, reject);\r\n            }\r\n            else {\r\n                if (this.serviceUrl !== \"\") {\r\n                    const serviceUrl = MeadCo.makeApiEndPoint(this.serviceUrl, sApi);\r\n                    MeadCo.log(\"servicesServer.call() \" + method + \": \" + serviceUrl);\r\n                    let oPayload = {\r\n                        method: method,\r\n                        cache: false,\r\n                        async: bAsync,\r\n                        jsonp: false,\r\n                        dataType: \"json\",\r\n                        contentType: \"application/json\"\r\n                    };\r\n\r\n                    if (bLicensed) {\r\n                        oPayload.headers = {\r\n                            \"Authorization\": \"Basic \" + btoa(licenseGuid + \":\")\r\n                        }\r\n                    }\r\n\r\n                    if (!this.IsEmptyPayload(oApiData)) {\r\n                        MeadCo.log(\"payload defined.\");\r\n                        oPayload.data = JSON.stringify(oApiData);\r\n                    }\r\n\r\n                    if (outerScope.jQuery && !MeadCo.fetchEnabled) {\r\n                        outerScope.jQuery.ajax(serviceUrl, oPayload)\r\n                            .done(function (data) {\r\n                                if (typeof resolve === \"function\") {\r\n                                    resolve(data);\r\n                                }\r\n                                return data;\r\n                            })\r\n                            .fail(function (jqXhr, textStatus, errorThrown) {\r\n                                errorThrown = MeadCo.parseAjaxError(\"MeadCo.ScriptX.Print:\" + sApi + method, jqXhr, textStatus, errorThrown);\r\n                                if (typeof reject === \"function\")\r\n                                    reject(errorThrown);\r\n                                else {\r\n                                    throw new Error(errorThrown);\r\n                                }\r\n                            })\r\n                            .always(function (dataOrjqXHR, textStatus, jqXHRorErrorThrown) {\r\n                                that.undoTrust();\r\n                            });\r\n                    }\r\n                    else {\r\n                        if (bAsync) {\r\n                            if (bLicensed) {\r\n                                oPayload.headers = {\r\n                                    \"Authorization\": \"Basic \" + btoa(licenseGuid + \":\"),\r\n                                    \"Content-type\": \"application/json\"\r\n                                }\r\n                            }\r\n                            else {\r\n                                oPayload.headers = {\r\n                                    \"Content-type\": \"application/json\"\r\n                                }\r\n                            }\r\n\r\n                            const netcall = fetch(serviceUrl, {\r\n                                method: oPayload.method,\r\n                                headers: oPayload.headers,\r\n                                body: oPayload.data,\r\n                                referrerPolicy: \"origin-when-cross-origin\",\r\n                                mode: \"cors\",\r\n                                credentials: \"omit\",\r\n                                cache: \"no-store\",\r\n                                redirect: \"error\",\r\n                                keepalive: false\r\n                            })\r\n                                .then((response) => {\r\n                                    that.undoTrust();\r\n                                    if (!response.ok) {\r\n                                        // throw new Error(`HTTP Error: ${response.status}`)\r\n                                        if (response.status == 500 || response.status == 404) {\r\n                                            const err = response.text()\r\n                                                .then(errorTxt => {\r\n                                                    const errorThrown = MeadCo.parseFetchError(\"MeadCo.ScriptX.Print:\" + sApi + method, errorTxt);\r\n                                                    if (typeof reject === \"function\")\r\n                                                        reject(errorThrown);\r\n                                                    else {\r\n                                                        throw new Error(errorThrown);\r\n                                                    }\r\n                                                });\r\n                                        }\r\n                                        else {\r\n                                            if (typeof reject === \"function\")\r\n                                                reject(response.statusText);\r\n                                            else {\r\n                                                throw new Error(response.statusText);\r\n                                            }\r\n                                        }\r\n                                        return;\r\n                                    }\r\n                                    return response.json();\r\n                                })\r\n                                .then(data => {\r\n                                    if (data && typeof resolve === \"function\") {\r\n                                        resolve(data);\r\n                                    }\r\n                                })\r\n                                .catch((error) => {\r\n                                    const errorThrown = MeadCo.parseFetchError(\"MeadCo.ScriptX.Print:\" + sApi + method, error);\r\n                                    if (typeof reject === \"function\")\r\n                                        reject(errorThrown);\r\n                                    else {\r\n                                        throw new Error(errorThrown);\r\n                                    }\r\n                                });\r\n                        }\r\n                        else {\r\n                            if (typeof reject === \"function\") {\r\n                                reject(\"Synchronous Ajax calls requires jQuery\");\r\n                            }\r\n                            else\r\n                                throw new Error(\"Synchronous Ajax calls requires jQuery\");\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    if (typeof reject === \"function\") {\r\n                        reject(\"MeadCo.ScriptX.Print : server connection is not defined.\");\r\n                    }\r\n                    else\r\n                        throw new Error(\"MeadCo.ScriptX.Print : server connection is not defined.\");\r\n                }\r\n            }\r\n\r\n            return true;\r\n        },\r\n\r\n        // determine if the server is changing - domain or port has changed when not using orchestrator\r\n        IsChangingServer: function (aServerUrl) {\r\n            if (this.serviceUrl !== \"\") {\r\n\r\n                try {\r\n                    var currentUrl = new URL(this.serviceUrl);\r\n                    var newUrl = new URL(aServerUrl);\r\n\r\n                    return currentUrl.hostname != newUrl.hostname || (currentUrl.port != newUrl.port && this.orchestratorPort == 0);\r\n                } catch (e) {\r\n                    MeadCo.error(\"Failed to construct URL(): \" + e.message + \", from: \" + this.serviceUrl + \", or: \" + aServerUrl);\r\n                    MeadCo.error(\"Many errors will ensue\");\r\n                    return false; // will stop attempts to use something bad.\r\n                }\r\n            }\r\n\r\n            return true;\r\n        },\r\n\r\n        IsEmptyPayload(oPayload) {\r\n            return oPayload === null || (Object.keys(oPayload).length === 0 && oPayload.constructor === Object);\r\n        },\r\n\r\n        // bad news to retest ports on a host that has already been tried, in a page lifetime, it isnt going to get any better.\r\n        IsFailedConnection: function (aServerUrl) {\r\n            if (this.failedUrl.length > 0) {\r\n                try {\r\n                    var failedUrl = new URL(this.failedUrl);\r\n                    var newUrl = new URL(aServerUrl);\r\n\r\n                    if (failedUrl.hostname === newUrl.hostname) {\r\n                        MeadCo.warn(\"Attempt to use: \" + aServerUrl + \" is noted as a failed connection and will not be retried\");\r\n                        return true;\r\n                    }\r\n\r\n                    return false;\r\n                } catch (e) {\r\n                    MeadCo.error(\"Testing IsFailed unable to construct URL(): \" + e.message + \", from: \" + this.failedUrl + \", or: \" + aServerUrl);\r\n                    return true; // will stop attempts to use something bad.\r\n                }\r\n            }\r\n\r\n            return false;\r\n        }\r\n    };\r\n\r\n    var licenseGuid = \"\";\r\n    var bConnected = false; // true when default device settings have been obtained from a .services server\r\n\r\n    var bDoneAuto = false;\r\n\r\n    var availablePrinters = [];\r\n\r\n    var cachedServiceDescription = null; // cached description of service server connected to \r\n\r\n    /**\r\n     * Enum for type of content being posted to printHtml API\r\n     *\r\n     * @memberof MeadCoScriptXPrint    \r\n     * @typedef {number} ContentType\r\n     * @enum {ContentType}\r\n     * @readonly\r\n     * @property {number} URL 1 the url will be downloaded and printed\r\n     * @property {number} HTML 2 the passed string is assumed to be a complete html document .. <html>..</html>\r\n     * @property {number} INNERHTML 4 the passed string is a complete html document but missing the html tags\r\n     * @property {number} STRING 8 the passed string is assumed to contain no html but may contain other language such as ZPL (for direct printing)\r\n     */\r\n    var enumContentType = {\r\n        URL: 1, // the url will be downloaded and printed (for html and direct printing)\r\n        HTML: 2, // the passed string is assumed to be a complete html document .. <html>..</html>\r\n        INNERHTML: 4, // the passed string is a complete html document but missing the html tags\r\n        STRING: 8 // the passed string is assumed to contain no html but may contain other language such as ZPL (for direct printing)\r\n    };\r\n\r\n    var enumResponseStatus = {\r\n        UNKNOWN: 0,\r\n        QUEUEDTODEVICE: 1,\r\n        QUEUEDTOFILE: 2,\r\n        SOFTERROR: 3,\r\n        OK: 4\r\n    };\r\n\r\n    /**\r\n     * Enum for required behaviour when an error occurs. \r\n     *\r\n     * @memberof MeadCoScriptXPrint    \r\n     * @typedef {number} ErrorAction\r\n     * @enum {ErrorAction}\r\n     * @readonly\r\n     * @property {number} REPORT 1 Call MeadCo.ScriptX.Print.reportServerError(errMsg)\r\n     * @property {number} THROW 2 throw an error : throw errMsg\r\n     */\r\n    var enumErrorAction = {\r\n        REPORT: 1,\r\n        THROW: 2\r\n    };\r\n    var errorAction = enumErrorAction.REPORT;\r\n\r\n    /**\r\n     * Enum for the class of service connected to.\r\n     * \r\n     * @memberof MeadCoScriptXPrint\r\n     * @typedef { number } ServiceClasses\r\n     * @enum { ServiceClasses }\r\n     * @readonly \r\n     * @property { number } CLOUD 1 MeadCo Cloud Service \r\n     * @property { number } ONPREMISE 2 ScriptX.Services for On Premise Devices\r\n     * @property { number } WINDOWSPC 3 ScriptX.Services for Windows PC\r\n     * */\r\n    var enumServiceClass = {\r\n        CLOUD: 1,\r\n        ONPREMISE: 2,\r\n        WINDOWSPC: 3\r\n    };\r\n\r\n    /**\r\n     * Information about the service that is connected to - version detail and facilities available\r\n     * See also: https://www.meadroid.com/Developers/KnowledgeBank/TechnicalReference/ScriptXServices/WebServiceAPIReference/ServiceDescription/GET\r\n     * \r\n     * @typedef ServiceDescriptionObject\r\n     * @memberof MeadCoScriptXPrint\r\n     * @property {ServiceClasses} serviceClass the class of the service; cloud, onpremise, pc\r\n     * @property {string} currentAPIVersion the latest version implemented (eg 'v1' or 'v2' etc)\r\n     * @property {VersionObject} serviceVersion implementation version of the service\r\n     * @property {VersionObject} serverVersion The version of ScriptX Server used by the service\r\n     * @property {VersionObject} serviceUpgrade The latest version of the service that is available and later than ServiceVersion/me \r\n     * @property {Array.<string>} availablePrinters Array of the names of the available printers\r\n     * @property {boolean} printHTML Printing of HTML is supported\r\n     * @property {boolean} printPDF Printing of PDF documents is supported\r\n     * @property {boolean} printDIRECT Direct printing to a print device is supported\r\n     * */\r\n    var ServiceDescriptionObject; // for Doc Generator\r\n\r\n    /**\r\n     * Enum for status code returned to print progress callbacks\r\n     *\r\n     * @memberof MeadCoScriptXPrint    \r\n     * @typedef {number} PrintStatus\r\n     * @enum {PrintStatus}\r\n     * @readonly\r\n     * @property {number} NOTSTARTED 0\r\n     * @property {number} QUEUED 1\r\n     * @property {number} STARTING 2\r\n     * @property {number} DOWNLOADING 3\r\n     * @property {number} DOWNLOADED 4\r\n     * @property {number} PRINTING 5\r\n     * @property {number} COMPLETED 6\r\n     * @property {number} PAUSED 7\r\n     * @property {number} PRINTPDF 8\r\n     * @property {number} ERROR -1\r\n     * @property {number} ABANDONED -2\r\n     */\r\n    var enumPrintStatus = {\r\n        NOTSTARTED: 0,\r\n\r\n        // queue call back opcodes ...\r\n        QUEUED: 1,\r\n        STARTING: 2,\r\n        DOWNLOADING: 3,\r\n        DOWNLOADED: 4,\r\n        PRINTING: 5,\r\n        COMPLETED: 6,\r\n        PAUSED: 7,\r\n        PRINTPDF: 8,\r\n\r\n        ERROR: -1,\r\n        ABANDONED: -2\r\n    };\r\n\r\n    /**\r\n     * Enum to describe the collation option when printing \r\n     *\r\n     * @memberof MeadCoScriptXPrint   \r\n     * @typedef {number} CollateOptions\r\n     * @enum {CollateOptions}\r\n     * @readonly\r\n     * @property {number} DEFAULT 0 use the default at the print server\r\n     * @property {number} TRUE 1 collate pages when printing\r\n     * @property {number} FALSE 2 do not collate pages\r\n     */\r\n    var enumCollateOptions = {\r\n        DEFAULT: 0,\r\n        TRUE: 1,\r\n        FALSE: 2\r\n    };\r\n\r\n    /**\r\n     * Enum to describe the duplex print option to use when printing \r\n     *\r\n     * @memberof MeadCoScriptXPrint\r\n     * @typedef {number} DuplexOptions\r\n     * @enum {DuplexOptions}\r\n     * @readonly\r\n     * @property {number} DEFAULT 0 use the default at the print server\r\n     * @property {number} SIMPLEX 1 \r\n     * @property {number} VERTICAL 2 \r\n     * @property {number} HORIZONTAL 3\r\n     */\r\n    var enumDuplexOptions = {\r\n        DEFAULT: 0,\r\n        SIMPLEX: 1,\r\n        VERTICAL: 2,\r\n        HORIZONTAL: 3\r\n    };\r\n\r\n    function queueJob(data) {\r\n        activePrintQueue.push(data);\r\n        MeadCo.log(\"ScriptX.Print queueJob: \" + data.jobIdentifier + \", name: \" + data.jobName + \", jobCount: \" + activePrintQueue.length);\r\n    }\r\n\r\n    function jobCount() {\r\n        MeadCo.log(\"ScriptX.Print jobCount: \" + activePrintQueue.length);\r\n        return activePrintQueue.length;\r\n    }\r\n\r\n    function findJob(id) {\r\n        return activePrintQueue.find(e => e.jobIdentifier === id);\r\n    }\r\n\r\n    function updateJob(data) {\r\n        let j = findJob(data.jobIdentifier);\r\n        if (j) {\r\n            Object.keys(data).forEach(function (key) {\r\n                j[key] = data[key];\r\n            });\r\n            return;\r\n        }\r\n\r\n        MeadCo.warn(\"Unable to find job: \" + data.jobIdentifier + \" to update it\");\r\n    }\r\n\r\n    function removeJob(id) {\r\n\r\n        activePrintQueue = activePrintQueue.filter(e => e.jobIdentifier !== id);\r\n        MeadCo.log(`ScriptX.Print removed job: ${id}, jobCount: ${activePrintQueue.length}`);\r\n        // no jobs being processed, allow next immediate start\r\n        if (activePrintQueue.length == 0) previousPrintCallWasAt = 0;\r\n\r\n    }\r\n\r\n    function progress(requestData, status, information) {\r\n        if (typeof requestData.OnProgress === \"function\") {\r\n            requestData.OnProgress(status, information, requestData.UserData);\r\n        }\r\n    }\r\n\r\n    // funcPrintHtmlAtServer\r\n    //\r\n    // Create a closure on all the data for a print job which can be used with timeout.\r\n    //\r\n    var nextJobFileName = \"\";\r\n    function funcPrintHtmlAtServer(contentType, content, htmlPrintSettings, trackingData, fnDone, fnProgress, fnOnQueuedFileAvailable) {\r\n        MeadCo.log(\"started MeadCo.ScriptX.Print.print.printHtmlAtServer() Type: \" + contentType);\r\n        if (contentType === enumContentType.URL) {\r\n            MeadCo.log(\".. request print url: \" + content);\r\n        }\r\n\r\n        // must deepclone objects not values by reference.\r\n        var devInfo;\r\n        if (printerName === \"\") {\r\n            devInfo = {};\r\n        } else {\r\n            if (printerName === magicPrintPreviewPrinter) {\r\n                devInfo = JSON.parse(JSON.stringify({\r\n                    printerName: printerName\r\n                }));\r\n            }\r\n            else\r\n                devInfo = JSON.parse(JSON.stringify(deviceSettings[printerName]));\r\n        }\r\n\r\n        var requestData = {\r\n            ContentType: contentType,\r\n            Content: content,\r\n            Settings: JSON.parse(JSON.stringify(htmlPrintSettings)),\r\n            Device: devInfo,\r\n            ProtectedContentAccess: AccessControl,\r\n            OnProgress: fnProgress,\r\n            UserData: trackingData\r\n        };\r\n\r\n        var fakeJob = {\r\n            jobIdentifier: Date.now(),\r\n            printerName: requestData.Device.printerName,\r\n            jobName: jobNameWaitingForSend\r\n        };\r\n        queueJob(fakeJob); // essentially a lock on the queue to stop it looking empty until this job is processed\r\n\r\n        var requiredOutputName = nextJobFileName;\r\n        nextJobFileName = \"\";\r\n\r\n        var fnOnFileAvailable = fnOnQueuedFileAvailable;\r\n\r\n        return function () {\r\n            removeJob(fakeJob.jobIdentifier);\r\n            return printAtServer(htmlApiLocation, requestData,\r\n                {\r\n                    fail: function (err) {\r\n                        progress(requestData, enumPrintStatus.ERROR, err);\r\n                        MeadCo.ScriptX.Print.reportError(err);\r\n                        if (typeof fnDone === \"function\") {\r\n                            fnDone(\"Server error\");\r\n                        }\r\n                    },\r\n\r\n                    queuedToFile: function (data) {\r\n                        MeadCo.log(\"print is being queued to a file\");\r\n                        progress(requestData, enumPrintStatus.QUEUED);\r\n                        monitorJob(htmlApiLocation, requestData, data.jobIdentifier,\r\n                            -1,\r\n                            function (data) {\r\n                                if (data !== null) {\r\n                                    MeadCo.log(\"download printed file is available\");\r\n                                    progress(requestData, enumPrintStatus.COMPLETED);\r\n\r\n                                    var api = MeadCo.makeApiEndPoint(servicesServer.url, htmlApiLocation + \"/download/\" + data.jobIdentifier);\r\n                                    if (requiredOutputName.length > 0) {\r\n                                        api += \"/\" + requiredOutputName;\r\n                                    }\r\n                                    fnOnFileAvailable(api, data.jobIdentifier);\r\n                                }\r\n\r\n                                if (typeof fnDone === \"function\") {\r\n                                    fnDone(data === null ? \"Server error\" : null);\r\n                                }\r\n                            });\r\n                    },\r\n\r\n                    queuedToDevice: function (data) {\r\n                        MeadCo.log(\"print was queued to device\");\r\n                        progress(requestData, enumPrintStatus.QUEUED);\r\n                        monitorJob(htmlApiLocation, requestData, data.jobIdentifier,\r\n                            -1,\r\n                            function (data) {\r\n                                if (data !== null) {\r\n                                    progress(requestData, enumPrintStatus.COMPLETED);\r\n                                }\r\n\r\n                                if (typeof fnDone === \"function\") {\r\n                                    fnDone(data === null ? \"Server error\" : null);\r\n                                }\r\n                            });\r\n                    },\r\n\r\n                    softError: function (data) {\r\n                        progress(requestData, enumPrintStatus.ERROR, data.message);\r\n                        MeadCo.ScriptX.Print.reportError(data.message);\r\n                        MeadCo.log(\"print has soft error\");\r\n                        removeJob(data.jobIdentifier);\r\n                        if (typeof fnDone === \"function\") {\r\n                            MeadCo.log(\"Call fnDone\");\r\n                            fnDone(data.message);\r\n                        }\r\n                    },\r\n\r\n                    ok: function (data) {\r\n                        progress(requestData, enumPrintStatus.COMPLETED);\r\n                        MeadCo.log(\"printed ok, no further information\");\r\n                        removeJob(data.jobIdentifier);\r\n                        if (typeof fnDone === \"function\") {\r\n                            fnDone(null);\r\n                        }\r\n                    }\r\n                })\r\n        };\r\n    }\r\n\r\n\r\n    /**\r\n     * Post a request to the server api/v1/print to print some html and monitor the print job \r\n     * to completion. If the server prints to file then the file is returned as a download.\r\n     * \r\n     * There is no guarantee of the order of outgoing calls, no guarantee they will ber processed in \r\n     * order at the server if they go from the client very quickly. ScriptX.Addon printHtml() was \r\n     * deterministic in its order - jobs were printed in the order of the calls. In order to \r\n     * achieve this without a push pull queue rapid calls are spaced a part via settimeout()\r\n     * \r\n     * @function printHtmlAtServer\r\n     * @memberof MeadCoScriptXPrint\r\n\r\n     * @param {ContentType} contentType enum type of content given (html snippet, url)\r\n     * @param {string} content the content - a url, html snippet or complete html\r\n     * @param {object} htmlPrintSettings the settings to use - page and html such as headers and footers\r\n     * @param {function({string})} fnDone function to call when printing complete (and output returned), arg is null on no error, else error message\r\n     * @param {function(status,sInformation,data)} fnProgress function to call when job status is updated\r\n     * @param {any} trackingData object to give pass to fnProgress\r\n     * @return {boolean} - true if a print was started (otherwise an error will be thrown)\r\n     * @private\r\n     */\r\n    var timeoutToJobStart = 0;\r\n    var previousPrintCallWasAt = 0;\r\n    var timeoutSpacingMSecs = 750;\r\n    var jobGapResetTimeout = 10000;\r\n    function printHtmlAtServer(contentType, content, htmlPrintSettings, fnDone, fnProgress, trackingData) {\r\n\r\n        if (!content || (typeof content === \"string\" && content.length === 0)) {\r\n            MeadCo.ScriptX.Print.reportError(\"Request to print no content - access denied?\");\r\n            if (typeof fnDone === \"function\") {\r\n                fnDone(\"Request to print no content\");\r\n            }\r\n            return false;\r\n        }\r\n\r\n        // if previous call was over (default) 10 seconds ago, reset\r\n        var t = Date.now();\r\n        if ((t - previousPrintCallWasAt) > jobGapResetTimeout) {\r\n            timeoutToJobStart = 0;\r\n        }\r\n        previousPrintCallWasAt = t;\r\n        setTimeout(funcPrintHtmlAtServer(contentType, content, htmlPrintSettings, trackingData, fnDone, fnProgress, function (sApi) {\r\n            window.open(sApi, \"_self\");\r\n        }), timeoutToJobStart);\r\n        timeoutToJobStart += timeoutSpacingMSecs;\r\n        return true;\r\n    }\r\n\r\n    // funcPrintPdfAtServer\r\n    //\r\n    // Create a closure on all the data for a print job which can be used with timeout.\r\n    //\r\n    function funcPrintPdfAtServer(document, pdfPrintSettings, fnDone, fnProgress, data) {\r\n\r\n        MeadCo.log(\"started MeadCo.ScriptX.Print.print.printPdfAtServer() document: \" + document + \", printerName: \" + printerName);\r\n\r\n        let devInfo;\r\n        // deep clones of objects\r\n        if (printerName === \"\") {\r\n            devInfo = {};\r\n        } else {\r\n            devInfo = JSON.parse(JSON.stringify(deviceSettings[printerName]));\r\n        }\r\n\r\n        const requestData = {\r\n            Document: document,\r\n            Description: pdfPrintSettings.jobDescription,\r\n            Settings: JSON.parse(JSON.stringify(pdfPrintSettings)),\r\n            Device: devInfo,\r\n            ProtectedContentAccess: AccessControl,\r\n            OnProgress: fnProgress,\r\n            UserData: data\r\n        };\r\n\r\n        // used/required by printAtServer ...\r\n        requestData.Settings.jobTitle = pdfPrintSettings.jobDescription;\r\n\r\n        const fakeJob = {\r\n            jobIdentifier: Date.now(),\r\n            printerName: requestData.Device.printerName,\r\n            jobName: jobNameWaitingForSend\r\n        };\r\n        queueJob(fakeJob); // essentially a lock on the queue to stop it looking empty until this job is processed\r\n\r\n        var requiredOutputName = nextJobFileName;\r\n        nextJobFileName = \"\";\r\n\r\n        return function () {\r\n            removeJob(fakeJob.jobIdentifier);\r\n            return printAtServer(pdfApiLocation, requestData,\r\n                {\r\n                    fail: function (err) {\r\n                        progress(requestData, enumPrintStatus.ERROR, err);\r\n                        MeadCo.ScriptX.Print.reportError(err);\r\n                        if (typeof fnDone === \"function\") {\r\n                            fnDone(\"Server error\");\r\n                        }\r\n                    },\r\n\r\n                    queuedToFile: function (data) {\r\n                        MeadCo.log(\"default handler on queued to file response\");\r\n                        progress(requestData, enumPrintStatus.QUEUED);\r\n                        monitorJob(pdfApiLocation, requestData, data.jobIdentifier,\r\n                            -1,\r\n                            function (data) {\r\n                                if (data !== null) {\r\n                                    MeadCo.log(\"Will download printed file\");\r\n                                    progress(requestData, enumPrintStatus.COMPLETED);\r\n                                    let api = MeadCo.makeApiEndPoint(servicesServer.url, pdfApiLocation + \"/download/\" + data.jobIdentifier);\r\n                                    if (requiredOutputName.length > 0) {\r\n                                        api += \"/\" + requiredOutputName;\r\n                                    }\r\n                                    window.open(api, \"_self\");\r\n                                }\r\n\r\n                                if (typeof fnDone === \"function\") {\r\n                                    fnDone(data === null ? \"Server error\" : null);\r\n                                }\r\n                            });\r\n                    },\r\n\r\n                    queuedToDevice: function (data) {\r\n                        MeadCo.log(\"print was queued to device\");\r\n                        progress(requestData, enumPrintStatus.QUEUED);\r\n                        monitorJob(pdfApiLocation, requestData, data.jobIdentifier,\r\n                            -1,\r\n                            function (data) {\r\n                                if (data !== null) {\r\n                                    progress(requestData, enumPrintStatus.COMPLETED);\r\n                                }\r\n\r\n                                if (typeof fnDone === \"function\") {\r\n                                    fnDone(data === null ? \"Server error\" : null);\r\n                                }\r\n                            });\r\n                    },\r\n\r\n                    softError: function (data) {\r\n                        progress(requestData, enumPrintStatus.ERROR, data.message);\r\n                        MeadCo.ScriptX.Print.reportError(data.message);\r\n                        MeadCo.log(\"printpdf call has soft error, remove job: \" + data.jobIdentifier);\r\n                        removeJob(data.jobIdentifier);\r\n                        if (typeof fnDone === \"function\") {\r\n                            MeadCo.log(\"Call fnDone\");\r\n                            fnDone(\"Server error\");\r\n                        }\r\n                    },\r\n\r\n                    ok: function (data) {\r\n                        progress(requestData, enumPrintStatus.COMPLETED);\r\n                        MeadCo.log(\"printed ok, no further information\");\r\n                        removeJob(data.jobIdentifier);\r\n                        if (typeof fnDone === \"function\") {\r\n                            fnDone(null);\r\n                        }\r\n                    }\r\n                });\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Post a request to the server api/v1/print to print a pdf document and monitor the print job \r\n     * to completion. If the server prints to file then the file is returned as a download\r\n     * \r\n     * @function printPdfAtServer\r\n     * @memberof MeadCoScriptXPrint\r\n     * @param {string} document full url to the pdf document to be printed\r\n     * @param {object} pdfPrintSettings the settings to use such as rotation, scaling. device settings (printer to use, copies etc) are taken from this static\r\n     * @param {function({string})} fnDone function to call when printing complete (and output returned), arg is null on no error, else error message.\r\n     * @param {function(status,sInformation,data)} fnProgress function to call when job status is updated\r\n     * @param {any} data object to give pass to fnProgress\r\n     * @return {boolean} - true if a print was started (otherwise an error will be thrown)\r\n     * @private\r\n     */\r\n    function printPdfAtServer(document, pdfPrintSettings, fnDone, fnProgress, data) {\r\n\r\n        if (!document || (typeof document === \"string\" && document.length === 0)) {\r\n            MeadCo.ScriptX.Print.reportError(\"The document to print must be given.\");\r\n            if (typeof fnDone === \"function\") {\r\n                fnDone(\"Request to print no content\");\r\n            }\r\n            return false;\r\n        }\r\n\r\n        // if previous call was over (default) 10 seconds ago, reset\r\n        const t = Date.now();\r\n        if ((t - previousPrintCallWasAt) > jobGapResetTimeout) {\r\n            timeoutToJobStart = 0;\r\n        }\r\n        previousPrintCallWasAt = t;\r\n        setTimeout(funcPrintPdfAtServer(document, pdfPrintSettings, fnDone, fnProgress, data), timeoutToJobStart);\r\n        timeoutToJobStart += timeoutSpacingMSecs;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n      * Post a request to the server api/v1/printDirect to print a string directly to the current printer. The print is synchronous at the server\r\n      * and is completed (sent to the printer) when the api returns.\r\n      * \r\n      * @function printDirectAtServer\r\n      * @memberof MeadCoScriptXPrint\r\n \r\n      * @param {ContentType} contentType enum type of content given (string or url)\r\n      * @param {string} content the content - a url, or string containing e.g. zpl.\r\n      * @param {function({string})} fnDone function to call when printing complete, arg is null on no error, else error message\r\n      * @return {boolean} - true if a print was started (otherwise an error will be thrown)\r\n      * @private\r\n      */\r\n    function printDirectAtServer(contentType, content, fnDone) {\r\n        MeadCo.log(\"started MeadCo.ScriptX.Print.print.printDirectAtServer() Type: \" + contentType + \", printerName: \" + printerName);\r\n        if (contentType === enumContentType.URL) {\r\n            MeadCo.log(\".. request print url: \" + content);\r\n        }\r\n        else {\r\n            if (contentType !== enumContentType.STRING) {\r\n                MeadCo.ScriptX.Print.reportError(\"Bad content type for direct printing\");\r\n                if (typeof fnDone === \"function\") {\r\n                    fnDone(\"Bad content type for direct printing\");\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n\r\n        if (!content || (typeof content === \"string\" && content.length === 0)) {\r\n            MeadCo.ScriptX.Print.reportError(\"Request to print no content - access denied?\");\r\n            if (typeof fnDone === \"function\") {\r\n                fnDone(\"Request to print no content\");\r\n            }\r\n            return false;\r\n        }\r\n\r\n        if (printerName === \"\") {\r\n            MeadCo.ScriptX.Print.reportError(\"Request to print but no current printer defined.\");\r\n            if (typeof fnDone === \"function\") {\r\n                fnDone(\"Request to print but no current printer defined.\");\r\n            }\r\n            return false;\r\n        }\r\n\r\n        const requestData = {\r\n            ContentType: contentType,\r\n            Content: content,\r\n            PrinterName: printerName,\r\n            Settings: {\r\n                jobTitle: \"Direct print\" // not required by the server .. used by printAtServer()\r\n            },\r\n            Device: deviceSettings[printerName] // not required by the server .. used by printAtServer()\r\n        };\r\n\r\n        return printAtServer(directApiLocation, requestData,\r\n            {\r\n                fail: function (err) {\r\n                    MeadCo.ScriptX.Print.reportError(err);\r\n                    if (typeof fnDone === \"function\") {\r\n                        fnDone(\"Server error\");\r\n                    }\r\n                },\r\n\r\n                softError: function (data) {\r\n                    MeadCo.ScriptX.Print.reportError(data.message);\r\n                    MeadCo.log(\"print has soft error\");\r\n                    removeJob(data.jobIdentifier);\r\n                    if (typeof fnDone === \"function\") {\r\n                        MeadCo.log(\"Call fnDone\");\r\n                        fnDone(data.message);\r\n                    }\r\n                },\r\n\r\n                ok: function (data) {\r\n                    MeadCo.log(\"printed ok, no further information\");\r\n                    removeJob(data.jobIdentifier); // for direct, by definition there is no queued response\r\n                    if (typeof fnDone === \"function\") {\r\n                        fnDone(null);\r\n                    }\r\n                }\r\n            });\r\n    }\r\n\r\n    // set the ScriptX.Services server to use and the client license/subscription id\r\n    //\r\n    // Both arguments are optional, leaving the current values in place.\r\n    //\r\n    // All connection etc calls route to here, so here is the place to determine the port\r\n    // number to use.\r\n    //\r\n    function setServer(serverUrl, clientLicenseGuid, resolve, reject) {\r\n        if (typeof serverUrl === \"string\" && serverUrl.length > 0) {\r\n            MeadCo.log(\"Print server requested: \" + serverUrl + \" with license: \" + clientLicenseGuid);\r\n\r\n            licenseGuid = typeof clientLicenseGuid === \"string\" && clientLicenseGuid.length > 0 ? clientLicenseGuid : licenseGuid;\r\n            printerName = \"\";\r\n            deviceSettings = {};\r\n            activePrintQueue = []; // warning, will kill any current monitoring\r\n            bConnected = false;\r\n            availablePrinters = [];\r\n\r\n            if (typeof resolve == \"function\") {\r\n                servicesServer.setUrlAsync(serverUrl, resolve, reject);\r\n            }\r\n            else {\r\n                servicesServer.url = serverUrl;\r\n            }\r\n        }\r\n        else {\r\n            MeadCo.log(\"Print server retained in setServer: \" + servicesServer.url + \" may update with license: {\" + clientLicenseGuid + \"} (if provided)\");\r\n            licenseGuid = typeof clientLicenseGuid === \"string\" && clientLicenseGuid.length > 0 ? clientLicenseGuid : licenseGuid;\r\n        }\r\n    }\r\n\r\n    function connectToServer(serverUrl, clientLicenseGuid) {\r\n        setServer(serverUrl, clientLicenseGuid);\r\n        // note that this will silently fail if no advanced printing license\r\n        getDeviceSettings({ name: \"systemdefault\", async: false });\r\n\r\n        // also (async) cache server description\r\n        getFromServer(\"\", true,\r\n            function (data) {\r\n                cachedServiceDescription = data;\r\n            });\r\n    }\r\n\r\n    function connectToServerAsync(serverUrl, clientLicenseGuid, resolve, reject) {\r\n        setServer(serverUrl, clientLicenseGuid, function (foundUrl) {\r\n            // note that this will silently fail if no advanced printing license\r\n            getDeviceSettings({\r\n                name: \"systemdefault\",\r\n                done: resolve,\r\n                async: true,\r\n                fail: reject\r\n            });\r\n\r\n            // also (async) cache server description\r\n            getFromServer(\"\", true,\r\n                function (data) {\r\n                    cachedServiceDescription = data;\r\n                });\r\n        }, reject);\r\n    }\r\n\r\n    /**\r\n     * Post a request to print\r\n     * \r\n     * @param {string} sApi The server api endpoint (e.g. api/printhtml). The method '/print' will be added. \r\n     * @param {object} requestData The data to be posted\r\n     * @param {functionList} responseInterface Callbacks to process responses\r\n     * @returns {bool} true if request sent\r\n     */\r\n    function printAtServer(sApi, requestData, responseInterface) {\r\n\r\n        const fakeJob = {\r\n            jobIdentifier: Date.now(),\r\n            printerName: requestData.Device.printerName,\r\n            jobName: jobNameSentWaitingResponse\r\n        };\r\n\r\n        MeadCo.log(\"printAtServer using: \" + sApi);\r\n\r\n        queueJob(fakeJob); // essentially a lock on the queue to stop it looking empty while we await the result\r\n\r\n        return callService(sApi + \"/print\", \"POST\", requestData, true, true, (data) => {\r\n            MeadCo.log(\"Success response: \" + data.status);\r\n            data.printerName = requestData.Device.printerName;\r\n            data.jobName = typeof requestData.Settings.jobTitle === \"string\" && requestData.Settings.jobTitle.length > 0 ? requestData.Settings.jobTitle : \"server job\";\r\n            queueJob(data);\r\n            removeJob(fakeJob.jobIdentifier);\r\n            switch (data.status) {\r\n                case enumResponseStatus.QUEUEDTOFILE:\r\n                    responseInterface.queuedToFile(data);\r\n                    break;\r\n\r\n                case enumResponseStatus.QUEUEDTODEVICE:\r\n                    responseInterface.queuedToDevice(data);\r\n                    break;\r\n\r\n                case enumResponseStatus.SOFTERROR:\r\n                case enumResponseStatus.UNKNOWN:\r\n                    responseInterface.softError(data);\r\n                    break;\r\n\r\n                case enumResponseStatus.OK:\r\n                    responseInterface.ok(data);\r\n                    break;\r\n            }\r\n        },\r\n            (errMsg) => {\r\n                removeJob(fakeJob.jobIdentifier);\r\n                if (typeof responseInterface.fail === \"function\") {\r\n                    responseInterface.fail(errMsg);\r\n                }\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Call an API on the server with GET\r\n     * \r\n     * @function getFromServer\r\n     * @memberof MeadCoScriptXPrint\r\n     * @param {string} sApi the api to call on the connected server\r\n     * @param {bool} async true for asynchronous call, false for synchronous \r\n     * @param {function} onSuccess function to call on success\r\n     * @param {function(errorText)} onFail function to call on failure\r\n     * @private\r\n     */\r\n    function getFromServer(sApi, async, onSuccess, onFail) {\r\n        return callService(sApi, \"GET\", null, true, async, onSuccess, onFail);\r\n    }\r\n\r\n    function callService(sApi, httpMethod, oApiData, bLicensed, bAsync, resolve, reject) {\r\n        return servicesServer.call(sApi, httpMethod, oApiData, bLicensed, bAsync, resolve, reject);\r\n    }\r\n\r\n    function processMonitorResponse(requestData, data, intervalId, jobId, timeOut, functionComplete) {\r\n        MeadCo.log(\"processMonitorResponse::jobStatus: \" + data.status);\r\n        switch (data.status) {\r\n            case enumPrintStatus.COMPLETED:\r\n                MeadCo.log(\"clear interval: \" + intervalId);\r\n                window.clearInterval(intervalId);\r\n                removeJob(jobId);\r\n                functionComplete(data);\r\n                break;\r\n\r\n            case enumPrintStatus.NOTSTARTED:\r\n            case enumPrintStatus.DOWNLOADED:\r\n            case enumPrintStatus.DOWNLOADING:\r\n            case enumPrintStatus.PRINTING:\r\n            case enumPrintStatus.QUEUED:\r\n            case enumPrintStatus.STARTING:\r\n            case enumPrintStatus.PAUSED:\r\n            case enumPrintStatus.PRINTPDF:\r\n                progress(requestData, data.status, data.message);\r\n                updateJob(data);\r\n                // keep going\r\n                if (timeOut > 0 && (++counter * interval) > timeOut) {\r\n                    window.clearInterval(intervalId);\r\n                    MeadCo.ScriptX.Print.reportError(\"unknown failure while printing.\");\r\n                }\r\n                break;\r\n\r\n            case enumPrintStatus.ERROR:\r\n            case enumPrintStatus.ABANDONED:\r\n                MeadCo.log(\"error status in monitorJob so clear interval: \" + intervalId);\r\n                progress(requestData, data.status, data.message);\r\n                removeJob(jobId);\r\n                window.clearInterval(intervalId);\r\n                MeadCo.ScriptX.Print.reportError(\"The print failed with the error: \" + data.message);\r\n                functionComplete(null);\r\n                break;\r\n\r\n            default:\r\n                progress(requestData, data.status, data.message);\r\n                MeadCo.log(\"unknown status in monitorJob so clear interval: \" + intervalId);\r\n                removeJob(jobId);\r\n                window.clearInterval(intervalId);\r\n                functionComplete(null);\r\n                break;\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * Monitor a job that has been known to start  on the server. Get job status from the server and record in the job queue \r\n     * and process status appropriately. Progress callbacks will occur.\r\n     * \r\n     * @function monitorJob\r\n     * @memberof MeadCoScriptXPrint\r\n     * @param {string} serverAndApi The server api endpoint (e.g. api/printhtml). The method '/status/' will be added.\r\n     * @param {string} requestData The original data sent with the print request\r\n     * @param {string} jobId The id return from the server for the job (to be monitored)\r\n     * @param {number} timeOut Time give the job to complete or assume has got stuck, -1 means no timeout.\r\n     * @param {function({object})} functionComplete function to call when job is complete. Argument is null on error, the data returned from the status call on success,.\r\n     * @private\r\n     */\r\n    function monitorJob(sApi, requestData, jobId, timeOut, functionComplete) {\r\n        MeadCo.log(\"monitorJob: \" + jobId);\r\n        const interval = 1000;\r\n        let bWaiting = false;\r\n        let intervalId = window.setInterval(function () {\r\n            if (!bWaiting) {\r\n                bWaiting = true; // ensure if the interval fires again before the last call response has been dealt with, wait till next interval until it has been dealt with\r\n                getFromServer(sApi + \"/status/\" + jobId, true, (data) => {\r\n                    processMonitorResponse(requestData, data, intervalId, jobId, timeOut, functionComplete);\r\n                    bWaiting = false;\r\n                },\r\n                    (errorThrown) => {\r\n                        MeadCo.log(\"error: \" + errorThrown + \" in monitorJob so clear interval: \" + intervalId);\r\n                        progress(requestData, enumPrintStatus.ERROR, errorThrown);\r\n                        removeJob(jobId);\r\n                        window.clearInterval(intervalId);\r\n                        functionComplete(null);\r\n                        bWaiting = false;\r\n                    });\r\n            } else {\r\n                MeadCo.log(\"** info : still waiting for last status request to complete\");\r\n            }\r\n        }, interval);\r\n\r\n        MeadCo.log(\"intervalId: \" + intervalId);\r\n    }\r\n\r\n    function addOrUpdateDeviceSettings(data) {\r\n        if (typeof data.printerName === \"string\") {\r\n            if (data.isDefault) {\r\n                for (var i = 0; i < deviceSettings.length; i++) {\r\n                    deviceSettings[i].isDefault = false;\r\n                }\r\n            }\r\n\r\n            deviceSettings[data.printerName] = data;\r\n            if (data.isDefault && printerName.length === 0) {\r\n                printerName = data.printerName;\r\n            }\r\n        }\r\n    }\r\n\r\n    function getDeviceSettings(oRequest) {\r\n        oRequest.name = oRequest.name.replace(/\\\\/g, \"||\");\r\n        MeadCo.log(\"Request get device info: \" + oRequest.name);\r\n\r\n        getFromServer(htmlApiLocation + \"/deviceinfo/\" + encodeURIComponent(oRequest.name) + \"/0\", oRequest.async,\r\n            function (data) {\r\n                bConnected = true;\r\n                addOrUpdateDeviceSettings(data);\r\n                if (typeof oRequest.done === \"function\") {\r\n                    oRequest.done(data);\r\n                }\r\n            },\r\n            function (errTxt) {\r\n                if (oRequest.name === \"systemdefault\") {\r\n                    MeadCo.warn(\"request for systemdefault printer failed - please update to ScriptX.Services 2.11.1\");\r\n                    oRequest.name = \"default\";\r\n                    getDeviceSettings(oRequest);\r\n                }\r\n                else {\r\n                    MeadCo.log(\"failed to getdevice: \" + errTxt);\r\n\r\n                    if (typeof oRequest.fail === \"function\") {\r\n                        oRequest.fail(errTxt);\r\n                    }\r\n                }\r\n            }\r\n        );\r\n\r\n    }\r\n\r\n    function getDeviceSettingsFor(sPrinterName) {\r\n        if (typeof sPrinterName === \"string\" && sPrinterName !== \"\") {\r\n            if (typeof deviceSettings[sPrinterName] === \"undefined\") {\r\n                getDeviceSettings({\r\n                    name: sPrinterName,\r\n                    async: false,\r\n                    done: function (printerData) {\r\n                        if (sPrinterName.toLowerCase() === \"systemdefault\") {\r\n                            sPrinterName = printerData.printerName;\r\n                        }\r\n                    },\r\n                    fail: function (eTxt) { MeadCo.ScriptX.Print.reportError(eTxt); }\r\n                });\r\n            }\r\n\r\n            return deviceSettings[sPrinterName];\r\n        }\r\n\r\n        return {};\r\n    }\r\n\r\n    function getDeviceSettingsForAsync(sPrinterName, resolve, reject) {\r\n        if (typeof sPrinterName === \"string\" && sPrinterName !== \"\") {\r\n            if (typeof deviceSettings[sPrinterName] === \"undefined\") {\r\n                getDeviceSettings({\r\n                    name: sPrinterName,\r\n                    async: true,\r\n                    done: function (printerData) {\r\n                        if (sPrinterName.toLowerCase() === \"systemdefault\") {\r\n                            sPrinterName = printerData.printerName;\r\n                        }\r\n                        resolve(deviceSettings[sPrinterName])\r\n                    },\r\n                    fail: function (eTxt) { reject(eTxt); }\r\n                });\r\n            }\r\n            else\r\n                resolve(deviceSettings[sPrinterName]);\r\n        }\r\n        else\r\n            reject(\"a printer name is required\");\r\n    }\r\n\r\n    function managePrinterConnection(sMethod, sShareName) {\r\n        console.warn(\"Synchronous calls to add/remove printer connections are not recommeneded as this will lock the browser UI. Consider using the asynchronous versions when working with in ScriptX.Services\");\r\n        var sd = MeadCo.ScriptX.Print.serviceDescription();\r\n        if (sd.serviceClass == enumServiceClass.WINDOWSPC && sd.serviceVersion.major >= 2 && sd.serviceVersion.minor >= 19) {\r\n            callService(printerApiLocation + \"/Connection/\" + encodeURIComponent(sShareName), sMethod, null, true, false);\r\n        }\r\n        else {\r\n            MeadCo.error(\"ScriptX.Services for Windows PC 2.19 or later is required for add/remove PrinterConnection()\");\r\n        }\r\n    }\r\n\r\n    function managePrinterConnectionAsync(sMethod, sShareName, onSuccess, onFail) {\r\n        MeadCo.ScriptX.Print.serviceDescriptionAsync(\r\n            function (sd) {\r\n                if (sd.serviceClass == enumServiceClass.WINDOWSPC && sd.serviceVersion.major >= 2 && sd.serviceVersion.minor >= 19) {\r\n                    callService(printerApiLocation + \"/Connection/\" + encodeURIComponent(sShareName), sMethod, null, true, true, onSuccess, onFail);\r\n                }\r\n                else {\r\n                    MeadCo.error(\"ScriptX.Services for Windows PC 2.19 or later is required for add/remove PrinterConnection()\");\r\n                    onFail(\"add/remove PrinterConnection is not supported\");\r\n                }\r\n            },\r\n            onFail\r\n        );\r\n    }\r\n\r\n    // look for auto-processing attributes that define the server to connect to and the\r\n    // license/subscription to be used. \r\n    //\r\n    // This implementation is called by the public api useAttributes (called by factory and secmgr implementations)\r\n    //\r\n    function processAttributes() {\r\n        MeadCo.log(\"MeadCo.ScriptX.Print ... looking for auto connect, already found?: \" + bDoneAuto);\r\n\r\n        if (!bDoneAuto) {\r\n            // protected API\r\n            var printHtml = MeadCo.ScriptX.Print.HTML;\r\n            var printApi = MeadCo.ScriptX.Print;\r\n            var licenseApi = MeadCo.ScriptX.Print.Licensing;\r\n\r\n            const cloudOrOnPremise = document.querySelector('[data-meadco-subscription]');\r\n            if (cloudOrOnPremise) {\r\n                const data = cloudOrOnPremise.dataset;\r\n                MeadCo.log(\"Auto connect susbcription to: \" +\r\n                    data.meadcoServer + \", or \" + data.meadcoPrinthtmlserver +\r\n                    \", with subscription: \" +\r\n                    data.meadcoSubscription +\r\n                    \", sync: \" +\r\n                    data.meadcoSyncinit +\r\n                    \", usefetch: \" +\r\n                    data.meadcoUsefetch\r\n                );\r\n                const syncInit = (\"\" + data.meadcoSyncinit)\r\n                    .toLowerCase() !==\r\n                    \"false\"; // defaults to true if not specified\r\n\r\n                if (!syncInit) {\r\n                    const sFetchDefined = (\"\" + data.meadcoUsefetch);\r\n                    if (sFetchDefined.length > 0)\r\n                        MeadCo.fetchEnabled = sFetchDefined.toLowerCase() === \"true\";\r\n                }\r\n                else\r\n                    MeadCo.fetchEnabled = false;\r\n\r\n                const server = data.meadcoServer;\r\n                if (typeof server === \"undefined\") {\r\n                    server = data.meadcoPrinthtmlserver;\r\n                }\r\n\r\n                if (typeof server === \"undefined\") {\r\n                    MeadCo.error(\"No server specified\");\r\n                } else {\r\n                    // in case there will be a request for the subnscription info ..\r\n                    if (typeof licenseApi !== \"undefined\")\r\n                        licenseApi.connect(server, data.meadcoSubscription);\r\n\r\n                    if (!syncInit) {\r\n                        MeadCo.log(\"Async connectlite...\");\r\n                        printApi.connectLite(server, data.meadcoSubscription);\r\n                    } else {\r\n                        MeadCo\r\n                            .warn(\"Synchronous connection is deprecated.jQuery is required for synchronous behaviour.To update to asynchronous behaviour please use data - meadco - syncinit='false'. Note that this may require additional code changes. Please see: https://www.meadroid.com/Developers/KnowledgeBank/HowToGuides/ScriptXServices/ThenToNow/Stage6\");\r\n                        printHtml.connect(server, data.meadcoSubscription);\r\n                    }\r\n                    bDoneAuto = true;\r\n                }\r\n            }\r\n            else {\r\n                const wPC = document.querySelector('[data-meadco-license]');\r\n\r\n                if (wPC) {\r\n                    if (typeof printApi === \"undefined\" || typeof printHtml === \"undefined\" || typeof licenseApi === \"undefined\") {\r\n                        MeadCo.log(\"Not auto-connecting client license as print or printHtml or license API not present. Should be present on next attempt.\");\r\n                    } else {\r\n                        const data = wPC.dataset;\r\n                        MeadCo.log(\"Auto connect client license to: \" +\r\n                            data.meadcoServer +\r\n                            \", with license: \" +\r\n                            data.meadcoLicense +\r\n                            \", path: \" +\r\n                            data.meadcoLicensePath +\r\n                            \", revision: \" +\r\n                            data.meadcoLicenseRevision +\r\n                            \", sync: \" +\r\n                            data.meadcoSyncinit +\r\n                            \", useFetch: \" +\r\n                            data.meadcoUsefetch +\r\n                            \", orchestrator: \" +\r\n                            data.meadcoOrchestrator +\r\n                            \", orchestratorKey: \" +\r\n                            data.meadcoOrchestratorKey +\r\n                            \", trustVerifiedConnection: \" +\r\n                            data.meadcoTrustVerifiedConnection);\r\n\r\n                        const syncInit = (\"\" + data.meadcoSyncinit)\r\n                            .toLowerCase() !==\r\n                            \"false\"; // defaults to true if not specified\r\n                        const reportError = (\"\" + data.meadcoReporterror)\r\n                            .toLowerCase() !==\r\n                            \"false\"; // defaults to true if not specified\r\n                        const applyLicense = (\"\" + data.meadcoApplyLicense)\r\n                            .toLowerCase() ==\r\n                            \"true\"; // only applies to async, defaults to false if not specified; if MeadCo ScriptXJS is in use, it will do the apply. Set true if it is not being used.\r\n\r\n                        const server = data.meadcoServer;\r\n\r\n                        servicesServer.orchestratorPort = data.meadcoOrchestrator;\r\n                        servicesServer.orchestratorKey = data.meadcoOrchestratorKey;\r\n                        servicesServer.trustVerifiedConnection = (\"\" + data.meadcoTrustVerifiedConnection)\r\n                            .toLowerCase() !==\r\n                            \"false\"; // defaults to true if not specified\r\n\r\n\r\n                        if (!syncInit) {\r\n                            MeadCo.log(\"Async connectlite...\");\r\n                            const sFetchDefined = (\"\" + data.meadcoUsefetch);\r\n                            if (sFetchDefined.length > 0)\r\n                                MeadCo.fetchEnabled = sFetchDefined.toLowerCase() === \"true\";\r\n\r\n                            licenseApi.connectLite(server, data.meadcoLicense,\r\n                                data.meadcoLicenseRevision,\r\n                                data.meadcoLicensePath);\r\n                            printApi.connectLite(server, data.meadcoLicense);\r\n\r\n                            if (applyLicense) {\r\n                                licenseApi.applyAsync(data.meadcoLicense, data.meadcoLicenseRevision, data.meadcoLicensePath,\r\n                                    () => {\r\n                                        MeadCo.log(\"NOTE: license has been applied successfully from async processing of attribute with values\");\r\n                                    },\r\n                                    (e) => {\r\n                                        MeadCo.error(`Failed to apply the license: ${e}, error is: ${licenseApi.errorMessage}`);\r\n                                        if (reportError) {\r\n                                            MeadCo.ScriptX.Print.reportError(licenseApi.errorMessage);\r\n                                        }\r\n                                    }\r\n                                );\r\n                            }\r\n                        } else {\r\n                            MeadCo\r\n                                .warn(\"Synchronous connection is deprecated. jQuery is required for synchronous behaviour. To update to asynchronous behaviour please use data-meadco-syncinit='false'. Note that this may require additional code changes. Please see: https://www.meadroid.com/Developers/KnowledgeBank/HowToGuides/ScriptXServices/ThenToNow/Stage6\");\r\n                            MeadCo.fetchEnabled = false;\r\n                            licenseApi.connect(server, data.meadcoLicense);\r\n                            if (typeof data.meadcoLicensePath !== \"undefined\" &&\r\n                                typeof data\r\n                                    .meadcoLicenseRevision !==\r\n                                \"undefined\") { // if these are not defined then you must use meadco-secmgr.js\r\n                                licenseApi.apply(data.meadcoLicense,\r\n                                    data.meadcoLicenseRevision,\r\n                                    data.meadcoLicensePath);\r\n\r\n                                if (licenseApi.result != 0 && reportError) {\r\n                                    MeadCo.ScriptX.Print.reportError(licenseApi.errorMessage);\r\n                                }\r\n                            }\r\n                            printHtml.connect(server, data.meadcoLicense);\r\n                        }\r\n                        bDoneAuto = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    MeadCo.log(\"MeadCo.ScriptX.Print \" + version + \" loaded.\");\r\n\r\n    //////////////////////////////////////////////////\r\n    // public API\r\n    return {\r\n        /*\r\n         * Enum for type of content being posted to printHtml API\r\n         * @readonly\r\n         * @memberof MeadCoScriptXPrint\r\n         * @enum { ContentType }\r\n         * \r\n         * URL: 1 a get request will be issued to the url and the returned content will be printed\r\n         * HTML: 2 the passed string is assumed to be a complete html document .. <html>..</html>\r\n         * INNERTHTML: 4 the passed string is a complete html document but missing the html tags\r\n         */\r\n        ContentType: enumContentType,\r\n\r\n        /* \r\n         * Enum for status code returned to print progress callbacks\r\n         * @readonly\r\n         * @memberof MeadCoScriptXPrint\r\n         * @enum PrintStatus { number }\r\n         */\r\n        PrintStatus: enumPrintStatus,\r\n\r\n        ErrorAction: enumErrorAction,\r\n\r\n        CollateOptions: enumCollateOptions,\r\n        DuplexOptions: enumDuplexOptions,\r\n        MeasurementUnits: enumMeasurementUnits,\r\n        ServiceClasses: enumServiceClass,\r\n\r\n        /**\r\n         * Get/set the action to take when an error occurs\r\n         * \r\n         * @memberof MeadCoScriptXPrint\r\n         * @property {ErrorAction} onErrorAction - the action\r\n         */\r\n        get onErrorAction() {\r\n            return errorAction;\r\n        },\r\n\r\n        set onErrorAction(action) {\r\n            errorAction = action;\r\n        },\r\n\r\n        /**\r\n         * Get/set the PORT number of the ScriptX.Services Orchestrator ('reverse proxy') to use. By definition orchestrator only listens\r\n         * on the local-loopback address.\r\n         * \r\n         * This is only useful in uses cases of multiple users are simultaneously logged in to an instance of Windows.\r\n         * In these cases, the port number used by ScriptX.Services for Windows PC will be unqiue for each user.\r\n         * \r\n         * The port number for the orchestrator is the same for each user as the orchestrator server is only active while the\r\n         * user is active. \r\n         */\r\n        get orchestrator() {\r\n            return servicesServer.orchestratorPort;\r\n        },\r\n\r\n        set orchestrator(nPort) {\r\n            servicesServer.orchestratorPort = \"\" + nPort;\r\n        },\r\n\r\n        /**\r\n         * Get/set the key to use with Orchestrator Service for ScriptX.Services for Windows PC to recover the port registered for use with the same key.\r\n         * Typically, this will be the user name but can be any value.\r\n         * */\r\n        get orchestratorKey() {\r\n            return servicesServer.orchestratorKey;\r\n        },\r\n\r\n        set orchestratorKey(sKey) {\r\n            servicesServer.orchestratorKey = sKey;\r\n        },\r\n\r\n        /**\r\n         * Get/set the cookie to be used to authorise access to protected content\r\n         * \r\n         * @memberof MeadCoScriptXPrint\r\n         * @property {string} authorisationCookie - the cookie in the form name=value\r\n         */\r\n        get authorisationCookie() {\r\n            return AccessControl.cookie;\r\n        },\r\n\r\n        set authorisationCookie(cookie) {\r\n            AccessControl.cookie = cookie;\r\n        },\r\n\r\n        /** \r\n         *  Get/set the currently active printer\r\n         *  @memberof MeadCoScriptXPrint\r\n         *  @property {string} printerName - The name of the current printer in use.\r\n         */\r\n        get printerName() {\r\n            return printerName;\r\n        },\r\n\r\n        set printerName(deviceRequest) {\r\n            if (!(deviceRequest === printerName || deviceRequest.name === printerName)) {\r\n                if (typeof deviceRequest === \"string\") {\r\n\r\n                    if (typeof deviceSettings[deviceRequest] === \"undefined\") {\r\n                        // not already cached, get (synchronously) if synchronous is available\r\n                        // if synchronous is not available then getDeviceSettingsAsync() must be called \r\n                        // We have no choice but to fail this call. \r\n                        if (outerScope.jQuery && !MeadCo.fetchEnabled) {\r\n                            getDeviceSettings({\r\n                                name: deviceRequest,\r\n                                done: function (data) {\r\n                                    printerName = data.printerName;\r\n                                },\r\n                                async: false,\r\n                                fail: function (eTxt) {\r\n                                    MeadCo.ScriptX.Print.reportError(eTxt);\r\n                                }\r\n                            });\r\n                        }\r\n                        else {\r\n                            MeadCo.error(\"Asynchronous processing of set printerName required, synchronous calls to obtain device details will fail until this completes.\")\r\n                            getDeviceSettingsForAsync(deviceRequest,\r\n                                (data) => { printerName = data.printerName; },\r\n                                (eTxt) => { MeadCo.ScriptX.Print.reportError(eTxt); }\r\n                            );\r\n\r\n                            // awful, solely to not break backwards compatibility\r\n                            if (servicesServer.serviceUrl === \"\")\r\n                                MeadCo.ScriptX.Print.reportError(\"MeadCo.ScriptX.Print : server connection is not defined.\");\r\n                            else\r\n                                MeadCo.ScriptX.Print.reportError(\"Not Found\");\r\n                        }\r\n                    }\r\n                    else {\r\n                        printerName = deviceRequest;\r\n                    }\r\n\r\n                } else {\r\n                    getDeviceSettings(deviceRequest);\r\n                }\r\n            }\r\n        },\r\n\r\n        setSystemDefaultPrinterAsync: function (sName, resolve, reject) {\r\n            if (typeof deviceSettings[\"systemdefault\"] !== \"undefined\" && deviceSettings[\"systemdefault\"] == sName) {\r\n                MeadCo.log(\"setSystemDefaultPrinterAsync() does NOT need to do anything\");\r\n                resolve();\r\n                return;\r\n            }\r\n\r\n            sName = \"system::\" + sName;\r\n            sName = sName.replace(/\\\\/g, \"||\");\r\n            MeadCo.log(\"Request systemDefaultPrinterAsync: \" + sName);\r\n            callService(htmlApiLocation + \"/CurrentPrinter/\" + encodeURIComponent(sName), \"PUT\", null, true, true, resolve, reject);\r\n        },\r\n\r\n        /**\r\n         * Get the version of this module as a string major.minor.hotfix.build\r\n         * @property {string} version\r\n         * @memberof MeadCoScriptXPrint\r\n         */\r\n        get version() {\r\n            return version;\r\n        },\r\n\r\n        /**\r\n         * Get the full url of the ScriptX.Services server connected to \r\n         * \r\n         * @property {string} serviceUrl\r\n         * @memberof MeadCoScriptXPrint         \r\n         */\r\n        get serviceUrl() {\r\n            return servicesServer.url;\r\n        },\r\n\r\n        /**\r\n         * Get the version of the service connected to.\r\n         * \r\n         * @function serviceVersion\r\n         * @memberof MeadCoScriptXPrint\r\n         * @returns {VersionObject} the version\r\n         */\r\n        serviceVersion: function () {\r\n            return this.serviceDescription().serviceVersion;\r\n        },\r\n\r\n        /**\r\n         * Get the version of the service connected to.\r\n         * \r\n         * @function serviceVersionAsync\r\n         * @memberof MeadCoScriptXPrint\r\n         * @param {function({VersionObject})} resolve function to call on success\r\n         * @param {function({errorText})} reject function to call on failure\r\n         */\r\n        serviceVersionAsync: function (resolve, reject) {\r\n            this.serviceDescriptionAsync(function (sd) { resolve(sd.serviceVersion); }, reject);\r\n        },\r\n\r\n        /**\r\n         * Get/set the cached device settings (papersize etc) for the currently active printer\r\n         * @memberof MeadCoScriptXPrint\r\n         * @property {DeviceSettingsObject} deviceSettings (see API /api/vi/printhtml/deviceInfo/ )\r\n         */\r\n        get deviceSettings() {\r\n            return printerName !== \"\" ? deviceSettings[printerName] : {};\r\n        },\r\n\r\n        set deviceSettings(settings) {\r\n            addOrUpdateDeviceSettings(settings);\r\n        },\r\n\r\n        /**\r\n         * Get the device settings (papersize etc) for the named printer. This call is synchronous \r\n         * and not recommended. \r\n         * \r\n         * @function deviceSettingsFor\r\n         * @memberof MeadCoScriptXPrint\r\n         * @param {string} sPrinterName the name of the printer device to return the settings for \r\n         * @returns {DeviceSettingsObject} object with properties\r\n         */\r\n        deviceSettingsFor: function (sPrinterName) {\r\n            return getDeviceSettingsFor(sPrinterName);\r\n        },\r\n\r\n        /**\r\n         * Get the device settings (papersize etc) for the named printer. If not already downloaded\r\n         * this function is asynchronous. \r\n         * \r\n         * @function deviceSettingsForAsync\r\n         * @memberof MeadCoScriptXPrint\r\n         * @param {string} sPrinterName the name of the printer device to return the settings for \r\n         * @param {function({DeviceSettingsObject})} resolve function to call on success\r\n         * @param {function({errorText})} reject function to call on failure\r\n         */\r\n        deviceSettingsForAsync: function (sPrinterName, resolve, reject) {\r\n            getDeviceSettingsForAsync(sPrinterName, resolve, reject);\r\n        },\r\n\r\n        /**\r\n         * search for processing attibutes for connection and subscription/license and process them. The attibutes can be on any element. This function is called automatically by factory emulation and licensing emulation scripts so does not usually \r\n         * need to be called by document script.\r\n         * \r\n         * Please note synchronous AJAX calls are deprecated in all browsers but may be useful to \"quick start\" use of older code. It is recommended that code is moved\r\n         * to using asynchronous calls as soon as practical. The MeadCoScriptXJS library can assist with this as it delivers promise rather than callback based code.\r\n         * \r\n         * @function useAttributes\r\n         * @memberof MeadCoScriptXPrint\r\n         * @example\r\n         * \r\n         * <!-- an example connection to an On Premise server for ScriptX.Services -->\r\n         * <script src=\"lib/meadco-scriptxservicesprintUI.min.js\" \r\n         *      data-meadco-server=\"https://app.corpservices/\" \r\n         *      data-meadco-subscription=\"\" data-meadco-syncinit=\"false\">\r\n         * </script>;\r\n         * \r\n         * <!-- an example connection to ScriptX.Services for Windows PC -->\r\n         * <script src=\"lib/meadco-scriptxservicesUI.min.js\"\r\n         *      data-meadco-server=\"http://127.0.0.1:41191\" \r\n         *      data-meadco-license=\"{6BC6808B-D645-40B6-AE80-E9D0825797EF}\" \r\n         *      data-meadco-syncinit=\"false\" \r\n         *      data-meadco-license-path=\"warehouse\"\r\n         *      data-meadco-license-revision=\"3\">\r\n         * </script>\r\n         * \r\n         * data-meadco-server value is the root url, api/v1/printhtml, api/v1/licensing will be added by the library\r\n         * data-meadco-syncinit default is true for synchronous calls to the server, value 'false' to use asynchronous calls to the server\r\n         * \r\n         * data-meadco-subscription present => cloud/on premise service, value is the subscription GUID\r\n         * data-meadco-license present => for Windows PC service, value is the license GUID\r\n         *\r\n         * If data-meadco-license is present then the following additional attributes can be used:\r\n         * \r\n         * data-meadco-license-revision, value is the revision number of the license\r\n         * data-meadco-license-path, value is the path to the license file (sxlic.mlf). A value of \"warehouse\" will cause the license to be downloaded from MeadCo's License Warehouse\r\n         * data-meadco-reporterror, default is \"true\", value \"false\" suppresses error messages during the initial connection to the service (only)\r\n         * \r\n         */\r\n        useAttributes: function () {\r\n            processAttributes();\r\n        },\r\n\r\n        /**\r\n         * Specify the server to use and the subscription/license id. \r\n         * \r\n         * Attempt to connect to the defined ScriptX.Services server and obtain\r\n         * the device settings for the default printer. This call is synchronous \r\n         * and therefore not recommended. Use connectAsync()\r\n         * \r\n         * @function connect\r\n         * @memberof MeadCoScriptXPrint\r\n         * @param {string} serverUrl the 'root' url to the server (the api path will be added by the library)\r\n         * @param {string} licenseGuid the license/subscription identifier\r\n         */\r\n        connect: function (serverUrl, licenseGuid) {\r\n            connectToServer(serverUrl, licenseGuid);\r\n        },\r\n\r\n        /**\r\n         * Specify the server and the subscription/license id to use on AJAX calls. No call is made in this function\r\n         *\r\n         * @function connectLite\r\n         * @memberof MeadCoScriptXPrint\r\n         * @param {string} serverUrl the 'root' url to the server (the api path will be added by the library)\r\n         * @param {string} licenseGuid the license/subscription identifier\r\n         */\r\n        connectLite: function (serverUrl, licenseGuid) {\r\n            // factory polyfill initialisation will result in a call with empty string\r\n            // values for both arguments via printHtml.connectAsync() as it doesnt \r\n            // know the values so we assume a connectLite has already been called\r\n            // and dont overwrite with empty values.\r\n            setServer(serverUrl, licenseGuid);\r\n        },\r\n\r\n        /**\r\n         * Specify the server to use and the subscription/license id.\r\n         *\r\n         * Attempt to connect to the defined ScriptX.Services server and obtain\r\n         * the device settings for the default printer. \r\n         *\r\n         * @function connectAsync\r\n         * @memberof MeadCoScriptXPrint\r\n         * @param {string} serverUrl the 'root' url to the server (the api path will be added by the library)\r\n         * @param {string} licenseGuid the license/subscription identifier\r\n         * @param {function({dataObject})} resolve function to call on success, dataObject contains the device settings for the default device.\r\n         * @param {function} reject function to call on failure\r\n         */\r\n        connectAsync: function (serverUrl, licenseGuid, resolve, reject) {\r\n            connectToServerAsync(serverUrl, licenseGuid, resolve, reject);\r\n        },\r\n\r\n        /**\r\n         * Test if there is a MeadCo PrintHtml API server at the url\r\n         * \r\n         * @function connectTestAsync\r\n         * @memberof MeadCoScriptXPrint\r\n         * @param {string} serverUrl the 'root' url to the server (the api path will be added by the library)\r\n         * @param {function({foundServerUrl})} resolve function to call on success\r\n         * @param {function({errorText})} reject function to call on failure\r\n         */\r\n        connectTestAsync: function (serverUrl, resolve, reject) {\r\n            servicesServer.verifyUrl(serverUrl, true, resolve, reject);\r\n        },\r\n\r\n        /**\r\n         * Obtain the description of the service provided by the server\r\n         *\r\n         * @function serviceDescription\r\n         * @memberof MeadCoScriptXPrint\r\n         * @returns {ServiceDescriptionObject} serviceDescription\r\n         */\r\n        serviceDescription: function () {\r\n\r\n            if (!cachedServiceDescription) {\r\n                getFromServer(\"\", false,\r\n                    function (data) { cachedServiceDescription = data; },\r\n                    function (e) {\r\n                        MeadCo.ScriptX.Print.reportError(e.message);\r\n                    });\r\n            }\r\n            return cachedServiceDescription;\r\n        },\r\n\r\n        /**\r\n         * Obtain the description of the service provided by the server\r\n         *\r\n         * @function serviceDescriptionAsync\r\n         * @memberof MeadCoScriptXPrint\r\n         * @param {function(ServiceDescriptionObject)} resolve function to call on success\r\n         * @param {function(errorText)} reject function to call on failure\r\n         */\r\n        serviceDescriptionAsync: function (resolve, reject) {\r\n\r\n            if (!cachedServiceDescription) {\r\n                getFromServer(\"\", true,\r\n                    function (data) {\r\n                        cachedServiceDescription = data;\r\n                        resolve(data);\r\n                    }, reject);\r\n            }\r\n            else {\r\n                resolve(cachedServiceDescription);\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Cache the given device info and available printers in this static class instance\r\n         * \r\n         * Used by libraries that call api/v1/printHtml/htmlPrintDefaults\r\n         * \r\n         * @function connectDeviceAndPrinters\r\n         * @memberof MeadCoScriptXPrint\r\n         * @param {object} deviceInfo the device name and settings (papersize etc)\r\n         * @param {array} arPrinters the names of the available printers\r\n         */\r\n        connectDeviceAndPrinters: function (deviceInfo, arPrinters) {\r\n            bConnected = true;\r\n            addOrUpdateDeviceSettings(deviceInfo);\r\n            availablePrinters = arPrinters;\r\n        },\r\n\r\n        /**\r\n         * true if the library has succesfully connected to a server and the default device settings obtained.\r\n         * \r\n         * @memberof MeadCoScriptXPrint\r\n         * @property {bool} isConnected true if the library has succesfully connected to a server.\r\n         * @readonly\r\n         */\r\n        get isConnected() {\r\n            return bConnected;\r\n        },\r\n\r\n        /**\r\n         * Get the list of printers availablefrom the server.\r\n         * \r\n         * @property {string[]} availablePrinterNames an array of strings of the names of the available printers\r\n         * @memberof MeadCoScriptXPrint\r\n         * @readonly\r\n         */\r\n        get availablePrinterNames() {\r\n            return availablePrinters;\r\n        },\r\n\r\n        /**\r\n         * Add a printer for the user. The printer driver must already be available. \r\n         * \r\n         * @function addPrinterConnection\r\n         * @memberof MeadCoScriptXPrint\r\n         * @param {any} sShareName - \r\n         */\r\n        addPrinterConnection: function (sShareName) {\r\n            managePrinterConnection(\"PUT\", sShareName);\r\n        },\r\n\r\n        /**\r\n         * Add a printer for the user. The printer driver must already be available. \r\n         * \r\n         * @function removePrinterConnection\r\n         * @memberof MeadCoScriptXPrint\r\n         * @param {any} sShareName - \r\n         */\r\n        removePrinterConnection: function (sShareName) {\r\n            managePrinterConnection(\"DELETE\", sShareName);\r\n        },\r\n\r\n        /**\r\n         * Add a printer for the user. The printer driver must already be available. \r\n         * \r\n         * @function addPrinterConnectionAsync\r\n         * @memberof MeadCoScriptXPrint\r\n         * @param {any} sShareName - \r\n         * @param {any} onSuccess\r\n         * @param {any} onFail\r\n         */\r\n        addPrinterConnectionAsync: function (sShareName, onSuccess, onFail) {\r\n            managePrinterConnectionAsync(\"PUT\", sShareName, onSuccess, onFail);\r\n        },\r\n\r\n        /**\r\n         * Add a printer for the user. The printer driver must already be available. \r\n         * \r\n         * @function removePrinterConnectionAsync\r\n         * @memberof MeadCoScriptXPrint\r\n         * @param {any} sShareName - \r\n         * @param {any} onSuccess\r\n         * @param {any} onFail\r\n         */\r\n        removePrinterConnectionAsync: function (sShareName, onSuccess, onFail) {\r\n            managePrinterConnectionAsync(\"DELETE\", sShareName, onSuccess, onFail);\r\n        },\r\n\r\n        /**\r\n         * Call a /printHtml API on the server with GET\r\n         * \r\n         * @function getFromServer\r\n         * @memberof MeadCoScriptXPrint\r\n         * @param {string} sPrintHtmlApi the api to call on the connected server\r\n         * @param {bool} async true for asynchronous call, false for synchronous \r\n         * @param {function} onSuccess function to call on success\r\n         * @param {function(errorText)} onFail function to call on failure\r\n         */\r\n        getFromServer: function (sPrintHtmlApi, async, onSuccess, onFail) {\r\n            getFromServer(htmlApiLocation + sPrintHtmlApi, async, onSuccess, onFail);\r\n        },\r\n\r\n        /**\r\n         * Post a request to the server to print some html and monitor the print job \r\n         * to completion. If the server prints to file then the file is opened for the user (in a new window)\r\n         * \r\n         * @function printHtml\r\n         * @memberof MeadCoScriptXPrint\r\n\r\n         * @param {ContentType} contentType enum type of content given (html snippet, url)\r\n         * @param {string} content the content - a url, html snippet or complete html\r\n         * @param {object} htmlPrintSettings the html settings to use such as headers and footers, device settings (printer to use, copies etc) are taken from this static \r\n         * @param {function({string})} fnDone function to call when printing complete (and output returned), arg is null on no error, else error message.\r\n         * @param {function(status,sInformation,data)} fnProgress function to call when job status is updated\r\n         * @param {any} data object to give pass to fnProgress\r\n         * @return {boolean} - true if a print was started (otherwise an error will be thrown)\r\n         */\r\n        printHtml: printHtmlAtServer,\r\n\r\n        /**\r\n         * Post a request to the server to generate a preview. When ready the url from which the preview can be downloaded\r\n         * is passed to the fnReady function.\r\n         * \r\n         * @function requestHtmlPreview\r\n         * @memberof MeadCoScriptXPrint\r\n         * \r\n         * @param {ContentType} contentType enum type of content given (html snippet, url)\r\n         * @param {string} content the content - a url, html snippet or complete html\r\n         * @param {object} htmlPrintSettings the html settings to use such as headers and footers, device settings (printer to use, copies etc) are taken from this static\r\n         * @param {function({string})} fnDone function to call when processing is complete arg is null on no error, else error message.\r\n         * @param {function({string})} fnReady function to call when the preview is available to download\r\n         */\r\n        requestHtmlPreview: function (contentType, content, htmlPrintSettings, fnDone, fnReady) {\r\n            var userPrinterName = printerName;\r\n            printerName = magicPrintPreviewPrinter;\r\n\r\n            funcPrintHtmlAtServer(contentType, content, htmlPrintSettings, {}, fnDone, function () { }, fnReady)();\r\n            printerName = userPrinterName;\r\n        },\r\n\r\n        /**\r\n         * Post a request to the server to print some html and monitor the print job \r\n         * to completion. If the server prints to file then the file is opened for the user (in a new window)\r\n         * \r\n         * @function printPdf\r\n         * @memberof MeadCoScriptXPrint\r\n\r\n         * @param {string} document full url to the pdf document to be printed\r\n         * @param {object} pdfPrintSettings the settings to use such as rotation, scaling. device settings (printer to use, copies etc) are taken from this static\r\n         * @param {function({string})} fnDone function to call when printing complete (and output returned), arg is null on no error, else error message.\r\n         * @param {function(status,sInformation,data)} fnProgress function to call when job status is updated\r\n         * @param {any} data object to give pass to fnProgress\r\n         * @return {boolean} - true if a print was started (otherwise an error will be thrown)\r\n         */\r\n        printPdf: printPdfAtServer,\r\n\r\n        /**\r\n         * Post a request to the server to print a string directly to the current printer. The print is synchronous at the server\r\n         * and is completed (sent to the printer) when the api returns.\r\n         *\r\n         * @function printDirect\r\n         * @memberof MeadCoScriptXPrint\r\n         *\r\n         * @param {ContentType} contentType enum type of content given (string or url)\r\n         * @param {string} content the content - a url, or string containing e.g. zpl.\r\n         * @param {function({string})} fnDone function to call when printing complete, arg is null on no error, else error message\r\n         * @return {boolean} - true if a print was started (otherwise an error will be thrown)         *\r\n         */\r\n        printDirect: printDirectAtServer,\r\n\r\n        /**\r\n         * Extract the error text from jQuery AJAX response\r\n         * \r\n         * @function parseAjaxError\r\n         * @memberof MeadCoScriptXPrint\r\n         * \r\n         * @param {string} logText The lead-in text for a console.log entry\r\n         * @param {object} jqXhr jQuery ajax header\r\n         * @param {string} textStatus textStatus result determined by jQuery\r\n         * @param {string} errorThrown The server exception dewtermined by jQuery\r\n         * @returns {string} The error text to display\r\n         */\r\n        parseAjaxError: function (logText, jqXhr, textStatus, errorThrown) {\r\n            return MeadCo.parseAjaxError(logText, jqXhr, textStatus, errorThrown);\r\n        },\r\n\r\n        /**\r\n         * Extract the error text from browser fetch response\r\n         * \r\n         * @function parseFetchError\r\n         * @memberof MeadCoScriptXPrint\r\n         * \r\n         * @param {object} errorThrown error caught from fetch \r\n         * @returns {string} The error text to display\r\n         */\r\n        parseFetchError: function (logText, errorThrown) {\r\n            return MeadCo.parseFetchError(logText, errorThrown);\r\n        },\r\n\r\n        /**\r\n         * 'derived' classes call this function to report errors, will either throw or report depending on \r\n         * value of onErrorAction.\r\n         * \r\n         * @memberof MeadCoScriptXPrint\r\n         * @function reportError \r\n         * @param {string} errorTxt the error text to display\r\n         * \r\n         */\r\n        reportError: function (errorTxt) {\r\n            MeadCo.error(\"ReportError: \" + errorTxt);\r\n            switch (errorAction) {\r\n                case enumErrorAction.REPORT:\r\n                    MeadCo.ScriptX.Print.reportServerError(errorTxt);\r\n                    break;\r\n\r\n                case enumErrorAction.THROW:\r\n                    throw new Error(errorTxt);\r\n            }\r\n        },\r\n\r\n        /**\r\n         * overridable function for reporting an error. 'derived' classes call this\r\n         * function to report errors.\r\n         * \r\n         * @memberof MeadCoScriptXPrint\r\n         * @function reportServerError \r\n         * @param {string} errorTxt the error text to display\r\n         * \r\n         * ```js\r\n         * // overload cloud print library report error\r\n         * MeadCo.ScriptX.Print.reportServerError = function (errorTxt) {\r\n         *    app.Messages.PrintErrorBox(errorTxt);\r\n         * }\r\n         * ```\r\n         */\r\n        reportServerError: function (errorTxt) {\r\n            alert(\"There was an error in the printing service\\n\\n\" + errorTxt);\r\n        },\r\n\r\n        /**\r\n         * overridable function for reporting an implementation isnt available. 'derived' classes call this\r\n         * function to report functions that are not yet implemented.\r\n         * \r\n         * @memberof MeadCoScriptXPrint\r\n         * @function reportFeatureNotImplemented\r\n         * @param {string} featureDescription descriptn of the feature that isnt available\r\n         * \r\n         * ```js\r\n         * // overload cloud print library report error\r\n         * MeadCo.ScriptX.Print.reportFeatureNotImplemented = function (featureDescription) {\r\n         *   app.Messages.PrintErrorBox(featureDescription + \" is not available yet with the ScriptX.Services.\\n\\nThis feature will be implemented soon.\");\r\n         * }\r\n         * ```\r\n         */\r\n        reportFeatureNotImplemented: function (featureDescription) {\r\n            MeadCo.log(\"Call to not implemented: \" + featureDescription);\r\n            alert(featureDescription + \"\\n\\nis not available.\");\r\n        },\r\n\r\n        /**\r\n         * The list of jobs currently active at this client or server (client 'jobs' are those waiting to be \r\n         * delivered to the server and 'locks' while asychronous UI is in progress).\r\n         * \r\n         * @memberof MeadCoScriptXPrint\r\n         * @property {object[]} queue array of jobs \r\n         * @readonly\r\n         */\r\n        get queue() {\r\n            return activePrintQueue;\r\n        },\r\n\r\n        /**\r\n         * The number of jobs there are active *at the server* for this client\r\n         * \r\n         * @memberof MeadCoScriptXPrint\r\n         * @property {int} activeJobs the number of jobs\r\n         * @readonly\r\n         */\r\n        get activeJobs() {\r\n            return this.queue.filter(j => j.jobName !== jobNameWaitingForSend && j.jobName !== jobNameSentWaitingResponse && j.jobName !== jobNameHoldEnsureSpoolingStatus).length;\r\n        },\r\n\r\n        /**\r\n         * The number of client only jobs (locks and those waiting for delivery to the server) active at this client\r\n         * \r\n         * @memberof MeadCoScriptXPrint\r\n         * @property {int} clientSideJobs the number of jobs\r\n         * @readonly\r\n         */\r\n        get clientSideJobs() {\r\n            return this.queue.filter(j => j.jobName == jobNameWaitingForSend || j.jobName == jobNameSentWaitingResponse || j.jobName == jobNameHoldEnsureSpoolingStatus).length;\r\n        },\r\n\r\n        /**\r\n         * Check if there are no jobs waiting for delivery to the server (faster than clientSideJobs==0)\r\n         * \r\n         * @memberof MeadCoScriptXPrint\r\n         * @property {bool} noJobsWaitingDelivery true if no jobs waiting\r\n         * @readonly\r\n         */\r\n        get noJobsWaitingDelivery() {\r\n            return this.queue.every(j => j.jobName !== jobNameWaitingForSend && j.jobName !== jobNameSentWaitingResponse && j.jobName !== jobNameHoldEnsureSpoolingStatus);\r\n        },\r\n\r\n        /**\r\n         * Make sure that spooling status is locked active while asynchronous UI that may start\r\n         * printing is displayed by placing a lock on the queue.\r\n         * \r\n         * @memberof MeadCoScriptXPrint\r\n         * @function ensureSpoolingStatus\r\n         * @returns {object} a fake job to lock the spooling status on\r\n         * \r\n         * @example\r\n         * var lock = MeadCo.ScriptX.Print.ensureSpoolingStatus\r\n         * ShowAsyncUI(function() {\r\n         *  MeadCo.ScriptX.Print.freeSpoolStatus(lock);\r\n         * });\r\n         */\r\n        ensureSpoolingStatus: function () {\r\n            var lock = { jobIdentifier: Date.now(), printerName: \"ensureJobsPrinter\", jobName: jobNameHoldEnsureSpoolingStatus };\r\n            queueJob(lock);\r\n            return lock;\r\n        },\r\n\r\n        /**\r\n         * Remove a lock on the queue that was created by a call to ensureSpoolingStatus().\r\n         * \r\n         * @memberof MeadCoScriptXPrint\r\n         * @function freeSpoolStatus\r\n         * @param {object} lock the lock object returned by ensureSpoolingStatus()\r\n         */\r\n        freeSpoolStatus: function (lock) {\r\n            removeJob(lock.jobIdentifier);\r\n        },\r\n\r\n        /**\r\n         * Get if print is still 'spooling', in other words still queued at the server\r\n         * \r\n         * @memberof MeadCoScriptXPrint\r\n         * @property {bool} isSpooling\r\n         * @readonly\r\n         */\r\n        get isSpooling() {\r\n            return jobCount() > 0;\r\n        },\r\n\r\n        /**\r\n         * Start (asynchronous) monitor to observe until no more jobs spooling/waiting at the server\r\n         * then call the given callback function\r\n         * \r\n         * @memberof MeadCoScriptXPrint\r\n         * @function waitForSpoolingComplete\r\n         * @param {int} iTimeout wait until complete or timeout (in ms) -1 => infinite\r\n         * @param {function({bool})} fnComplete callback function, arg is true if all jobs complete\r\n         */\r\n        waitForSpoolingComplete: function (iTimeout, fnComplete) {\r\n            MeadCo.log(\"Started WaitForSpoolingComplete(\" + iTimeout + \")\");\r\n            if (typeof fnComplete !== \"function\") {\r\n                throw \"WaitForSpoolingComplete requires a completion callback\";\r\n            }\r\n\r\n            var startTime = Date.now();\r\n            var interval = 250;\r\n\r\n            var intervalId = window.setInterval(function () {\r\n                if (jobCount() === 0) {\r\n                    MeadCo.log(\"WaitForSpoolingComplete - complete\");\r\n                    window.clearInterval(intervalId);\r\n                    fnComplete(true);\r\n                } else {\r\n                    if (iTimeout >= 0 && Date.now() - startTime > iTimeout) {\r\n                        MeadCo.log(\"WaitForSpoolingComplete - timeout\");\r\n                        window.clearInterval(intervalId);\r\n                        fnComplete(jobCount() === 0);\r\n                    }\r\n                }\r\n            }, interval);\r\n        },\r\n\r\n        /**\r\n         * Start (asynchronous) monitor to observe until all submitted jobs have been\r\n         * delivered to the server, there will probably be jobs still waiting to process/spool\r\n         * at the server. It is not safe to close the browser window until this function \r\n         * indicates completion\r\n         * \r\n         * @memberof MeadCoScriptXPrint\r\n         * @function waitForDeliveryComplete\r\n         * @param {int} iTimeout wait until complete or timeout (in ms) -1 => infinite\r\n         * @param {function({bool})} fnComplete callback function, arg is true if all jobs delivered\r\n\r\n         */\r\n        waitForDeliveryComplete: function (iTimeout, fnComplete) {\r\n            MeadCo.log(\"Started waitForDeliveryComplete(\" + iTimeout + \")\");\r\n            if (typeof fnComplete !== \"function\") {\r\n                throw \"waitForDeliveryComplete requires a completion callback\";\r\n            }\r\n\r\n            const startTime = Date.now();\r\n            const interval = 250;\r\n            const that = this;\r\n\r\n            const intervalId = window.setInterval(() => {\r\n                if (that.noJobsWaitingDelivery) {\r\n                    MeadCo.log(\"waitForDeliveryComplete - complete\");\r\n                    window.clearInterval(intervalId);\r\n                    fnComplete(true);\r\n                } else {\r\n                    if (iTimeout >= 0 && Date.now() - startTime > iTimeout) {\r\n                        MeadCo.log(\"waitForDeliveryComplete - timeout\");\r\n                        window.clearInterval(intervalId);\r\n                        fnComplete(false);\r\n                    }\r\n                }\r\n            }, interval);\r\n\r\n        },\r\n\r\n        /**\r\n          * Waits for all pending operations originated with Print, PrintHTML and BatchPrintPDF to be delivered to the server. This is useful\r\n          * to determine when it is safe to call window.close() and not loose jobs and is a significantly shorter period than waitForSpoolingComplete()\r\n          * \r\n          * @function waitForDeliveryCompleteAsync\r\n          * @memberof MeadCoScriptXPrint\r\n          * @returns {Promise} Promise object represents boolean with value true if all jobs have been delivered.\r\n          * @example \r\n          * MeadCo.ScriptX.PrintPage(false);\r\n          * await MeadCo.ScriptX.Print.waitForDeliveryCompleteAsync();\r\n          * self.close();\r\n          */\r\n        waitForDeliveryCompleteAsync: function () {\r\n            const that = this;\r\n            return new Promise(function (resolve, reject) {\r\n                that.waitForDeliveryComplete(-1, resolve);\r\n            });\r\n        },\r\n\r\n        /**\r\n         * Get/set the timeout between jobs when there is a series of print calls and maintaining the output order is required.\r\n         * The default is 750ms. On slow systems/slow connections this may need to be increased.\r\n         * \r\n         * @memberof MeadCoScriptXPrint\r\n         * @property {number} queueTimeoutSpacing\r\n         */\r\n        get queueTimeoutSpacing() {\r\n            return timeoutSpacingMSecs;\r\n        },\r\n\r\n        set queueTimeoutSpacing(msec) {\r\n            timeoutSpacingMSecs = msec;\r\n        },\r\n\r\n        /**\r\n         * Get/set the time since last print call after which the job spacing timeout is reset\r\n         * \r\n         * @memberof MeadCoScriptXPrint\r\n         * @property {number} queueGapResetTime\r\n         */\r\n        get queueGapResetTime() {\r\n            return jobGapResetTimeout;\r\n        },\r\n\r\n        set queueGapResetTime(msec) {\r\n            jobGapResetTimeout = msec;\r\n        },\r\n\r\n        /**\r\n         * Get/set the name to use on the next job\r\n         * \r\n         * @memberof MeadCoScriptXPrint\r\n         * @property {string} jobFileName\r\n         */\r\n        get jobFileName() {\r\n            return nextJobFileName;\r\n        },\r\n\r\n        set jobFileName(sname) {\r\n            nextJobFileName = sname;\r\n        },\r\n\r\n        requestService: function (sApi, method, oApiData, bLicensed, bAsync, resolve, reject) {\r\n            return callService(sApi, method, oApiData, bLicensed, bAsync, resolve, reject);\r\n        },\r\n\r\n        getService: function (sApi, oApiData, bLicensed) {\r\n            return callService(sApi, \"GET\", oApiData, bLicensed, false);\r\n        },\r\n\r\n        postService: function (sApi, oApiData, bLicensed) {\r\n            return callService(sApi, \"POST\", oApiData, bLicensed, false);\r\n        },\r\n\r\n        getServiceAsync: function (sApi, oApiData, bLicensed, resolve, reject) {\r\n            return callService(sApi, \"GET\", oApiData, bLicensed, true, resolve, reject);\r\n        },\r\n\r\n        postServiceAsync: function (sApi, oApiData, bLicensed, resolve, reject) {\r\n            return callService(sApi, \"POST\", oApiData, bLicensed, true, resolve, reject);\r\n        }\r\n\r\n    };\r\n\r\n});\r\n"]}