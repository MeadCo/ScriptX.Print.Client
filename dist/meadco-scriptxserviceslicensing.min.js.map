{"version":3,"file":"meadco-scriptxserviceslicensing.min.js","mappings":"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","sources":["webpack://MeadCo/./src/meadco-core.js","webpack://MeadCo/./src/meadco-scriptxprint.js","webpack://MeadCo/./src/meadco-scriptxprintlicensing.js","webpack://MeadCo/./src/meadco-secmgr.js"],"sourcesContent":["﻿/**\r\n * Static class for namespace creation and core utility functions for ScriptX.Services client libraries.\r\n * \r\n * This must be included before any other files from this package.\r\n * \r\n * The implementation is for use in a browser only, not general runtime javascript environments.\r\n * \r\n * This code is necessarily 'old-fashioned' as it may find itself running in old versions of IE.\r\n *  \r\n * @namespace MeadCo\r\n */\r\n\r\n; (function (name, definition) {\r\n    var theModule = definition();\r\n\r\n    // var scope = (this.jQuery || this.ender || this.$ || this);\r\n    // we always go for window\r\n    var scope = this;\r\n\r\n    // hack ...\r\n    //\r\n    // MeadCo.ScriptX and MeadCo.Licensing may already be defined\r\n    // when we run -- they would happily extend this implementation\r\n    // and we should extend theirs. This is a horible way to do it.\r\n    //\r\n    var oldscope = null;\r\n    if (typeof scope[name] !== 'undefined') {\r\n        // console.log(name + \" already exists\");\r\n        oldscope = scope[name];\r\n    }\r\n\r\n    scope[name] = theModule;\r\n\r\n    if (oldscope !== null) {\r\n        var newscope = scope[name];\r\n\r\n        // console.log(\"preserving old scope ... \");\r\n        for (var prop in oldscope) {\r\n            if (oldscope.hasOwnProperty(prop)) {\r\n                // console.log(\"will preserve: \" + prop);\r\n                newscope[prop] = oldscope[prop];\r\n            }\r\n        }\r\n    }\r\n\r\n    // this is moderately poor .. assuming this code is executing\r\n    // as the root of the name space, which it is and assumes\r\n    // it implements inheritable extendNamespace(), which it does.\r\n    // For all that, it means that the root gets to decide where this\r\n    // is (i.e. in a common namespace or the global object)\r\n    theModule.scope = scope;\r\n\r\n})('MeadCo', function () {\r\n\r\n    // protected API\r\n    var outerScope = this;\r\n    var version = \"1.16.1.0\"; // matches the highest version number of sub-classes.\r\n    var bLog = ((typeof (MeadCo) !== \"undefined\" && typeof (MeadCo.logEnable) !== \"undefined\")) ? MeadCo.logEnable : false;\r\n    var bUseFetch = ((typeof (MeadCo) !== \"undefined\" && typeof (MeadCo.useFetch) !== \"undefined\")) ? MeadCo.useFetch : false;\r\n\r\n    var log = function (str) {\r\n        if (bLog) {\r\n            console.log(\"MeadCo :: \" + str);\r\n        }\r\n    };\r\n\r\n    var warn = function (str) {\r\n        console.warn(\"MeadCo :: \" + str);\r\n    };\r\n\r\n    var error = function (str) {\r\n        console.error(\"MeadCo :: \" + str);\r\n    };\r\n\r\n    // extend the namespace\r\n    outerScope.extendMeadCoNamespace = function (name, definition) {\r\n        var theModule = definition()\r\n\r\n        log(\"MeadCo root extending namespace: \" + name);\r\n        // walk/build the namespace part by part and assign the module to the leaf\r\n        var namespaces = name.split(\".\");\r\n        var scope = (outerScope.scope || this.jQuery || this.ender || this.$ || this);\r\n        for (var i = 0; i < namespaces.length; i++) {\r\n            var packageName = namespaces[i];\r\n            if (i === namespaces.length - 1) {\r\n                if (typeof scope[packageName] === \"undefined\") {\r\n                    log(\"installing implementation at: \" + packageName);\r\n                    scope[packageName] = theModule;\r\n                } else {\r\n                    log(\"Warning - extending package: \" + packageName);\r\n                    var oldscope = scope[packageName];\r\n                    scope[packageName] = theModule;\r\n\r\n                    var newscope = scope[packageName];\r\n\r\n                    log(\"preserving old scope ... \");\r\n                    for (var prop in oldscope) {\r\n                        if (oldscope.hasOwnProperty(prop)) {\r\n                            log(\"will preserve: \" + prop);\r\n                            newscope[prop] = oldscope[prop];\r\n                        }\r\n                    }\r\n                }\r\n            } else if (typeof scope[packageName] === \"undefined\") {\r\n                log(\"initialising new: \" + packageName);\r\n                scope[packageName] = {};\r\n            } else {\r\n                log(\"using existing package: \" + packageName);\r\n            }\r\n            scope = scope[packageName];\r\n        }\r\n    };\r\n\r\n    /*\r\n     * Extract the error text from jQuery AJAX response\r\n     * \r\n     * @param {string} logText The lead-in text for a console.log entry\r\n     * @param {object} jqXhr jQuery ajax header\r\n     * @param {string} textStatus textStatus result determined by jQuery\r\n     * @param {string} errorThrown The server exception dewtermined by jQuery\r\n     * @returns {string} The error text to display\r\n     */\r\n    function parseError(logText, jqXhr, textStatus, errorThrown) {\r\n        error(\"**warning: AJAX call failure in \" + logText + \": [\" +\r\n            textStatus +\r\n            \"], [\" +\r\n            errorThrown +\r\n            \"], [\" +\r\n            jqXhr.responseText +\r\n            \"], [\" +\r\n            jqXhr.statusText +\r\n            \"]\");\r\n\r\n        if (errorThrown === \"\" || errorThrown === \"Internal Server Error\") {\r\n            if (textStatus !== \"error\") {\r\n                errorThrown = jqXhr.responseText || textStatus;\r\n            }\r\n            else {\r\n                if (typeof jqXhr.responseJSON === \"object\" && typeof jqXhr.responseJSON.Message === \"string\") {\r\n                    errorThrown = jqXhr.responseJSON.Message;\r\n                }\r\n                else {\r\n                    if (typeof jqXhr.responseText === \"string\") {\r\n                        errorThrown = jqXhr.responseText;\r\n                    }\r\n                    else\r\n                        errorThrown = \"Server or network error\";\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            if (typeof jqXhr.responseJSON !== \"object\" && typeof jqXhr.responseText === \"string\" && jqXhr.responseText.length > 0) {\r\n                errorThrown = jqXhr.responseText;\r\n            }\r\n        }\r\n\r\n        error(\" error parsed to --> [\" + errorThrown + \"]\");\r\n        return errorThrown;\r\n    }\r\n\r\n    log(\"MeadCo root namespace \" + version + \" loaded.\");\r\n\r\n    // public API.\r\n    return {\r\n        /**\r\n         * Sends the content to the console (if informational logging is enabled)\r\n         * @function log\r\n         * @memberof MeadCo\r\n         * @param {string} text to send to console\r\n         */\r\n        log: log,\r\n\r\n        /**\r\n         * Marks the content as a warning and sends to the console \r\n         * @function warn\r\n         * @memberof MeadCo\r\n         * @param {string} text to send to console\r\n         */\r\n        warn: warn,\r\n\r\n        /**\r\n         * Marks the content as an error and sends to the console \r\n         * @function error\r\n         * @memberof MeadCo \r\n         * @param {string} text to send to console\r\n         */\r\n        error: error,\r\n\r\n        /**\r\n         * Get the version of this module as a string major.minor.hotfix.build\r\n         * @property {string} version\r\n         * @memberof MeadCo\r\n         */\r\n        get version() { return version; },\r\n\r\n        /**\r\n         * Get/set state of logging to console of informational messages. Default is off\r\n         * @property {boolean} logEnabled\r\n         * @memberof MeadCo\r\n         */\r\n        get logEnabled() { return bLog; },\r\n        set logEnabled(bEnable) {\r\n            bLog = bEnable;\r\n        },\r\n\r\n        /**\r\n         * Get/set state of forcing use of fetch even if jQuery(.ajax) is available. Default is off\r\n         * @property {boolean} logEnabled\r\n         * @memberof MeadCo         * \r\n         */\r\n        get fetchEnabled() { return bUseFetch; },\r\n        set fetchEnabled(bEnable) {\r\n            bUseFetch = bEnable;\r\n        },\r\n\r\n        /**\r\n         * Create a namespace\r\n         * @function createNS\r\n         * @memberof MeadCo\r\n         * @param {string} namespace path of the namespace\r\n         * @returns {object} static object for the namespace\r\n         * @example\r\n         * var ui = MeadCo.createNS(\"MeadCo.ScriptX.Print.UI\");\r\n         * ui.Show = function() { alert(\"hello\"); }\r\n         */\r\n        createNS: function (namespace) {\r\n            var nsparts = namespace.split(\".\");\r\n            var parent = outerScope.scope.MeadCo;\r\n\r\n            // we want to be able to include or exclude the root namespace so we strip\r\n            // it if it's in the namespace\r\n            if (nsparts[0] === \"MeadCo\") {\r\n                nsparts = nsparts.slice(1);\r\n            }\r\n\r\n            // loop through the parts and create a nested namespace if necessary\r\n            for (var i = 0; i < nsparts.length; i++) {\r\n                var partname = nsparts[i];\r\n                // check if the current parent already has the namespace declared\r\n                // if it isn't, then create it\r\n                if (typeof parent[partname] === \"undefined\") {\r\n                    parent[partname] = {};\r\n                }\r\n                // get a reference to the deepest element in the hierarchy so far\r\n                parent = parent[partname];\r\n            }\r\n            // the parent is now constructed with empty namespaces and can be used.\r\n            // we return the outermost namespace\r\n            return parent;\r\n        },\r\n\r\n        /**\r\n         * @private\r\n         * @param {object} s the scope in which to create namesapces\r\n         */\r\n        set scope(s) { outerScope.scope = s; },\r\n\r\n        /**\r\n         * Get the url to a ScriptX.Services api. If an api is already present, it is replaced.\r\n         * \r\n         * @function makeApiEndPoint\r\n         * @memberof MeadCo\r\n         * @param {string} serverUrl url to the server\r\n         * @param {string} apiLocation the api, e.g. v1/printhtml\r\n         * @returns {string} url to the api\r\n         */\r\n        makeApiEndPoint: function (serverUrl, apiLocation) {\r\n            // check if given partial ...\r\n            var p = serverUrl.indexOf(\"/api\");\r\n            if (p === -1) {\r\n                if (serverUrl.lastIndexOf(\"/\") !== (serverUrl.length - 1)) {\r\n                    serverUrl += \"/\";\r\n                }\r\n                serverUrl += \"api/\" + apiLocation;\r\n            }\r\n            else {\r\n                // given another api, chop and replace with requested api\r\n                serverUrl = serverUrl.substring(0, p) + \"/api/\" + apiLocation;\r\n            }\r\n            return serverUrl;\r\n        },\r\n\r\n        /**\r\n         * Get the url to a ScriptX.Services service endpoint. \r\n         * \r\n         * @function makeServiceEndPoint\r\n         * @memberof MeadCo\r\n         * @param {string} serverUrl url to the server\r\n         * @param {string} endPoint the service endpoint, e.g. v1/preview\r\n         * @returns {string} url to the endpoint\r\n         */\r\n        makeServiceEndPoint: function (serverUrl, endPoint) {\r\n            // check if given partial ...\r\n            var p = serverUrl.indexOf(\"/api\");\r\n            if (p === -1) {\r\n                if (serverUrl.lastIndexOf(\"/\") !== (serverUrl.length - 1)) {\r\n                    serverUrl += \"/\";\r\n                }\r\n                serverUrl += endPoint;\r\n            }\r\n            else {\r\n                // given another api, chop and replace with requested api\r\n                serverUrl = serverUrl.substring(0, p) + \"/\" + endPoint;\r\n            }\r\n            return serverUrl;\r\n        },\r\n\r\n\r\n        /**\r\n         * Extract the error text from jQuery AJAX response\r\n         * \r\n         * @function parseAjaxError\r\n         * @memberof MeadCo\r\n         * \r\n         * @param {string} logText The lead-in text for a console.log entry\r\n         * @param {object} jqXhr jQuery ajax header\r\n         * @param {string} textStatus textStatus result determined by jQuery\r\n         * @param {string} errorThrown The server exception dewtermined by jQuery\r\n         * @returns {string} The error text to display\r\n         */\r\n        parseAjaxError: function (logText, jqXhr, textStatus, errorThrown) {\r\n            return parseError(logText, jqXhr, textStatus, errorThrown);\r\n        },\r\n\r\n        /**\r\n         * Extract the error text from browser fetch response\r\n         * \r\n         * @function parseFetchError\r\n         * @memberof MeadCo\r\n         * \r\n         * @param {object} errorThrown error caught from fetch \r\n         * @returns {string} The error text to display\r\n         */\r\n        parseFetchError: function (logText, errorThrown) {\r\n            const msg = typeof errorThrown === \"string\" ? errorThrown : errorThrown.message;\r\n            error(\"**warning: FETCH call failure in \" + logText + \": \" + msg);\r\n            return msg;\r\n        }\r\n    };\r\n\r\n});\r\n\r\n\r\n","/**\r\n * MeadCo.ScriptX.Print\r\n * \r\n * A static class wrapping calls to the server API. \r\n * \r\n * Requires: meadco-core.js\r\n * \r\n * Includes processing of calls to the print api that return \"printing to file\" including collecting the file output. \r\n * \r\n * Provides attribute based connection to the server.\r\n * \r\n * Synchronous AJAX calls are deprecated in all browsers but may be useful to \"quick start\" use of older code. It is recommended that code is moved\r\n * to using asynchronous calls as soon as practical. The MeadCoScriptXJS library can assist with this as it delivers promise rather than callback based code.\r\n * \r\n * AJAX calls can be made via jQuery or browser native fetch(). If jQuery is available it will be used by preference - if used jQuery v1.19 or later is required.\r\n * \r\n * jQuery is required for synchronous AJAX calls.\r\n * \r\n * To use fetch, even if jQuery is available then set MeadCo.fetchEnabled to false. \r\n * \r\n * This can be done using an attribute: data-meadco-usefetch=\"true\" or declare var MeadCo = { useFetch: true } before including this library\r\n * This is useful if a very old version of jQuery is required for UI.\r\n *\r\n * @namespace MeadCoScriptXPrint\r\n */\r\n\r\n; (function (name, definition) {\r\n    extendMeadCoNamespace(name, definition);\r\n})('MeadCo.ScriptX.Print', function () {\r\n    // module version and the api we are coded for\r\n    const version = \"1.16.1.4\";\r\n    const htmlApiLocation = \"v1/printHtml\";\r\n    const pdfApiLocation = \"v1/printPdf\";\r\n    const directApiLocation = \"v1/printDirect\";\r\n    const licenseApiLocation = \"v1/licensing\";\r\n    const printerApiLocation = \"v1/printer\";\r\n\r\n    // default printer \r\n    let printerName = \"\";\r\n\r\n    // using this printername causes ScriptX.Services to select \r\n    // a printer that prints to a PDF file.\r\n    const magicPrintPreviewPrinter = \"ScriptX.Services//PrintPreview.1\"\r\n\r\n    const jobNameWaitingForSend = \"[hold.clientside]\";\r\n    const jobNameSentWaitingResponse = \"[wait.response]\";\r\n    const jobNameHoldEnsureSpoolingStatus = \"[hold.ensureSpoolStatus]\";\r\n\r\n    /**\r\n     * Enum to describe the units used on measurements. Please be aware that (sadly) these enum values do *not* match  \r\n     * the values by the MeadCo ScriptX COM Servers. Please use MeadCo.ScriptX.MeasurementUnits (declared in MeadCoScriptJS) for compatibility\r\n     *\r\n     * @memberof MeadCoScriptXPrint\r\n     * @typedef {number} MeasurementUnits\r\n     * @enum {MeasurementUnits}\r\n     * @readonly\r\n     * @property {number} DEFAULT 0 use the default at the print server\r\n     * @property {number} INCHES 1 \r\n     * @property {number} MM 2 millimeters\r\n     */\r\n    const enumMeasurementUnits = {\r\n        DEFAULT: 0,\r\n        INCHES: 1,\r\n        MM: 2\r\n    };\r\n\r\n    /**\r\n     * Describe the size of a page by its width and height.\r\n     * \r\n     * @typedef PageSize\r\n     * @memberof MeadCoScriptXPrint\r\n     * @property {number} width width of paper in requested units\r\n     * @property {number} height height of paper in requested units\r\n     * */\r\n    var PageSize;  // for doc generator\r\n\r\n    /**\r\n     * Describe the margins within which to print.\r\n     * \r\n     * @typedef Margins\r\n     * @memberof MeadCoScriptXPrint\r\n     * @property {number} left left margin in requested units\r\n     * @property {number} top top margin in requested units\r\n     * @property {number} right right margin in requested units\r\n     * @property {number} bottom bottom margin in requested units\r\n     * */\r\n    var Margins;  // for doc generator\r\n\r\n    /**\r\n     * Information about and the settings to use with an output printing device\r\n     * See also: https://www.meadroid.com/Developers/KnowledgeBank/TechnicalReference/ScriptXServices/WebServiceAPIReference/PrintHtml/deviceinfoGET\r\n     * \r\n     * @typedef DeviceSettingsObject\r\n     * @memberof MeadCoScriptXPrint\r\n     * @property {string} printerName The name of the printer\r\n     * @property {string} printToFileName The name of a the file to send print output to (for Windows PC and )\r\n     * @property {string} paperSizeName The descriptive name of the papersize, e.g. \"A4\"\r\n     * @property {string} paperSourceName The descriptive name of the paper source, e.g. \"Upper tray\"\r\n     * @property {CollateOptions} collate The collation to use when printing\r\n     * @property {number} copies The number of copies to print\r\n     * @property {DuplexOptions} duplex The dulex printing option\r\n     * @property {MeasurementUnits} units Measurement units for papersize and margins\r\n     * @property {PageSize} paperPageSize The size of the paper (in requested units)\r\n     * @property {Margins} unprintableMargins The margin that cannot be printed in (in requested units)\r\n     * @property {number} status Status code for the status of the device. Note this is not reliable, it is the cached return from the first server enquiry only.\r\n     * @property {string} port Printer connection port name/description\r\n     * @property {number} attributes Printer attributes\r\n     * @property {string} serverName Name of the server to which the printer is connected\r\n     * @property {string} shareName Name of the share \r\n     * @property {string} location description of the location of the printer\r\n     * @property {boolean} isLocal true if the printer is local to the server\r\n     * @property {boolean} isNetwork true if the server is on the network\r\n     * @property {boolean} isShared true if the printer is shared \r\n     * @property {boolean} isDefault true if this is the default printer on the service\r\n     * @property {Array.<string>} bins Array of the names of the available paper sources\r\n     * @property {Array.<string>} forms Array of the names of the avbailable paper sizes\r\n     * */\r\n    var DeviceSettingsObject; // for doc generator\r\n\r\n    /**\r\n     * Provide authorisation details to access protected content. \r\n     * \r\n     * @typedef AccessControl\r\n     * @memberof MeadCoScriptXPrint\r\n     * @property {string} cookie The authorisation cookie in the form name=value|name2=value2\r\n     * */\r\n    var AccessControl = {\r\n        cookie: \"\"\r\n    };\r\n\r\n    /**\r\n     * Description of a code version. Semver is used \r\n     * \r\n     * @typedef VersionObject\r\n     * @memberof MeadCoScriptXPrint\r\n     * @property {int} major The major version  \r\n     * @property {int} minor The minor version \r\n     * @property {int} build The patch/hotfix version\r\n     * @property {int} revision Internal revisions of a build/patch/hotfix\r\n     * @property {int} majorRevision ignore\r\n     * @property {int} minorRevision ignore \r\n     * */\r\n    var VersionObject; // for doc generator\r\n\r\n    let deviceSettings = {};\r\n    const outerScope = this;\r\n\r\n    let activePrintQueue = []; // current job queue\r\n\r\n    // singleton wrapper to the server\r\n    //\r\n    // servicesServer.url\r\n    // servicesServer.test\r\n    // servicesServer.call\r\n    //\r\n    const servicesServer = {\r\n\r\n        serviceUrl: \"\",\r\n        pendingUrl: \"\",\r\n        failedUrl: \"\",\r\n        verifiedUrl: \"\",\r\n        orchestratorPort: 0,\r\n        orchestratorKey: \"\",\r\n        portsToTry: 10,\r\n        verifying: false,\r\n        trustVerifiedConnection: true, // if true then once a connection has been found, trust that it will be valid for the page lifetime\r\n\r\n        undoTrust: function () {\r\n            if (!this.trustVerifiedConnection && this.serviceUrl !== \"\") {\r\n                this.verifiedUrl = this.serviceUrl;\r\n                this.pendingUrl = this.serviceUrl;\r\n                this.serviceUrl = \"\";\r\n            }\r\n        },\r\n\r\n        get url() {\r\n\r\n            if (this.verifiedUrl !== \"\") {\r\n                return this.verifiedUrl;\r\n            }\r\n\r\n            if (this.serviceUrl === \"\" && this.pendingUrl !== \"\") {\r\n                MeadCo.warn(\"[GET] servicesServer.url is not ready, performing synchronous search. Recommend code re-org to resolve the server earlier and asynchronously.\")\r\n                var that = this;\r\n                this.verifyUrl(this.pendingUrl, false, function () {\r\n                    return that.serviceUrl;\r\n                }, function () {\r\n                    return \"\";\r\n                });\r\n            }\r\n\r\n            return this.serviceUrl;\r\n\r\n        },\r\n\r\n        // essentially synchronous set url, we set the pending value so the code \r\n        // executes synchronously here and there may then be an asynchronous sorting\r\n        // out when an api call is made (see implementation of call : function())\r\n        set url(value) {\r\n            MeadCo.log(\"servicesServer::setUrl: \" + value);\r\n            if (this.IsChangingServer(value)) {\r\n                MeadCo.log(\"note set as pending\");\r\n                this.serviceUrl = \"\";\r\n                this.pendingUrl = value;\r\n            }\r\n        },\r\n\r\n        setUrlAsync: function (value, resolve, reject) {\r\n            MeadCo.log(\"servicesServer::urlAsync: \" + value);\r\n            this.verifyUrl(value, true, resolve, reject);\r\n        },\r\n\r\n        verifyUrl: function (value, bAsync, resolve, reject) {\r\n\r\n            if (this.verifying && bAsync) {\r\n                MeadCo.warn(\"Verify called and verify in progress ....\");\r\n                var that = this;\r\n                var thatValue = value;\r\n                window.setTimeout(function () { that.verifyUrl(thatValue, bAsync, resolve, reject); }, 1000);\r\n                return;\r\n            }\r\n\r\n            if (this.IsChangingServer(value) && !this.IsFailedConnection(value)) {\r\n\r\n                var that = this;\r\n                var thatValue = value;\r\n\r\n                MeadCo.log(\"servicesServer::verifyurl: \" + value + \", async: \" + bAsync);\r\n\r\n                // if an orchestrator has been defined then ask it for the current users port\r\n                if (typeof this.orchestratorPort !== \"number\") {\r\n                    this.orchestratorPort = parseInt(\"\" + this.orchestratorPort);\r\n                }\r\n\r\n                if (this.orchestratorPort > 0) {\r\n                    MeadCo.log(\"Using request to Orchestrator on port: \" + this.orchestratorPort);\r\n                    that.verifying = true;\r\n\r\n                    // by definition Orchestrator is local.\r\n                    var apiEndPoint;\r\n                    if (typeof this.orchestratorKey === \"string\" && this.orchestratorKey.length > 0) {\r\n                        apiEndPoint = \"/api/v2?key=\" + this.orchestratorKey;\r\n                    }\r\n                    else {\r\n                        apiEndPoint = \"/api/v1\";\r\n                    }\r\n\r\n                    MeadCo.log(\"servicesServer::querying orchestrator: \" + \"http://127.0.0.1:\" + this.orchestratorPort + apiEndPoint);\r\n\r\n                    if (outerScope.jQuery && !MeadCo.fetchEnabled) {\r\n                        outerScope.jQuery.ajax(\"http://127.0.0.1:\" + this.orchestratorPort + apiEndPoint,\r\n                            {\r\n                                method: \"GET\",\r\n                                dataType: \"json\",\r\n                                cache: false,\r\n                                async: bAsync\r\n                            }).done(function (data) {\r\n\r\n                                MeadCo.log(\"orchestrator returned ScriptX.Services port: \" + data.HttpPort)\r\n\r\n                                var urlHelper = new URL(thatValue);\r\n                                urlHelper.port = data.HttpPort;\r\n                                thatValue = urlHelper.protocol + \"//\" + urlHelper.host + urlHelper.pathname\r\n\r\n                                that.test(thatValue, 0, bAsync, function (urlFound) {\r\n                                    that.serviceUrl = urlFound;\r\n                                    that.pendingUrl = \"\";\r\n                                    that.verifying = false;\r\n                                    resolve(urlFound, true);\r\n                                }, function (errorThrown) {\r\n                                    that.serviceUrl = \"\";\r\n                                    that.pendingUrl = \"\";\r\n                                    that.failedUrl = thatValue;\r\n                                    that.verifying = false;\r\n                                    if (typeof reject === \"function\") {\r\n                                        reject(errorThrown);\r\n                                    }\r\n                                });\r\n\r\n                            })\r\n                            .fail(function (jqXhr, textStatus, errorThrown) {\r\n                                that.verifying = false;\r\n                                that.serviceUrl = \"\";\r\n                                that.pendingUrl = \"\";\r\n\r\n                                const msg = MeadCo.parseAjaxError(\"Failed to connect with Orchestrator: \", jqXhr, textStatus, errorThrown);\r\n                                MeadCo.warn(msg);\r\n\r\n                                try {\r\n                                    let t = new URL(thatValue);\r\n                                    that.failedUrl = thatValue;\r\n                                }\r\n                                catch (_) { }\r\n\r\n                                if (typeof reject === \"function\") {\r\n                                    reject(\"ScriptX.Services (Orchestrator) could not be found at \\\"\" + thatValue + \"\\\". Is it installed and running?\");\r\n                                }\r\n                            });\r\n                    }\r\n                    else {\r\n                        fetch(\"http://127.0.0.1:\" + this.orchestratorPort + apiEndPoint)\r\n                            .then((response) => {\r\n                                if (!response.ok) {\r\n                                    throw new Error(`HTTP Error: ${response.status}`)\r\n                                }\r\n                                return response.json();\r\n                            })\r\n                            .then(data => {\r\n                                MeadCo.log(\"orchestrator returned ScriptX.Services port: \" + data.HttpPort)\r\n\r\n                                var urlHelper = new URL(thatValue);\r\n                                urlHelper.port = data.HttpPort;\r\n                                thatValue = urlHelper.protocol + \"//\" + urlHelper.host + urlHelper.pathname\r\n\r\n                                that.test(thatValue, 0, bAsync, function (urlFound) {\r\n                                    that.serviceUrl = urlFound;\r\n                                    that.pendingUrl = \"\";\r\n                                    that.verifying = false;\r\n                                    resolve(urlFound, true);\r\n                                }, function (errorThrown) {\r\n                                    that.serviceUrl = \"\";\r\n                                    that.pendingUrl = \"\";\r\n                                    that.failedUrl = thatValue;\r\n                                    that.verifying = false;\r\n                                    if (typeof reject === \"function\") {\r\n                                        reject(errorThrown);\r\n                                    }\r\n                                });\r\n                            })\r\n                            .catch(error => {\r\n                                that.verifying = false;\r\n                                that.serviceUrl = \"\";\r\n                                that.pendingUrl = \"\";\r\n\r\n                                try {\r\n                                    let t = new URL(thatValue);\r\n                                    that.failedUrl = thatValue;\r\n                                }\r\n                                catch (_) { }\r\n\r\n                                if (typeof reject === \"function\") {\r\n                                    reject(\"ScriptX.Services (Orchestrator) could not be found at \\\"\" + thatValue + \"\\\". Is it installed and running?\");\r\n                                }\r\n                            });\r\n                    }\r\n                }\r\n                else {\r\n                    that.verifying = true;\r\n                    that.test(thatValue, that.portsToTry, bAsync, function (urlFound) {\r\n                        that.serviceUrl = urlFound;\r\n                        that.pendingUrl = \"\";\r\n                        that.verifying = false;\r\n                        resolve(urlFound, false);\r\n                    }, function (errorThrown) {\r\n                        that.serviceUrl = \"\";\r\n                        that.pendingUrl = \"\";\r\n                        that.verifying = false;\r\n\r\n                        try {\r\n                            let t = new URL(thatValue);\r\n                            that.failedUrl = thatValue;\r\n                        }\r\n                        catch (_) { }\r\n\r\n                        if (typeof reject === \"function\") {\r\n                            reject(\"ScriptX.Services could not be found at \\\"\" + thatValue + \"\\\". Is it installed and running?\");\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n            else {\r\n                if (this.IsFailedConnection(value)) {\r\n                    if (typeof reject === \"function\") {\r\n                        reject(\"ScriptX.Services connection to: \" + value + \" is either invalid or has already failed and will not be re-tried.\")\r\n                    }\r\n                    else {\r\n                        MeadCo.warn(\"ScriptX.Services connection to: \" + value + \" has already failed and will not be re-tried.\")\r\n                    }\r\n                }\r\n                else\r\n                    resolve(this.serviceUrl, this.orchestratorPort > 0);\r\n            }\r\n        },\r\n\r\n        // test\r\n        //\r\n        // Can we ask something and get a response, without using a license - checks the server is there.\r\n        //\r\n        // Will perform port hunt (increment the port number) when attempting to connect to\r\n        // ScriptX.Services for Windows PC\r\n        //\r\n        test: function (serverUrl, nHuntAllowed, bAsync, resolve, reject) {\r\n            if (serverUrl.length > 0) {\r\n                const that = this;\r\n                let urlHelper;\r\n\r\n                try {\r\n                    urlHelper = new URL(serverUrl);\r\n                    if (urlHelper.protocol !== 'http:' && urlHelper.protocol !== 'https:') {\r\n                        reject(\"Invalid protocol: \" + serverUrl);\r\n                        return;\r\n                    }\r\n                } catch (_) {\r\n                    reject(\"Invalid URL: \" + serverUrl);\r\n                    return;\r\n                }\r\n\r\n                MeadCo.log(\"Test server requested: \" + serverUrl + \", port: \" + urlHelper.port);\r\n\r\n                // use the license API\r\n                const serviceUrl = MeadCo.makeApiEndPoint(urlHelper.href, licenseApiLocation + \"/ping\");\r\n\r\n                if (outerScope.jQuery && !MeadCo.fetchEnabled) {\r\n                    MeadCo.log(\".ajax() get: \" + serviceUrl);\r\n                    outerScope.jQuery.ajax(serviceUrl,\r\n                        {\r\n                            method: \"GET\",\r\n                            dataType: \"json\",\r\n                            cache: false,\r\n                            async: bAsync\r\n                        }).done(function (data) {\r\n                            const resolvedUrl = urlHelper.protocol + \"//\" + urlHelper.host + urlHelper.pathname;\r\n                            MeadCo.log(\"Test server succeed, resolve(\" + resolvedUrl + \")\")\r\n                            resolve(resolvedUrl);\r\n                        })\r\n                        .fail(function (jqXhr, textStatus, errorThrown) {\r\n                            // only do hunting with 4WPC and that must be on 127.0.0.1 or localhost\r\n                            MeadCo.log(\"Test server failed: [\" + errorThrown + \"], \" + nHuntAllowed + \", on: \" + urlHelper.hostname);\r\n                            if (nHuntAllowed > 0 && (urlHelper.hostname === \"localhost\" || urlHelper.hostname == \"127.0.0.1\")) {\r\n                                urlHelper.port++;\r\n                                outerScope.setTimeout(that.test(urlHelper.protocol + \"//\" + urlHelper.host + urlHelper.pathname, --nHuntAllowed, bAsync, resolve, reject), 1);\r\n                            }\r\n                            else {\r\n                                errorThrown = MeadCo.parseAjaxError(\"MeadCo.ScriptX.Print.servicesServer.test:\", jqXhr, textStatus, errorThrown);\r\n                                if (typeof reject === \"function\") {\r\n                                    MeadCo.log(\"rejecting with: \" + errorThrown);\r\n                                    reject(errorThrown);\r\n                                }\r\n                                else {\r\n                                    MeadCo.warn(\"failed with no reject function\");\r\n                                }\r\n                            }\r\n                        });\r\n                }\r\n                else {\r\n                    MeadCo.log(\"fetch get: \" + serviceUrl);\r\n                    if (bAsync) {\r\n                        fetch(serviceUrl)\r\n                            .then((response) => {\r\n                                if (!response.ok) {\r\n                                    throw new Error(`HTTP Error: ${response.status}`)\r\n                                }\r\n                                return response.json();\r\n                            })\r\n                            .then(data => {\r\n                                const resolvedUrl = urlHelper.protocol + \"//\" + urlHelper.host + urlHelper.pathname;\r\n                                MeadCo.log(\"Test server succeed, resolve(\" + resolvedUrl + \")\")\r\n                                resolve(resolvedUrl);\r\n                            })\r\n                            .catch((error) => {\r\n                                // only do hunting with 4WPC and that must be on 127.0.0.1 or localhost\r\n                                MeadCo.log(\"Test server failed: [\" + error + \"], \" + nHuntAllowed + \", on: \" + urlHelper.hostname);\r\n                                if (nHuntAllowed > 0 && (urlHelper.hostname === \"localhost\" || urlHelper.hostname == \"127.0.0.1\")) {\r\n                                    urlHelper.port++;\r\n                                    outerScope.setTimeout(that.test(urlHelper.protocol + \"//\" + urlHelper.host + urlHelper.pathname, --nHuntAllowed, bAsync, resolve, reject), 1);\r\n                                }\r\n                                else {\r\n                                    errorThrown = MeadCo.parseFetchError(\"MeadCo.ScriptX.Print.servicesServer.test:\", error);\r\n                                    if (typeof reject === \"function\") {\r\n                                        MeadCo.log(\"rejecting with: \" + errorThrown);\r\n                                        reject(errorThrown);\r\n                                    }\r\n                                    else {\r\n                                        MeadCo.warn(\"failed with no reject function\");\r\n                                    }\r\n                                }\r\n\r\n                            });\r\n                    }\r\n                    else {\r\n                        MeadCo.error(\"Synchronous Ajax calls requires jQuery\");\r\n                        if (typeof reject === \"function\") {\r\n                            reject(\"Synchronous Ajax calls requires jQuery\");\r\n                        }\r\n                    }\r\n                }\r\n\r\n            }\r\n        },\r\n\r\n        // send a method request to an end point\r\n        //\r\n        call: function (sApi, method, oApiData, bLicensed, bAsync, resolve, reject) {\r\n\r\n            const that = this;\r\n\r\n            if (this.serviceUrl === \"\" && this.pendingUrl !== \"\") {\r\n\r\n                this.verifyUrl(this.pendingUrl, bAsync, function () {\r\n                    if (that.url !== \"\") {\r\n                        that.call(sApi, method, oApiData, bLicensed, bAsync, resolve, reject);\r\n                    }\r\n                    else {\r\n                        if (typeof reject === \"function\") {\r\n                            reject(\"Server url verification failed to set url\");\r\n                        }\r\n                    }\r\n                }, reject);\r\n            }\r\n            else {\r\n                if (this.serviceUrl !== \"\") {\r\n                    const serviceUrl = MeadCo.makeApiEndPoint(this.serviceUrl, sApi);\r\n                    const currentUrl = window.location.href;\r\n                    MeadCo.log(\"servicesServer.call() \" + method + \": \" + serviceUrl);\r\n                    let oPayload = {\r\n                        method: method,\r\n                        cache: false,\r\n                        async: bAsync,\r\n                        jsonp: false,\r\n                        dataType: \"json\",\r\n                        contentType: \"application/json\"\r\n                    };\r\n\r\n                    if (bLicensed) {\r\n                        oPayload.headers = {\r\n                            \"Authorization\": \"Basic \" + btoa(licenseGuid + \":\"),\r\n                            \"X-Meadroid-Path\": currentUrl\r\n                        }\r\n                    }\r\n                    else {\r\n                        oPayload.headers = {\r\n                            \"X-Meadroid-Path\": currentUrl\r\n                        }\r\n                    }\r\n\r\n                    if (!this.IsEmptyPayload(oApiData)) {\r\n                        MeadCo.log(\"payload defined.\");\r\n                        oPayload.data = JSON.stringify(oApiData);\r\n                    }\r\n\r\n                    if (outerScope.jQuery && !MeadCo.fetchEnabled) {\r\n                        outerScope.jQuery.ajax(serviceUrl, oPayload)\r\n                            .done(function (data) {\r\n                                if (typeof resolve === \"function\") {\r\n                                    resolve(data);\r\n                                }\r\n                                return data;\r\n                            })\r\n                            .fail(function (jqXhr, textStatus, errorThrown) {\r\n                                errorThrown = MeadCo.parseAjaxError(\"MeadCo.ScriptX.Print:\" + sApi + method, jqXhr, textStatus, errorThrown);\r\n                                if (typeof reject === \"function\")\r\n                                    reject(errorThrown);\r\n                                else {\r\n                                    throw new Error(errorThrown);\r\n                                }\r\n                            })\r\n                            .always(function (dataOrjqXHR, textStatus, jqXHRorErrorThrown) {\r\n                                that.undoTrust();\r\n                            });\r\n                    }\r\n                    else {\r\n                        if (bAsync) {\r\n                            if (bLicensed) {\r\n                                oPayload.headers = {\r\n                                    \"Authorization\": \"Basic \" + btoa(licenseGuid + \":\"),\r\n                                    \"X-Meadroid-Path\": currentUrl,\r\n                                    \"Content-type\": \"application/json\"\r\n                                }\r\n                            }\r\n                            else {\r\n                                oPayload.headers = {\r\n                                    \"X-Meadroid-Path\": currentUrl,\r\n                                    \"Content-type\": \"application/json\"\r\n                                }\r\n                            }\r\n\r\n                            const netcall = fetch(serviceUrl, {\r\n                                method: oPayload.method,\r\n                                headers: oPayload.headers,\r\n                                body: oPayload.data,\r\n                                referrerPolicy: \"origin-when-cross-origin\",\r\n                                mode: \"cors\",\r\n                                credentials: \"omit\",\r\n                                cache: \"no-store\",\r\n                                redirect: \"error\",\r\n                                keepalive: false\r\n                            })\r\n                                .then((response) => {\r\n                                    that.undoTrust();\r\n                                    if (!response.ok) {\r\n                                        // throw new Error(`HTTP Error: ${response.status}`)\r\n                                        if (response.status == 500 || response.status == 404) {\r\n                                            const err = response.text()\r\n                                                .then(errorTxt => {\r\n                                                    const errorThrown = MeadCo.parseFetchError(\"MeadCo.ScriptX.Print:\" + sApi + method, errorTxt);\r\n                                                    if (typeof reject === \"function\")\r\n                                                        reject(errorThrown);\r\n                                                    else {\r\n                                                        throw new Error(errorThrown);\r\n                                                    }\r\n                                                });\r\n                                        }\r\n                                        else {\r\n                                            if (typeof reject === \"function\")\r\n                                                reject(response.statusText);\r\n                                            else {\r\n                                                throw new Error(response.statusText);\r\n                                            }\r\n                                        }\r\n                                        return;\r\n                                    }\r\n                                    return response.json();\r\n                                })\r\n                                .then(data => {\r\n                                    if (data && typeof resolve === \"function\") {\r\n                                        resolve(data);\r\n                                    }\r\n                                })\r\n                                .catch((error) => {\r\n                                    const errorThrown = MeadCo.parseFetchError(\"MeadCo.ScriptX.Print:\" + sApi + method, error);\r\n                                    if (typeof reject === \"function\")\r\n                                        reject(errorThrown);\r\n                                    else {\r\n                                        throw new Error(errorThrown);\r\n                                    }\r\n                                });\r\n                        }\r\n                        else {\r\n                            if (typeof reject === \"function\") {\r\n                                reject(\"Synchronous Ajax calls requires jQuery\");\r\n                            }\r\n                            else\r\n                                throw new Error(\"Synchronous Ajax calls requires jQuery\");\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    if (typeof reject === \"function\") {\r\n                        reject(\"MeadCo.ScriptX.Print : server connection is not defined.\");\r\n                    }\r\n                    else\r\n                        throw new Error(\"MeadCo.ScriptX.Print : server connection is not defined.\");\r\n                }\r\n            }\r\n\r\n            return true;\r\n        },\r\n\r\n        // determine if the server is changing - domain or port has changed when not using orchestrator\r\n        IsChangingServer: function (aServerUrl) {\r\n            if (this.serviceUrl !== \"\") {\r\n\r\n                try {\r\n                    var currentUrl = new URL(this.serviceUrl);\r\n                    var newUrl = new URL(aServerUrl);\r\n\r\n                    return currentUrl.hostname != newUrl.hostname || (currentUrl.port != newUrl.port && this.orchestratorPort == 0);\r\n                } catch (e) {\r\n                    MeadCo.error(\"Failed to construct URL(): \" + e.message + \", from: \" + this.serviceUrl + \", or: \" + aServerUrl);\r\n                    MeadCo.error(\"Many errors will ensue\");\r\n                    return false; // will stop attempts to use something bad.\r\n                }\r\n            }\r\n\r\n            return true;\r\n        },\r\n\r\n        IsEmptyPayload(oPayload) {\r\n            return oPayload === null || (Object.keys(oPayload).length === 0 && oPayload.constructor === Object);\r\n        },\r\n\r\n        // bad news to retest ports on a host that has already been tried, in a page lifetime, it isnt going to get any better.\r\n        IsFailedConnection: function (aServerUrl) {\r\n            if (this.failedUrl.length > 0) {\r\n                try {\r\n                    var failedUrl = new URL(this.failedUrl);\r\n                    var newUrl = new URL(aServerUrl);\r\n\r\n                    if (failedUrl.hostname === newUrl.hostname) {\r\n                        MeadCo.warn(\"Attempt to use: \" + aServerUrl + \" is noted as a failed connection and will not be retried\");\r\n                        return true;\r\n                    }\r\n\r\n                    return false;\r\n                } catch (e) {\r\n                    MeadCo.error(\"Testing IsFailed unable to construct URL(): \" + e.message + \", from: \" + this.failedUrl + \", or: \" + aServerUrl);\r\n                    return true; // will stop attempts to use something bad.\r\n                }\r\n            }\r\n\r\n            return false;\r\n        }\r\n    };\r\n\r\n    var licenseGuid = \"\";\r\n    var bConnected = false; // true when default device settings have been obtained from a .services server\r\n\r\n    var bDoneAuto = false;\r\n\r\n    var availablePrinters = [];\r\n\r\n    var cachedServiceDescription = null; // cached description of service server connected to \r\n\r\n    /**\r\n     * Enum for type of content being posted to printHtml API\r\n     *\r\n     * @memberof MeadCoScriptXPrint    \r\n     * @typedef {number} ContentType\r\n     * @enum {ContentType}\r\n     * @readonly\r\n     * @property {number} URL 1 the url will be downloaded and printed\r\n     * @property {number} HTML 2 the passed string is assumed to be a complete html document .. <html>..</html>\r\n     * @property {number} INNERHTML 4 the passed string is a complete html document but missing the html tags\r\n     * @property {number} STRING 8 the passed string is assumed to contain no html but may contain other language such as ZPL (for direct printing)\r\n     */\r\n    var enumContentType = {\r\n        URL: 1, // the url will be downloaded and printed (for html and direct printing)\r\n        HTML: 2, // the passed string is assumed to be a complete html document .. <html>..</html>\r\n        INNERHTML: 4, // the passed string is a complete html document but missing the html tags\r\n        STRING: 8 // the passed string is assumed to contain no html but may contain other language such as ZPL (for direct printing)\r\n    };\r\n\r\n    var enumResponseStatus = {\r\n        UNKNOWN: 0,\r\n        QUEUEDTODEVICE: 1,\r\n        QUEUEDTOFILE: 2,\r\n        SOFTERROR: 3,\r\n        OK: 4\r\n    };\r\n\r\n    /**\r\n     * Enum for required behaviour when an error occurs. \r\n     *\r\n     * @memberof MeadCoScriptXPrint    \r\n     * @typedef {number} ErrorAction\r\n     * @enum {ErrorAction}\r\n     * @readonly\r\n     * @property {number} REPORT 1 Call MeadCo.ScriptX.Print.reportServerError(errMsg)\r\n     * @property {number} THROW 2 throw an error : throw errMsg\r\n     */\r\n    var enumErrorAction = {\r\n        REPORT: 1,\r\n        THROW: 2\r\n    };\r\n    var errorAction = enumErrorAction.REPORT;\r\n\r\n    /**\r\n     * Enum for the class of service connected to.\r\n     * \r\n     * @memberof MeadCoScriptXPrint\r\n     * @typedef { number } ServiceClasses\r\n     * @enum { ServiceClasses }\r\n     * @readonly \r\n     * @property { number } CLOUD 1 MeadCo Cloud Service \r\n     * @property { number } ONPREMISE 2 ScriptX.Services for On Premise Devices\r\n     * @property { number } WINDOWSPC 3 ScriptX.Services for Windows PC\r\n     * */\r\n    var enumServiceClass = {\r\n        CLOUD: 1,\r\n        ONPREMISE: 2,\r\n        WINDOWSPC: 3\r\n    };\r\n\r\n    /**\r\n     * Information about the service that is connected to - version detail and facilities available\r\n     * See also: https://www.meadroid.com/Developers/KnowledgeBank/TechnicalReference/ScriptXServices/WebServiceAPIReference/ServiceDescription/GET\r\n     * \r\n     * @typedef ServiceDescriptionObject\r\n     * @memberof MeadCoScriptXPrint\r\n     * @property {ServiceClasses} serviceClass the class of the service; cloud, onpremise, pc\r\n     * @property {string} currentAPIVersion the latest version implemented (eg 'v1' or 'v2' etc)\r\n     * @property {VersionObject} serviceVersion implementation version of the service\r\n     * @property {VersionObject} serverVersion The version of ScriptX Server used by the service\r\n     * @property {VersionObject} serviceUpgrade The latest version of the service that is available and later than ServiceVersion/me \r\n     * @property {Array.<string>} availablePrinters Array of the names of the available printers\r\n     * @property {boolean} printHTML Printing of HTML is supported\r\n     * @property {boolean} printPDF Printing of PDF documents is supported\r\n     * @property {boolean} printDIRECT Direct printing to a print device is supported\r\n     * */\r\n    var ServiceDescriptionObject; // for Doc Generator\r\n\r\n    /**\r\n     * Enum for status code returned to print progress callbacks\r\n     *\r\n     * @memberof MeadCoScriptXPrint    \r\n     * @typedef {number} PrintStatus\r\n     * @enum {PrintStatus}\r\n     * @readonly\r\n     * @property {number} NOTSTARTED 0\r\n     * @property {number} QUEUED 1\r\n     * @property {number} STARTING 2\r\n     * @property {number} DOWNLOADING 3\r\n     * @property {number} DOWNLOADED 4\r\n     * @property {number} PRINTING 5\r\n     * @property {number} COMPLETED 6\r\n     * @property {number} PAUSED 7\r\n     * @property {number} PRINTPDF 8\r\n     * @property {number} ERROR -1\r\n     * @property {number} ABANDONED -2\r\n     *\r\n     * These are internal and should not be seen. However it is known CODEEXEPTION can leak and be seen.\r\n     * @property {number} COLLECTED 100\r\n     * @property {number} CODEEXEPTION 101\r\n     * @property {number} COMPLETEDWAITINGFORCOLLECTION 102\r\n     */\r\n    var enumPrintStatus = {\r\n        NOTSTARTED: 0,\r\n\r\n        // queue call back opcodes ...\r\n        QUEUED: 1,\r\n        STARTING: 2,\r\n        DOWNLOADING: 3,\r\n        DOWNLOADED: 4,\r\n        PRINTING: 5,\r\n        COMPLETED: 6,\r\n        PAUSED: 7,\r\n        PRINTPDF: 8,\r\n\r\n        ERROR: -1,\r\n        ABANDONED: -2\r\n    };\r\n\r\n    /**\r\n     * Enum to describe the collation option when printing \r\n     *\r\n     * @memberof MeadCoScriptXPrint   \r\n     * @typedef {number} CollateOptions\r\n     * @enum {CollateOptions}\r\n     * @readonly\r\n     * @property {number} DEFAULT 0 use the default at the print server\r\n     * @property {number} TRUE 1 collate pages when printing\r\n     * @property {number} FALSE 2 do not collate pages\r\n     */\r\n    var enumCollateOptions = {\r\n        DEFAULT: 0,\r\n        TRUE: 1,\r\n        FALSE: 2\r\n    };\r\n\r\n    /**\r\n     * Enum to describe the duplex print option to use when printing \r\n     *\r\n     * @memberof MeadCoScriptXPrint\r\n     * @typedef {number} DuplexOptions\r\n     * @enum {DuplexOptions}\r\n     * @readonly\r\n     * @property {number} DEFAULT 0 use the default at the print server\r\n     * @property {number} SIMPLEX 1 \r\n     * @property {number} VERTICAL 2 \r\n     * @property {number} HORIZONTAL 3\r\n     */\r\n    var enumDuplexOptions = {\r\n        DEFAULT: 0,\r\n        SIMPLEX: 1,\r\n        VERTICAL: 2,\r\n        HORIZONTAL: 3\r\n    };\r\n\r\n    function queueJob(data) {\r\n        activePrintQueue.push(data);\r\n        MeadCo.log(\"ScriptX.Print queueJob: \" + data.jobIdentifier + \", name: \" + data.jobName + \", jobCount: \" + activePrintQueue.length);\r\n    }\r\n\r\n    function jobCount() {\r\n        MeadCo.log(\"ScriptX.Print jobCount: \" + activePrintQueue.length);\r\n        return activePrintQueue.length;\r\n    }\r\n\r\n    function findJob(id) {\r\n        return activePrintQueue.find(e => e.jobIdentifier === id);\r\n    }\r\n\r\n    function updateJob(data) {\r\n        let j = findJob(data.jobIdentifier);\r\n        if (j) {\r\n            Object.keys(data).forEach(function (key) {\r\n                j[key] = data[key];\r\n            });\r\n            return;\r\n        }\r\n\r\n        MeadCo.warn(\"Unable to find job: \" + data.jobIdentifier + \" to update it\");\r\n    }\r\n\r\n    function removeJob(id) {\r\n\r\n        activePrintQueue = activePrintQueue.filter(e => e.jobIdentifier !== id);\r\n        MeadCo.log(`ScriptX.Print removed job: ${id}, jobCount: ${activePrintQueue.length}`);\r\n        // no jobs being processed, allow next immediate start\r\n        if (activePrintQueue.length == 0) previousPrintCallWasAt = 0;\r\n\r\n    }\r\n\r\n    function progress(requestData, status, information) {\r\n        if (typeof requestData.OnProgress === \"function\") {\r\n            requestData.OnProgress(status, information, requestData.UserData);\r\n        }\r\n    }\r\n\r\n    // funcPrintHtmlAtServer\r\n    //\r\n    // Create a closure on all the data for a print job which can be used with timeout.\r\n    //\r\n    var nextJobFileName = \"\";\r\n    function funcPrintHtmlAtServer(contentType, content, htmlPrintSettings, trackingData, fnDone, fnProgress, fnOnQueuedFileAvailable) {\r\n        MeadCo.log(\"started MeadCo.ScriptX.Print.print.printHtmlAtServer() Type: \" + contentType);\r\n        if (contentType === enumContentType.URL) {\r\n            MeadCo.log(\".. request print url: \" + content);\r\n        }\r\n\r\n        // must deepclone objects not values by reference.\r\n        var devInfo;\r\n        if (printerName === \"\") {\r\n            devInfo = {};\r\n        } else {\r\n            if (printerName === magicPrintPreviewPrinter) {\r\n                devInfo = JSON.parse(JSON.stringify({\r\n                    printerName: printerName\r\n                }));\r\n            }\r\n            else\r\n                devInfo = JSON.parse(JSON.stringify(deviceSettings[printerName]));\r\n        }\r\n\r\n        var requestData = {\r\n            ContentType: contentType,\r\n            Content: content,\r\n            Settings: JSON.parse(JSON.stringify(htmlPrintSettings)),\r\n            Device: devInfo,\r\n            ProtectedContentAccess: AccessControl,\r\n            OnProgress: fnProgress,\r\n            UserData: trackingData\r\n        };\r\n\r\n        var fakeJob = {\r\n            jobIdentifier: Date.now(),\r\n            printerName: requestData.Device.printerName,\r\n            jobName: jobNameWaitingForSend\r\n        };\r\n        queueJob(fakeJob); // essentially a lock on the queue to stop it looking empty until this job is processed\r\n\r\n        var requiredOutputName = nextJobFileName;\r\n        nextJobFileName = \"\";\r\n\r\n        var fnOnFileAvailable = fnOnQueuedFileAvailable;\r\n\r\n        return function () {\r\n            removeJob(fakeJob.jobIdentifier);\r\n            return printAtServer(htmlApiLocation, requestData,\r\n                {\r\n                    fail: function (err) {\r\n                        progress(requestData, enumPrintStatus.ERROR, err);\r\n                        MeadCo.ScriptX.Print.reportError(err);\r\n                        if (typeof fnDone === \"function\") {\r\n                            fnDone(\"Server error\");\r\n                        }\r\n                    },\r\n\r\n                    queuedToFile: function (data) {\r\n                        MeadCo.log(\"print is being queued to a file\");\r\n                        progress(requestData, enumPrintStatus.QUEUED);\r\n                        monitorJob(htmlApiLocation, requestData, data.jobIdentifier,\r\n                            -1,\r\n                            function (data) {\r\n                                if (data !== null) {\r\n                                    MeadCo.log(\"download printed file is available\");\r\n                                    progress(requestData, enumPrintStatus.COMPLETED);\r\n\r\n                                    var api = MeadCo.makeApiEndPoint(servicesServer.url, htmlApiLocation + \"/download/\" + data.jobIdentifier);\r\n                                    if (requiredOutputName.length > 0) {\r\n                                        api += \"/\" + requiredOutputName;\r\n                                    }\r\n                                    fnOnFileAvailable(api, data.jobIdentifier);\r\n                                }\r\n\r\n                                if (typeof fnDone === \"function\") {\r\n                                    fnDone(data === null ? \"Server error\" : null);\r\n                                }\r\n                            });\r\n                    },\r\n\r\n                    queuedToDevice: function (data) {\r\n                        MeadCo.log(\"print was queued to device\");\r\n                        progress(requestData, enumPrintStatus.QUEUED);\r\n                        monitorJob(htmlApiLocation, requestData, data.jobIdentifier,\r\n                            -1,\r\n                            function (data) {\r\n                                if (data !== null) {\r\n                                    progress(requestData, enumPrintStatus.COMPLETED);\r\n                                }\r\n\r\n                                if (typeof fnDone === \"function\") {\r\n                                    fnDone(data === null ? \"Server error\" : null);\r\n                                }\r\n                            });\r\n                    },\r\n\r\n                    softError: function (data) {\r\n                        progress(requestData, enumPrintStatus.ERROR, data.message);\r\n                        MeadCo.ScriptX.Print.reportError(data.message);\r\n                        MeadCo.log(\"print has soft error\");\r\n                        removeJob(data.jobIdentifier);\r\n                        if (typeof fnDone === \"function\") {\r\n                            MeadCo.log(\"Call fnDone\");\r\n                            fnDone(data.message);\r\n                        }\r\n                    },\r\n\r\n                    ok: function (data) {\r\n                        progress(requestData, enumPrintStatus.COMPLETED);\r\n                        MeadCo.log(\"printed ok, no further information\");\r\n                        removeJob(data.jobIdentifier);\r\n                        if (typeof fnDone === \"function\") {\r\n                            fnDone(null);\r\n                        }\r\n                    }\r\n                })\r\n        };\r\n    }\r\n\r\n\r\n    /**\r\n     * Post a request to the server api/v1/print to print some html and monitor the print job \r\n     * to completion. If the server prints to file then the file is returned as a download.\r\n     * \r\n     * There is no guarantee of the order of outgoing calls, no guarantee they will ber processed in \r\n     * order at the server if they go from the client very quickly. ScriptX.Addon printHtml() was \r\n     * deterministic in its order - jobs were printed in the order of the calls. In order to \r\n     * achieve this without a push pull queue rapid calls are spaced a part via settimeout()\r\n     * \r\n     * @function printHtmlAtServer\r\n     * @memberof MeadCoScriptXPrint\r\n\r\n     * @param {ContentType} contentType enum type of content given (html snippet, url)\r\n     * @param {string} content the content - a url, html snippet or complete html\r\n     * @param {object} htmlPrintSettings the settings to use - page and html such as headers and footers\r\n     * @param {function({string})} fnDone function to call when printing complete (and output returned), arg is null on no error, else error message\r\n     * @param {function(status,sInformation,data)} fnProgress function to call when job status is updated\r\n     * @param {any} trackingData object to give pass to fnProgress\r\n     * @return {boolean} - true if a print was started (otherwise an error will be thrown)\r\n     * @private\r\n     */\r\n    var timeoutToJobStart = 0;\r\n    var previousPrintCallWasAt = 0;\r\n    var timeoutSpacingMSecs = 750;\r\n    var jobGapResetTimeout = 10000;\r\n    function printHtmlAtServer(contentType, content, htmlPrintSettings, fnDone, fnProgress, trackingData) {\r\n\r\n        if (!content || (typeof content === \"string\" && content.length === 0)) {\r\n            MeadCo.ScriptX.Print.reportError(\"Request to print no content - access denied?\");\r\n            if (typeof fnDone === \"function\") {\r\n                fnDone(\"Request to print no content\");\r\n            }\r\n            return false;\r\n        }\r\n\r\n        // if previous call was over (default) 10 seconds ago, reset\r\n        var t = Date.now();\r\n        if ((t - previousPrintCallWasAt) > jobGapResetTimeout) {\r\n            timeoutToJobStart = 0;\r\n        }\r\n        previousPrintCallWasAt = t;\r\n        setTimeout(funcPrintHtmlAtServer(contentType, content, htmlPrintSettings, trackingData, fnDone, fnProgress, function (sApi) {\r\n            window.open(sApi, \"_self\");\r\n        }), timeoutToJobStart);\r\n        timeoutToJobStart += timeoutSpacingMSecs;\r\n        return true;\r\n    }\r\n\r\n    // funcPrintPdfAtServer\r\n    //\r\n    // Create a closure on all the data for a print job which can be used with timeout.\r\n    //\r\n    function funcPrintPdfAtServer(document, pdfPrintSettings, fnDone, fnProgress, data) {\r\n\r\n        MeadCo.log(\"started MeadCo.ScriptX.Print.print.printPdfAtServer() document: \" + document + \", printerName: \" + printerName);\r\n\r\n        let devInfo;\r\n        // deep clones of objects\r\n        if (printerName === \"\") {\r\n            devInfo = {};\r\n        } else {\r\n            devInfo = JSON.parse(JSON.stringify(deviceSettings[printerName]));\r\n        }\r\n\r\n        const requestData = {\r\n            Document: document,\r\n            Description: pdfPrintSettings.jobDescription,\r\n            Settings: JSON.parse(JSON.stringify(pdfPrintSettings)),\r\n            Device: devInfo,\r\n            ProtectedContentAccess: AccessControl,\r\n            OnProgress: fnProgress,\r\n            UserData: data\r\n        };\r\n\r\n        // used/required by printAtServer ...\r\n        requestData.Settings.jobTitle = pdfPrintSettings.jobDescription;\r\n\r\n        const fakeJob = {\r\n            jobIdentifier: Date.now(),\r\n            printerName: requestData.Device.printerName,\r\n            jobName: jobNameWaitingForSend\r\n        };\r\n        queueJob(fakeJob); // essentially a lock on the queue to stop it looking empty until this job is processed\r\n\r\n        var requiredOutputName = nextJobFileName;\r\n        nextJobFileName = \"\";\r\n\r\n        return function () {\r\n            removeJob(fakeJob.jobIdentifier);\r\n            return printAtServer(pdfApiLocation, requestData,\r\n                {\r\n                    fail: function (err) {\r\n                        progress(requestData, enumPrintStatus.ERROR, err);\r\n                        MeadCo.ScriptX.Print.reportError(err);\r\n                        if (typeof fnDone === \"function\") {\r\n                            fnDone(\"Server error\");\r\n                        }\r\n                    },\r\n\r\n                    queuedToFile: function (data) {\r\n                        MeadCo.log(\"default handler on queued to file response\");\r\n                        progress(requestData, enumPrintStatus.QUEUED);\r\n                        monitorJob(pdfApiLocation, requestData, data.jobIdentifier,\r\n                            -1,\r\n                            function (data) {\r\n                                if (data !== null) {\r\n                                    MeadCo.log(\"Will download printed file\");\r\n                                    progress(requestData, enumPrintStatus.COMPLETED);\r\n                                    let api = MeadCo.makeApiEndPoint(servicesServer.url, pdfApiLocation + \"/download/\" + data.jobIdentifier);\r\n                                    if (requiredOutputName.length > 0) {\r\n                                        api += \"/\" + requiredOutputName;\r\n                                    }\r\n                                    window.open(api, \"_self\");\r\n                                }\r\n\r\n                                if (typeof fnDone === \"function\") {\r\n                                    fnDone(data === null ? \"Server error\" : null);\r\n                                }\r\n                            });\r\n                    },\r\n\r\n                    queuedToDevice: function (data) {\r\n                        MeadCo.log(\"print was queued to device\");\r\n                        progress(requestData, enumPrintStatus.QUEUED);\r\n                        monitorJob(pdfApiLocation, requestData, data.jobIdentifier,\r\n                            -1,\r\n                            function (data) {\r\n                                if (data !== null) {\r\n                                    progress(requestData, enumPrintStatus.COMPLETED);\r\n                                }\r\n\r\n                                if (typeof fnDone === \"function\") {\r\n                                    fnDone(data === null ? \"Server error\" : null);\r\n                                }\r\n                            });\r\n                    },\r\n\r\n                    softError: function (data) {\r\n                        progress(requestData, enumPrintStatus.ERROR, data.message);\r\n                        MeadCo.ScriptX.Print.reportError(data.message);\r\n                        MeadCo.log(\"printpdf call has soft error, remove job: \" + data.jobIdentifier);\r\n                        removeJob(data.jobIdentifier);\r\n                        if (typeof fnDone === \"function\") {\r\n                            MeadCo.log(\"Call fnDone\");\r\n                            fnDone(\"Server error\");\r\n                        }\r\n                    },\r\n\r\n                    ok: function (data) {\r\n                        progress(requestData, enumPrintStatus.COMPLETED);\r\n                        MeadCo.log(\"printed ok, no further information\");\r\n                        removeJob(data.jobIdentifier);\r\n                        if (typeof fnDone === \"function\") {\r\n                            fnDone(null);\r\n                        }\r\n                    }\r\n                });\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Post a request to the server api/v1/print to print a pdf document and monitor the print job \r\n     * to completion. If the server prints to file then the file is returned as a download\r\n     * \r\n     * @function printPdfAtServer\r\n     * @memberof MeadCoScriptXPrint\r\n     * @param {string} document full url to the pdf document to be printed\r\n     * @param {object} pdfPrintSettings the settings to use such as rotation, scaling. device settings (printer to use, copies etc) are taken from this static\r\n     * @param {function({string})} fnDone function to call when printing complete (and output returned), arg is null on no error, else error message.\r\n     * @param {function(status,sInformation,data)} fnProgress function to call when job status is updated\r\n     * @param {any} data object to give pass to fnProgress\r\n     * @return {boolean} - true if a print was started (otherwise an error will be thrown)\r\n     * @private\r\n     */\r\n    function printPdfAtServer(document, pdfPrintSettings, fnDone, fnProgress, data) {\r\n\r\n        if (!document || (typeof document === \"string\" && document.length === 0)) {\r\n            MeadCo.ScriptX.Print.reportError(\"The document to print must be given.\");\r\n            if (typeof fnDone === \"function\") {\r\n                fnDone(\"Request to print no content\");\r\n            }\r\n            return false;\r\n        }\r\n\r\n        // if previous call was over (default) 10 seconds ago, reset\r\n        const t = Date.now();\r\n        if ((t - previousPrintCallWasAt) > jobGapResetTimeout) {\r\n            timeoutToJobStart = 0;\r\n        }\r\n        previousPrintCallWasAt = t;\r\n        setTimeout(funcPrintPdfAtServer(document, pdfPrintSettings, fnDone, fnProgress, data), timeoutToJobStart);\r\n        timeoutToJobStart += timeoutSpacingMSecs;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n      * Post a request to the server api/v1/printDirect to print a string directly to the current printer. The print is synchronous at the server\r\n      * and is completed (sent to the printer) when the api returns.\r\n      * \r\n      * @function printDirectAtServer\r\n      * @memberof MeadCoScriptXPrint\r\n \r\n      * @param {ContentType} contentType enum type of content given (string or url)\r\n      * @param {string} content the content - a url, or string containing e.g. zpl.\r\n      * @param {function({string})} fnDone function to call when printing complete, arg is null on no error, else error message\r\n      * @return {boolean} - true if a print was started (otherwise an error will be thrown)\r\n      * @private\r\n      */\r\n    function printDirectAtServer(contentType, content, fnDone) {\r\n        MeadCo.log(\"started MeadCo.ScriptX.Print.print.printDirectAtServer() Type: \" + contentType + \", printerName: \" + printerName);\r\n        if (contentType === enumContentType.URL) {\r\n            MeadCo.log(\".. request print url: \" + content);\r\n        }\r\n        else {\r\n            if (contentType !== enumContentType.STRING) {\r\n                MeadCo.ScriptX.Print.reportError(\"Bad content type for direct printing\");\r\n                if (typeof fnDone === \"function\") {\r\n                    fnDone(\"Bad content type for direct printing\");\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n\r\n        if (!content || (typeof content === \"string\" && content.length === 0)) {\r\n            MeadCo.ScriptX.Print.reportError(\"Request to print no content - access denied?\");\r\n            if (typeof fnDone === \"function\") {\r\n                fnDone(\"Request to print no content\");\r\n            }\r\n            return false;\r\n        }\r\n\r\n        if (printerName === \"\") {\r\n            MeadCo.ScriptX.Print.reportError(\"Request to print but no current printer defined.\");\r\n            if (typeof fnDone === \"function\") {\r\n                fnDone(\"Request to print but no current printer defined.\");\r\n            }\r\n            return false;\r\n        }\r\n\r\n        const requestData = {\r\n            ContentType: contentType,\r\n            Content: content,\r\n            PrinterName: printerName,\r\n            Settings: {\r\n                jobTitle: \"Direct print\" // not required by the server .. used by printAtServer()\r\n            },\r\n            Device: deviceSettings[printerName] // not required by the server .. used by printAtServer()\r\n        };\r\n\r\n        return printAtServer(directApiLocation, requestData,\r\n            {\r\n                fail: function (err) {\r\n                    MeadCo.ScriptX.Print.reportError(err);\r\n                    if (typeof fnDone === \"function\") {\r\n                        fnDone(\"Server error\");\r\n                    }\r\n                },\r\n\r\n                softError: function (data) {\r\n                    MeadCo.ScriptX.Print.reportError(data.message);\r\n                    MeadCo.log(\"print has soft error\");\r\n                    removeJob(data.jobIdentifier);\r\n                    if (typeof fnDone === \"function\") {\r\n                        MeadCo.log(\"Call fnDone\");\r\n                        fnDone(data.message);\r\n                    }\r\n                },\r\n\r\n                ok: function (data) {\r\n                    MeadCo.log(\"printed ok, no further information\");\r\n                    removeJob(data.jobIdentifier); // for direct, by definition there is no queued response\r\n                    if (typeof fnDone === \"function\") {\r\n                        fnDone(null);\r\n                    }\r\n                }\r\n            });\r\n    }\r\n\r\n    // set the ScriptX.Services server to use and the client license/subscription id\r\n    //\r\n    // Both arguments are optional, leaving the current values in place.\r\n    //\r\n    // All connection etc calls route to here, so here is the place to determine the port\r\n    // number to use.\r\n    //\r\n    function setServer(serverUrl, clientLicenseGuid, resolve, reject) {\r\n        if (typeof serverUrl === \"string\" && serverUrl.length > 0) {\r\n            MeadCo.log(\"Print server requested: \" + serverUrl + \" with license: \" + clientLicenseGuid);\r\n\r\n            licenseGuid = typeof clientLicenseGuid === \"string\" && clientLicenseGuid.length > 0 ? clientLicenseGuid : licenseGuid;\r\n            printerName = \"\";\r\n            deviceSettings = {};\r\n            activePrintQueue = []; // warning, will kill any current monitoring\r\n            bConnected = false;\r\n            availablePrinters = [];\r\n\r\n            if (typeof resolve == \"function\") {\r\n                servicesServer.setUrlAsync(serverUrl, resolve, reject);\r\n            }\r\n            else {\r\n                servicesServer.url = serverUrl;\r\n            }\r\n        }\r\n        else {\r\n            MeadCo.log(\"Print server retained in setServer: \" + servicesServer.url + \" may update with license: {\" + clientLicenseGuid + \"} (if provided)\");\r\n            licenseGuid = typeof clientLicenseGuid === \"string\" && clientLicenseGuid.length > 0 ? clientLicenseGuid : licenseGuid;\r\n        }\r\n    }\r\n\r\n    function connectToServer(serverUrl, clientLicenseGuid) {\r\n        setServer(serverUrl, clientLicenseGuid);\r\n        // note that this will silently fail if no advanced printing license\r\n        getDeviceSettings({ name: \"systemdefault\", async: false });\r\n\r\n        // also (async) cache server description\r\n        getFromServer(\"\", true,\r\n            function (data) {\r\n                cachedServiceDescription = data;\r\n            });\r\n    }\r\n\r\n    function connectToServerAsync(serverUrl, clientLicenseGuid, resolve, reject) {\r\n        setServer(serverUrl, clientLicenseGuid, function (foundUrl) {\r\n            // note that this will silently fail if no advanced printing license\r\n            getDeviceSettings({\r\n                name: \"systemdefault\",\r\n                done: resolve,\r\n                async: true,\r\n                fail: reject\r\n            });\r\n\r\n            // also (async) cache server description\r\n            getFromServer(\"\", true,\r\n                function (data) {\r\n                    cachedServiceDescription = data;\r\n                });\r\n        }, reject);\r\n    }\r\n\r\n    /**\r\n     * Post a request to print\r\n     * \r\n     * @param {string} sApi The server api endpoint (e.g. api/printhtml). The method '/print' will be added. \r\n     * @param {object} requestData The data to be posted\r\n     * @param {functionList} responseInterface Callbacks to process responses\r\n     * @returns {bool} true if request sent\r\n     */\r\n    function printAtServer(sApi, requestData, responseInterface) {\r\n\r\n        const fakeJob = {\r\n            jobIdentifier: Date.now(),\r\n            printerName: requestData.Device.printerName,\r\n            jobName: jobNameSentWaitingResponse\r\n        };\r\n\r\n        MeadCo.log(\"printAtServer using: \" + sApi);\r\n\r\n        queueJob(fakeJob); // essentially a lock on the queue to stop it looking empty while we await the result\r\n\r\n        return callService(sApi + \"/print\", \"POST\", requestData, true, true, (data) => {\r\n            MeadCo.log(\"Success response: \" + data.status);\r\n            data.printerName = requestData.Device.printerName;\r\n            data.jobName = typeof requestData.Settings.jobTitle === \"string\" && requestData.Settings.jobTitle.length > 0 ? requestData.Settings.jobTitle : \"server job\";\r\n            queueJob(data);\r\n            removeJob(fakeJob.jobIdentifier);\r\n            switch (data.status) {\r\n                case enumResponseStatus.QUEUEDTOFILE:\r\n                    responseInterface.queuedToFile(data);\r\n                    break;\r\n\r\n                case enumResponseStatus.QUEUEDTODEVICE:\r\n                    responseInterface.queuedToDevice(data);\r\n                    break;\r\n\r\n                case enumResponseStatus.SOFTERROR:\r\n                case enumResponseStatus.UNKNOWN:\r\n                    responseInterface.softError(data);\r\n                    break;\r\n\r\n                case enumResponseStatus.OK:\r\n                    responseInterface.ok(data);\r\n                    break;\r\n            }\r\n        },\r\n            (errMsg) => {\r\n                removeJob(fakeJob.jobIdentifier);\r\n                if (typeof responseInterface.fail === \"function\") {\r\n                    responseInterface.fail(errMsg);\r\n                }\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Call an API on the server with GET\r\n     * \r\n     * @function getFromServer\r\n     * @memberof MeadCoScriptXPrint\r\n     * @param {string} sApi the api to call on the connected server\r\n     * @param {bool} async true for asynchronous call, false for synchronous \r\n     * @param {function} onSuccess function to call on success\r\n     * @param {function(errorText)} onFail function to call on failure\r\n     * @private\r\n     */\r\n    function getFromServer(sApi, async, onSuccess, onFail) {\r\n        return callService(sApi, \"GET\", null, true, async, onSuccess, onFail);\r\n    }\r\n\r\n    function callService(sApi, httpMethod, oApiData, bLicensed, bAsync, resolve, reject) {\r\n        return servicesServer.call(sApi, httpMethod, oApiData, bLicensed, bAsync, resolve, reject);\r\n    }\r\n\r\n    function processMonitorResponse(requestData, data, intervalId, jobId, timeOut, functionComplete) {\r\n        MeadCo.log(\"processMonitorResponse::jobStatus: \" + data.status);\r\n        switch (data.status) {\r\n            case enumPrintStatus.COMPLETED:\r\n                MeadCo.log(\"clear interval: \" + intervalId);\r\n                window.clearInterval(intervalId);\r\n                removeJob(jobId);\r\n                functionComplete(data);\r\n                break;\r\n\r\n            case enumPrintStatus.NOTSTARTED:\r\n            case enumPrintStatus.DOWNLOADED:\r\n            case enumPrintStatus.DOWNLOADING:\r\n            case enumPrintStatus.PRINTING:\r\n            case enumPrintStatus.QUEUED:\r\n            case enumPrintStatus.STARTING:\r\n            case enumPrintStatus.PAUSED:\r\n            case enumPrintStatus.PRINTPDF:\r\n                progress(requestData, data.status, data.message);\r\n                updateJob(data);\r\n                // keep going\r\n                if (timeOut > 0 && (++counter * interval) > timeOut) {\r\n                    window.clearInterval(intervalId);\r\n                    MeadCo.ScriptX.Print.reportError(\"unknown failure while printing.\");\r\n                }\r\n                break;\r\n\r\n            case enumPrintStatus.ERROR:\r\n            case enumPrintStatus.ABANDONED:\r\n            case enumPrintStatus.CODEEXEPTION:\r\n                MeadCo.log(\"error status in processMonitorResponse so clear interval: \" + intervalId);\r\n                progress(requestData, data.status, data.message);\r\n                removeJob(jobId);\r\n                window.clearInterval(intervalId);\r\n                MeadCo.ScriptX.Print.reportError(\"The print failed with the error: \" + data.message);\r\n                functionComplete(null);\r\n                break;\r\n\r\n            default:\r\n                progress(requestData, data.status, data.message);\r\n                MeadCo.log(\"unknown status in processMonitorResponse so clear interval: \" + intervalId);\r\n                removeJob(jobId);\r\n                window.clearInterval(intervalId);\r\n                functionComplete(null);\r\n                break;\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * Monitor a job that has been known to start  on the server. Get job status from the server and record in the job queue \r\n     * and process status appropriately. Progress callbacks will occur.\r\n     * \r\n     * @function monitorJob\r\n     * @memberof MeadCoScriptXPrint\r\n     * @param {string} serverAndApi The server api endpoint (e.g. api/printhtml). The method '/status/' will be added.\r\n     * @param {string} requestData The original data sent with the print request\r\n     * @param {string} jobId The id return from the server for the job (to be monitored)\r\n     * @param {number} timeOut Time give the job to complete or assume has got stuck, -1 means no timeout.\r\n     * @param {function({object})} functionComplete function to call when job is complete. Argument is null on error, the data returned from the status call on success,.\r\n     * @private\r\n     */\r\n    function monitorJob(sApi, requestData, jobId, timeOut, functionComplete) {\r\n        MeadCo.log(\"monitorJob: \" + jobId);\r\n        const interval = 1000;\r\n        let bWaiting = false;\r\n        let intervalId = window.setInterval(function () {\r\n            if (!bWaiting) {\r\n                bWaiting = true; // ensure if the interval fires again before the last call response has been dealt with, wait till next interval until it has been dealt with\r\n                getFromServer(sApi + \"/status/\" + jobId, true, (data) => {\r\n                    processMonitorResponse(requestData, data, intervalId, jobId, timeOut, functionComplete);\r\n                    bWaiting = false;\r\n                },\r\n                    (errorThrown) => {\r\n                        MeadCo.log(\"error: \" + errorThrown + \" in monitorJob so clear interval: \" + intervalId);\r\n                        progress(requestData, enumPrintStatus.ERROR, errorThrown);\r\n                        removeJob(jobId);\r\n                        window.clearInterval(intervalId);\r\n                        functionComplete(null);\r\n                        bWaiting = false;\r\n                    });\r\n            } else {\r\n                MeadCo.log(\"** info : still waiting for last status request to complete\");\r\n            }\r\n        }, interval);\r\n\r\n        MeadCo.log(\"intervalId: \" + intervalId);\r\n    }\r\n\r\n    function addOrUpdateDeviceSettings(data) {\r\n        if (typeof data.printerName === \"string\") {\r\n            if (data.isDefault) {\r\n                for (var i = 0; i < deviceSettings.length; i++) {\r\n                    deviceSettings[i].isDefault = false;\r\n                }\r\n            }\r\n\r\n            deviceSettings[data.printerName] = data;\r\n            if (data.isDefault && printerName.length === 0) {\r\n                printerName = data.printerName;\r\n            }\r\n        }\r\n    }\r\n\r\n    function getDeviceSettings(oRequest) {\r\n        oRequest.name = oRequest.name.replace(/\\\\/g, \"||\");\r\n        MeadCo.log(\"Request get device info: \" + oRequest.name);\r\n\r\n        getFromServer(htmlApiLocation + \"/deviceinfo/\" + encodeURIComponent(oRequest.name) + \"/0\", oRequest.async,\r\n            function (data) {\r\n                bConnected = true;\r\n                addOrUpdateDeviceSettings(data);\r\n                if (typeof oRequest.done === \"function\") {\r\n                    oRequest.done(data);\r\n                }\r\n            },\r\n            function (errTxt) {\r\n                if (oRequest.name === \"systemdefault\") {\r\n                    MeadCo.warn(\"request for systemdefault printer failed - please update to ScriptX.Services 2.11.1\");\r\n                    oRequest.name = \"default\";\r\n                    getDeviceSettings(oRequest);\r\n                }\r\n                else {\r\n                    MeadCo.log(\"failed to getdevice: \" + errTxt);\r\n\r\n                    if (typeof oRequest.fail === \"function\") {\r\n                        oRequest.fail(errTxt);\r\n                    }\r\n                }\r\n            }\r\n        );\r\n\r\n    }\r\n\r\n    function getDeviceSettingsFor(sPrinterName) {\r\n        if (typeof sPrinterName === \"string\" && sPrinterName !== \"\") {\r\n            if (typeof deviceSettings[sPrinterName] === \"undefined\") {\r\n                getDeviceSettings({\r\n                    name: sPrinterName,\r\n                    async: false,\r\n                    done: function (printerData) {\r\n                        if (sPrinterName.toLowerCase() === \"systemdefault\") {\r\n                            sPrinterName = printerData.printerName;\r\n                        }\r\n                    },\r\n                    fail: function (eTxt) { MeadCo.ScriptX.Print.reportError(eTxt); }\r\n                });\r\n            }\r\n\r\n            return deviceSettings[sPrinterName];\r\n        }\r\n\r\n        return {};\r\n    }\r\n\r\n    function getDeviceSettingsForAsync(sPrinterName, resolve, reject) {\r\n        if (typeof sPrinterName === \"string\" && sPrinterName !== \"\") {\r\n            if (typeof deviceSettings[sPrinterName] === \"undefined\") {\r\n                getDeviceSettings({\r\n                    name: sPrinterName,\r\n                    async: true,\r\n                    done: function (printerData) {\r\n                        if (sPrinterName.toLowerCase() === \"systemdefault\") {\r\n                            sPrinterName = printerData.printerName;\r\n                        }\r\n                        resolve(deviceSettings[sPrinterName])\r\n                    },\r\n                    fail: function (eTxt) { reject(eTxt); }\r\n                });\r\n            }\r\n            else\r\n                resolve(deviceSettings[sPrinterName]);\r\n        }\r\n        else\r\n            reject(\"a printer name is required\");\r\n    }\r\n\r\n    function managePrinterConnection(sMethod, sShareName) {\r\n        console.warn(\"Synchronous calls to add/remove printer connections are not recommeneded as this will lock the browser UI. Consider using the asynchronous versions when working with in ScriptX.Services\");\r\n        var sd = MeadCo.ScriptX.Print.serviceDescription();\r\n        if (sd.serviceClass == enumServiceClass.WINDOWSPC && sd.serviceVersion.major >= 2 && sd.serviceVersion.minor >= 19) {\r\n            callService(printerApiLocation + \"/Connection/\" + encodeURIComponent(sShareName), sMethod, null, true, false);\r\n        }\r\n        else {\r\n            MeadCo.error(\"ScriptX.Services for Windows PC 2.19 or later is required for add/remove PrinterConnection()\");\r\n        }\r\n    }\r\n\r\n    function managePrinterConnectionAsync(sMethod, sShareName, onSuccess, onFail) {\r\n        MeadCo.ScriptX.Print.serviceDescriptionAsync(\r\n            function (sd) {\r\n                if (sd.serviceClass == enumServiceClass.WINDOWSPC && sd.serviceVersion.major >= 2 && sd.serviceVersion.minor >= 19) {\r\n                    callService(printerApiLocation + \"/Connection/\" + encodeURIComponent(sShareName), sMethod, null, true, true, onSuccess, onFail);\r\n                }\r\n                else {\r\n                    MeadCo.error(\"ScriptX.Services for Windows PC 2.19 or later is required for add/remove PrinterConnection()\");\r\n                    onFail(\"add/remove PrinterConnection is not supported\");\r\n                }\r\n            },\r\n            onFail\r\n        );\r\n    }\r\n\r\n    // look for auto-processing attributes that define the server to connect to and the\r\n    // license/subscription to be used. \r\n    //\r\n    // This implementation is called by the public api useAttributes (called by factory and secmgr implementations)\r\n    //\r\n    function processAttributes() {\r\n        MeadCo.log(\"MeadCo.ScriptX.Print ... looking for auto connect, already found?: \" + bDoneAuto);\r\n\r\n        if (!bDoneAuto) {\r\n            // protected API\r\n            var printHtml = MeadCo.ScriptX.Print.HTML;\r\n            var printApi = MeadCo.ScriptX.Print;\r\n            var licenseApi = MeadCo.ScriptX.Print.Licensing;\r\n\r\n            const cloudOrOnPremise = document.querySelector('[data-meadco-subscription]');\r\n            if (cloudOrOnPremise) {\r\n                const data = cloudOrOnPremise.dataset;\r\n                MeadCo.log(\"Auto connect susbcription to: \" +\r\n                    data.meadcoServer + \", or \" + data.meadcoPrinthtmlserver +\r\n                    \", with subscription: \" +\r\n                    data.meadcoSubscription +\r\n                    \", sync: \" +\r\n                    data.meadcoSyncinit +\r\n                    \", usefetch: \" +\r\n                    data.meadcoUsefetch\r\n                );\r\n                const syncInit = (\"\" + data.meadcoSyncinit)\r\n                    .toLowerCase() !==\r\n                    \"false\"; // defaults to true if not specified\r\n\r\n                if (!syncInit) {\r\n                    const sFetchDefined = (\"\" + data.meadcoUsefetch);\r\n                    if (sFetchDefined.length > 0)\r\n                        MeadCo.fetchEnabled = sFetchDefined.toLowerCase() === \"true\";\r\n                }\r\n                else\r\n                    MeadCo.fetchEnabled = false;\r\n\r\n                const server = data.meadcoServer;\r\n                if (typeof server === \"undefined\") {\r\n                    server = data.meadcoPrinthtmlserver;\r\n                }\r\n\r\n                if (typeof server === \"undefined\") {\r\n                    MeadCo.error(\"No server specified\");\r\n                } else {\r\n                    // in case there will be a request for the subnscription info ..\r\n                    if (typeof licenseApi !== \"undefined\")\r\n                        licenseApi.connect(server, data.meadcoSubscription);\r\n\r\n                    if (!syncInit) {\r\n                        MeadCo.log(\"Async connectlite...\");\r\n                        printApi.connectLite(server, data.meadcoSubscription);\r\n                    } else {\r\n                        MeadCo\r\n                            .warn(\"Synchronous connection is deprecated.jQuery is required for synchronous behaviour.To update to asynchronous behaviour please use data - meadco - syncinit='false'. Note that this may require additional code changes. Please see: https://www.meadroid.com/Developers/KnowledgeBank/HowToGuides/ScriptXServices/ThenToNow/Stage6\");\r\n                        printHtml.connect(server, data.meadcoSubscription);\r\n                    }\r\n                    bDoneAuto = true;\r\n                }\r\n            }\r\n            else {\r\n                const wPC = document.querySelector('[data-meadco-license]');\r\n\r\n                if (wPC) {\r\n                    if (typeof printApi === \"undefined\" || typeof printHtml === \"undefined\" || typeof licenseApi === \"undefined\") {\r\n                        MeadCo.log(\"Not auto-connecting client license as print or printHtml or license API not present. Should be present on next attempt.\");\r\n                    } else {\r\n                        const data = wPC.dataset;\r\n                        MeadCo.log(\"Auto connect client license to: \" +\r\n                            data.meadcoServer +\r\n                            \", with license: \" +\r\n                            data.meadcoLicense +\r\n                            \", path: \" +\r\n                            data.meadcoLicensePath +\r\n                            \", revision: \" +\r\n                            data.meadcoLicenseRevision +\r\n                            \", sync: \" +\r\n                            data.meadcoSyncinit +\r\n                            \", useFetch: \" +\r\n                            data.meadcoUsefetch +\r\n                            \", orchestrator: \" +\r\n                            data.meadcoOrchestrator +\r\n                            \", orchestratorKey: \" +\r\n                            data.meadcoOrchestratorKey +\r\n                            \", trustVerifiedConnection: \" +\r\n                            data.meadcoTrustVerifiedConnection);\r\n\r\n                        const syncInit = (\"\" + data.meadcoSyncinit)\r\n                            .toLowerCase() !==\r\n                            \"false\"; // defaults to true if not specified\r\n                        const reportError = (\"\" + data.meadcoReporterror)\r\n                            .toLowerCase() !==\r\n                            \"false\"; // defaults to true if not specified\r\n                        const applyLicense = (\"\" + data.meadcoApplyLicense)\r\n                            .toLowerCase() ==\r\n                            \"true\"; // only applies to async, defaults to false if not specified; if MeadCo ScriptXJS is in use, it will do the apply. Set true if it is not being used.\r\n\r\n                        const server = data.meadcoServer;\r\n\r\n                        servicesServer.orchestratorPort = data.meadcoOrchestrator;\r\n                        servicesServer.orchestratorKey = data.meadcoOrchestratorKey;\r\n                        servicesServer.trustVerifiedConnection = (\"\" + data.meadcoTrustVerifiedConnection)\r\n                            .toLowerCase() !==\r\n                            \"false\"; // defaults to true if not specified\r\n\r\n\r\n                        if (!syncInit) {\r\n                            MeadCo.log(\"Async connectlite...\");\r\n                            const sFetchDefined = (\"\" + data.meadcoUsefetch);\r\n                            if (sFetchDefined.length > 0)\r\n                                MeadCo.fetchEnabled = sFetchDefined.toLowerCase() === \"true\";\r\n\r\n                            licenseApi.connectLite(server, data.meadcoLicense,\r\n                                data.meadcoLicenseRevision,\r\n                                data.meadcoLicensePath);\r\n                            printApi.connectLite(server, data.meadcoLicense);\r\n\r\n                            if (applyLicense) {\r\n                                licenseApi.applyAsync(data.meadcoLicense, data.meadcoLicenseRevision, data.meadcoLicensePath,\r\n                                    () => {\r\n                                        MeadCo.log(\"NOTE: license has been applied successfully from async processing of attribute with values\");\r\n                                    },\r\n                                    (e) => {\r\n                                        MeadCo.error(`Failed to apply the license: ${e}, error is: ${licenseApi.errorMessage}`);\r\n                                        if (reportError) {\r\n                                            MeadCo.ScriptX.Print.reportError(licenseApi.errorMessage);\r\n                                        }\r\n                                    }\r\n                                );\r\n                            }\r\n                        } else {\r\n                            MeadCo\r\n                                .warn(\"Synchronous connection is deprecated. jQuery is required for synchronous behaviour. To update to asynchronous behaviour please use data-meadco-syncinit='false'. Note that this may require additional code changes. Please see: https://www.meadroid.com/Developers/KnowledgeBank/HowToGuides/ScriptXServices/ThenToNow/Stage6\");\r\n                            MeadCo.fetchEnabled = false;\r\n                            licenseApi.connect(server, data.meadcoLicense);\r\n                            if (typeof data.meadcoLicensePath !== \"undefined\" &&\r\n                                typeof data\r\n                                    .meadcoLicenseRevision !==\r\n                                \"undefined\") { // if these are not defined then you must use meadco-secmgr.js\r\n                                licenseApi.apply(data.meadcoLicense,\r\n                                    data.meadcoLicenseRevision,\r\n                                    data.meadcoLicensePath);\r\n\r\n                                if (licenseApi.result != 0 && reportError) {\r\n                                    MeadCo.ScriptX.Print.reportError(licenseApi.errorMessage);\r\n                                }\r\n                            }\r\n                            printHtml.connect(server, data.meadcoLicense);\r\n                        }\r\n                        bDoneAuto = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    MeadCo.log(\"MeadCo.ScriptX.Print \" + version + \" loaded.\");\r\n\r\n    //////////////////////////////////////////////////\r\n    // public API\r\n    return {\r\n        /*\r\n         * Enum for type of content being posted to printHtml API\r\n         * @readonly\r\n         * @memberof MeadCoScriptXPrint\r\n         * @enum { ContentType }\r\n         * \r\n         * URL: 1 a get request will be issued to the url and the returned content will be printed\r\n         * HTML: 2 the passed string is assumed to be a complete html document .. <html>..</html>\r\n         * INNERTHTML: 4 the passed string is a complete html document but missing the html tags\r\n         */\r\n        ContentType: enumContentType,\r\n\r\n        /* \r\n         * Enum for status code returned to print progress callbacks\r\n         * @readonly\r\n         * @memberof MeadCoScriptXPrint\r\n         * @enum PrintStatus { number }\r\n         */\r\n        PrintStatus: enumPrintStatus,\r\n\r\n        ErrorAction: enumErrorAction,\r\n\r\n        CollateOptions: enumCollateOptions,\r\n        DuplexOptions: enumDuplexOptions,\r\n        MeasurementUnits: enumMeasurementUnits,\r\n        ServiceClasses: enumServiceClass,\r\n\r\n        /**\r\n         * Get/set the action to take when an error occurs\r\n         * \r\n         * @memberof MeadCoScriptXPrint\r\n         * @property {ErrorAction} onErrorAction - the action\r\n         */\r\n        get onErrorAction() {\r\n            return errorAction;\r\n        },\r\n\r\n        set onErrorAction(action) {\r\n            errorAction = action;\r\n        },\r\n\r\n        /**\r\n         * Get/set the PORT number of the ScriptX.Services Orchestrator ('reverse proxy') to use. By definition orchestrator only listens\r\n         * on the local-loopback address.\r\n         * \r\n         * This is only useful in uses cases of multiple users are simultaneously logged in to an instance of Windows.\r\n         * In these cases, the port number used by ScriptX.Services for Windows PC will be unqiue for each user.\r\n         * \r\n         * The port number for the orchestrator is the same for each user as the orchestrator server is only active while the\r\n         * user is active. \r\n         */\r\n        get orchestrator() {\r\n            return servicesServer.orchestratorPort;\r\n        },\r\n\r\n        set orchestrator(nPort) {\r\n            servicesServer.orchestratorPort = \"\" + nPort;\r\n        },\r\n\r\n        /**\r\n         * Get/set the key to use with Orchestrator Service for ScriptX.Services for Windows PC to recover the port registered for use with the same key.\r\n         * Typically, this will be the user name but can be any value.\r\n         * */\r\n        get orchestratorKey() {\r\n            return servicesServer.orchestratorKey;\r\n        },\r\n\r\n        set orchestratorKey(sKey) {\r\n            servicesServer.orchestratorKey = sKey;\r\n        },\r\n\r\n        /**\r\n         * Get/set the cookie to be used to authorise access to protected content\r\n         * \r\n         * @memberof MeadCoScriptXPrint\r\n         * @property {string} authorisationCookie - the cookie in the form name=value\r\n         */\r\n        get authorisationCookie() {\r\n            return AccessControl.cookie;\r\n        },\r\n\r\n        set authorisationCookie(cookie) {\r\n            AccessControl.cookie = cookie;\r\n        },\r\n\r\n        /** \r\n         *  Get/set the currently active printer\r\n         *  @memberof MeadCoScriptXPrint\r\n         *  @property {string} printerName - The name of the current printer in use.\r\n         */\r\n        get printerName() {\r\n            return printerName;\r\n        },\r\n\r\n        set printerName(deviceRequest) {\r\n            if (!(deviceRequest === printerName || deviceRequest.name === printerName)) {\r\n                if (typeof deviceRequest === \"string\") {\r\n\r\n                    if (typeof deviceSettings[deviceRequest] === \"undefined\") {\r\n                        // not already cached, get (synchronously) if synchronous is available\r\n                        // if synchronous is not available then getDeviceSettingsAsync() must be called \r\n                        // We have no choice but to fail this call. \r\n                        if (outerScope.jQuery && !MeadCo.fetchEnabled) {\r\n                            getDeviceSettings({\r\n                                name: deviceRequest,\r\n                                done: function (data) {\r\n                                    printerName = data.printerName;\r\n                                },\r\n                                async: false,\r\n                                fail: function (eTxt) {\r\n                                    MeadCo.ScriptX.Print.reportError(eTxt);\r\n                                }\r\n                            });\r\n                        }\r\n                        else {\r\n                            MeadCo.error(\"Asynchronous processing of set printerName required, synchronous calls to obtain device details will fail until this completes.\")\r\n                            getDeviceSettingsForAsync(deviceRequest,\r\n                                (data) => { printerName = data.printerName; },\r\n                                (eTxt) => { MeadCo.ScriptX.Print.reportError(eTxt); }\r\n                            );\r\n\r\n                            // awful, solely to not break backwards compatibility\r\n                            if (servicesServer.serviceUrl === \"\")\r\n                                MeadCo.ScriptX.Print.reportError(\"MeadCo.ScriptX.Print : server connection is not defined.\");\r\n                            else\r\n                                MeadCo.ScriptX.Print.reportError(\"Not Found\");\r\n                        }\r\n                    }\r\n                    else {\r\n                        printerName = deviceRequest;\r\n                    }\r\n\r\n                } else {\r\n                    getDeviceSettings(deviceRequest);\r\n                }\r\n            }\r\n        },\r\n\r\n        setSystemDefaultPrinterAsync: function (sName, resolve, reject) {\r\n            if (typeof deviceSettings[\"systemdefault\"] !== \"undefined\" && deviceSettings[\"systemdefault\"] == sName) {\r\n                MeadCo.log(\"setSystemDefaultPrinterAsync() does NOT need to do anything\");\r\n                resolve();\r\n                return;\r\n            }\r\n\r\n            sName = \"system::\" + sName;\r\n            sName = sName.replace(/\\\\/g, \"||\");\r\n            MeadCo.log(\"Request systemDefaultPrinterAsync: \" + sName);\r\n            callService(htmlApiLocation + \"/CurrentPrinter/\" + encodeURIComponent(sName), \"PUT\", null, true, true, resolve, reject);\r\n        },\r\n\r\n        /**\r\n         * Get the version of this module as a string major.minor.hotfix.build\r\n         * @property {string} version\r\n         * @memberof MeadCoScriptXPrint\r\n         */\r\n        get version() {\r\n            return version;\r\n        },\r\n\r\n        /**\r\n         * Get the full url of the ScriptX.Services server connected to \r\n         * \r\n         * @property {string} serviceUrl\r\n         * @memberof MeadCoScriptXPrint         \r\n         */\r\n        get serviceUrl() {\r\n            return servicesServer.url;\r\n        },\r\n\r\n        /**\r\n         * Get the version of the service connected to.\r\n         * \r\n         * @function serviceVersion\r\n         * @memberof MeadCoScriptXPrint\r\n         * @returns {VersionObject} the version\r\n         */\r\n        serviceVersion: function () {\r\n            return this.serviceDescription().serviceVersion;\r\n        },\r\n\r\n        /**\r\n         * Get the version of the service connected to.\r\n         * \r\n         * @function serviceVersionAsync\r\n         * @memberof MeadCoScriptXPrint\r\n         * @param {function({VersionObject})} resolve function to call on success\r\n         * @param {function({errorText})} reject function to call on failure\r\n         */\r\n        serviceVersionAsync: function (resolve, reject) {\r\n            this.serviceDescriptionAsync(function (sd) { resolve(sd.serviceVersion); }, reject);\r\n        },\r\n\r\n        /**\r\n         * Get/set the cached device settings (papersize etc) for the currently active printer\r\n         * @memberof MeadCoScriptXPrint\r\n         * @property {DeviceSettingsObject} deviceSettings (see API /api/vi/printhtml/deviceInfo/ )\r\n         */\r\n        get deviceSettings() {\r\n            return printerName !== \"\" ? deviceSettings[printerName] : {};\r\n        },\r\n\r\n        set deviceSettings(settings) {\r\n            addOrUpdateDeviceSettings(settings);\r\n        },\r\n\r\n        /**\r\n         * Get the device settings (papersize etc) for the named printer. This call is synchronous \r\n         * and not recommended. \r\n         * \r\n         * @function deviceSettingsFor\r\n         * @memberof MeadCoScriptXPrint\r\n         * @param {string} sPrinterName the name of the printer device to return the settings for \r\n         * @returns {DeviceSettingsObject} object with properties\r\n         */\r\n        deviceSettingsFor: function (sPrinterName) {\r\n            return getDeviceSettingsFor(sPrinterName);\r\n        },\r\n\r\n        /**\r\n         * Get the device settings (papersize etc) for the named printer. If not already downloaded\r\n         * this function is asynchronous. \r\n         * \r\n         * @function deviceSettingsForAsync\r\n         * @memberof MeadCoScriptXPrint\r\n         * @param {string} sPrinterName the name of the printer device to return the settings for \r\n         * @param {function({DeviceSettingsObject})} resolve function to call on success\r\n         * @param {function({errorText})} reject function to call on failure\r\n         */\r\n        deviceSettingsForAsync: function (sPrinterName, resolve, reject) {\r\n            getDeviceSettingsForAsync(sPrinterName, resolve, reject);\r\n        },\r\n\r\n        /**\r\n         * search for processing attibutes for connection and subscription/license and process them. The attibutes can be on any element. This function is called automatically by factory emulation and licensing emulation scripts so does not usually \r\n         * need to be called by document script.\r\n         * \r\n         * Please note synchronous AJAX calls are deprecated in all browsers but may be useful to \"quick start\" use of older code. It is recommended that code is moved\r\n         * to using asynchronous calls as soon as practical. The MeadCoScriptXJS library can assist with this as it delivers promise rather than callback based code.\r\n         * \r\n         * @function useAttributes\r\n         * @memberof MeadCoScriptXPrint\r\n         * @example\r\n         * \r\n         * <!-- an example connection to an On Premise server for ScriptX.Services -->\r\n         * <script src=\"lib/meadco-scriptxservicesprintUI.min.js\" \r\n         *      data-meadco-server=\"https://app.corpservices/\" \r\n         *      data-meadco-subscription=\"\" data-meadco-syncinit=\"false\">\r\n         * </script>;\r\n         * \r\n         * <!-- an example connection to ScriptX.Services for Windows PC -->\r\n         * <script src=\"lib/meadco-scriptxservicesUI.min.js\"\r\n         *      data-meadco-server=\"http://127.0.0.1:41191\" \r\n         *      data-meadco-license=\"{6BC6808B-D645-40B6-AE80-E9D0825797EF}\" \r\n         *      data-meadco-syncinit=\"false\" \r\n         *      data-meadco-license-path=\"warehouse\"\r\n         *      data-meadco-license-revision=\"3\">\r\n         * </script>\r\n         * \r\n         * data-meadco-server value is the root url, api/v1/printhtml, api/v1/licensing will be added by the library\r\n         * data-meadco-syncinit default is true for synchronous calls to the server, value 'false' to use asynchronous calls to the server\r\n         * \r\n         * data-meadco-subscription present => cloud/on premise service, value is the subscription GUID\r\n         * data-meadco-license present => for Windows PC service, value is the license GUID\r\n         *\r\n         * If data-meadco-license is present then the following additional attributes can be used:\r\n         * \r\n         * data-meadco-license-revision, value is the revision number of the license\r\n         * data-meadco-license-path, value is the path to the license file (sxlic.mlf). A value of \"warehouse\" will cause the license to be downloaded from MeadCo's License Warehouse\r\n         * data-meadco-reporterror, default is \"true\", value \"false\" suppresses error messages during the initial connection to the service (only)\r\n         * \r\n         */\r\n        useAttributes: function () {\r\n            processAttributes();\r\n        },\r\n\r\n        /**\r\n         * Specify the server to use and the subscription/license id. \r\n         * \r\n         * Attempt to connect to the defined ScriptX.Services server and obtain\r\n         * the device settings for the default printer. This call is synchronous \r\n         * and therefore not recommended. Use connectAsync()\r\n         * \r\n         * @function connect\r\n         * @memberof MeadCoScriptXPrint\r\n         * @param {string} serverUrl the 'root' url to the server (the api path will be added by the library)\r\n         * @param {string} licenseGuid the license/subscription identifier\r\n         */\r\n        connect: function (serverUrl, licenseGuid) {\r\n            connectToServer(serverUrl, licenseGuid);\r\n        },\r\n\r\n        /**\r\n         * Specify the server and the subscription/license id to use on AJAX calls. No call is made in this function\r\n         *\r\n         * @function connectLite\r\n         * @memberof MeadCoScriptXPrint\r\n         * @param {string} serverUrl the 'root' url to the server (the api path will be added by the library)\r\n         * @param {string} licenseGuid the license/subscription identifier\r\n         */\r\n        connectLite: function (serverUrl, licenseGuid) {\r\n            // factory polyfill initialisation will result in a call with empty string\r\n            // values for both arguments via printHtml.connectAsync() as it doesnt \r\n            // know the values so we assume a connectLite has already been called\r\n            // and dont overwrite with empty values.\r\n            setServer(serverUrl, licenseGuid);\r\n        },\r\n\r\n        /**\r\n         * Specify the server to use and the subscription/license id.\r\n         *\r\n         * Attempt to connect to the defined ScriptX.Services server and obtain\r\n         * the device settings for the default printer. \r\n         *\r\n         * @function connectAsync\r\n         * @memberof MeadCoScriptXPrint\r\n         * @param {string} serverUrl the 'root' url to the server (the api path will be added by the library)\r\n         * @param {string} licenseGuid the license/subscription identifier\r\n         * @param {function({dataObject})} resolve function to call on success, dataObject contains the device settings for the default device.\r\n         * @param {function} reject function to call on failure\r\n         */\r\n        connectAsync: function (serverUrl, licenseGuid, resolve, reject) {\r\n            connectToServerAsync(serverUrl, licenseGuid, resolve, reject);\r\n        },\r\n\r\n        /**\r\n         * Test if there is a MeadCo PrintHtml API server at the url\r\n         * \r\n         * @function connectTestAsync\r\n         * @memberof MeadCoScriptXPrint\r\n         * @param {string} serverUrl the 'root' url to the server (the api path will be added by the library)\r\n         * @param {function({foundServerUrl})} resolve function to call on success\r\n         * @param {function({errorText})} reject function to call on failure\r\n         */\r\n        connectTestAsync: function (serverUrl, resolve, reject) {\r\n            servicesServer.verifyUrl(serverUrl, true, resolve, reject);\r\n        },\r\n\r\n        /**\r\n         * Obtain the description of the service provided by the server\r\n         *\r\n         * @function serviceDescription\r\n         * @memberof MeadCoScriptXPrint\r\n         * @returns {ServiceDescriptionObject} serviceDescription\r\n         */\r\n        serviceDescription: function () {\r\n\r\n            if (!cachedServiceDescription) {\r\n                getFromServer(\"\", false,\r\n                    function (data) { cachedServiceDescription = data; },\r\n                    function (e) {\r\n                        MeadCo.ScriptX.Print.reportError(e.message);\r\n                    });\r\n            }\r\n            return cachedServiceDescription;\r\n        },\r\n\r\n        /**\r\n         * Obtain the description of the service provided by the server\r\n         *\r\n         * @function serviceDescriptionAsync\r\n         * @memberof MeadCoScriptXPrint\r\n         * @param {function(ServiceDescriptionObject)} resolve function to call on success\r\n         * @param {function(errorText)} reject function to call on failure\r\n         */\r\n        serviceDescriptionAsync: function (resolve, reject) {\r\n\r\n            if (!cachedServiceDescription) {\r\n                getFromServer(\"\", true,\r\n                    function (data) {\r\n                        cachedServiceDescription = data;\r\n                        resolve(data);\r\n                    }, reject);\r\n            }\r\n            else {\r\n                resolve(cachedServiceDescription);\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Cache the given device info and available printers in this static class instance\r\n         * \r\n         * Used by libraries that call api/v1/printHtml/htmlPrintDefaults\r\n         * \r\n         * @function connectDeviceAndPrinters\r\n         * @memberof MeadCoScriptXPrint\r\n         * @param {object} deviceInfo the device name and settings (papersize etc)\r\n         * @param {array} arPrinters the names of the available printers\r\n         */\r\n        connectDeviceAndPrinters: function (deviceInfo, arPrinters) {\r\n            bConnected = true;\r\n            addOrUpdateDeviceSettings(deviceInfo);\r\n            availablePrinters = arPrinters;\r\n        },\r\n\r\n        /**\r\n         * true if the library has succesfully connected to a server and the default device settings obtained.\r\n         * \r\n         * @memberof MeadCoScriptXPrint\r\n         * @property {bool} isConnected true if the library has succesfully connected to a server.\r\n         * @readonly\r\n         */\r\n        get isConnected() {\r\n            return bConnected;\r\n        },\r\n\r\n        /**\r\n         * Get the list of printers availablefrom the server.\r\n         * \r\n         * @property {string[]} availablePrinterNames an array of strings of the names of the available printers\r\n         * @memberof MeadCoScriptXPrint\r\n         * @readonly\r\n         */\r\n        get availablePrinterNames() {\r\n            return availablePrinters;\r\n        },\r\n\r\n        /**\r\n         * Add a printer for the user. The printer driver must already be available. \r\n         * \r\n         * @function addPrinterConnection\r\n         * @memberof MeadCoScriptXPrint\r\n         * @param {any} sShareName - \r\n         */\r\n        addPrinterConnection: function (sShareName) {\r\n            managePrinterConnection(\"PUT\", sShareName);\r\n        },\r\n\r\n        /**\r\n         * Add a printer for the user. The printer driver must already be available. \r\n         * \r\n         * @function removePrinterConnection\r\n         * @memberof MeadCoScriptXPrint\r\n         * @param {any} sShareName - \r\n         */\r\n        removePrinterConnection: function (sShareName) {\r\n            managePrinterConnection(\"DELETE\", sShareName);\r\n        },\r\n\r\n        /**\r\n         * Add a printer for the user. The printer driver must already be available. \r\n         * \r\n         * @function addPrinterConnectionAsync\r\n         * @memberof MeadCoScriptXPrint\r\n         * @param {any} sShareName - \r\n         * @param {any} onSuccess\r\n         * @param {any} onFail\r\n         */\r\n        addPrinterConnectionAsync: function (sShareName, onSuccess, onFail) {\r\n            managePrinterConnectionAsync(\"PUT\", sShareName, onSuccess, onFail);\r\n        },\r\n\r\n        /**\r\n         * Add a printer for the user. The printer driver must already be available. \r\n         * \r\n         * @function removePrinterConnectionAsync\r\n         * @memberof MeadCoScriptXPrint\r\n         * @param {any} sShareName - \r\n         * @param {any} onSuccess\r\n         * @param {any} onFail\r\n         */\r\n        removePrinterConnectionAsync: function (sShareName, onSuccess, onFail) {\r\n            managePrinterConnectionAsync(\"DELETE\", sShareName, onSuccess, onFail);\r\n        },\r\n\r\n        /**\r\n         * Call a /printHtml API on the server with GET\r\n         * \r\n         * @function getFromServer\r\n         * @memberof MeadCoScriptXPrint\r\n         * @param {string} sPrintHtmlApi the api to call on the connected server\r\n         * @param {bool} async true for asynchronous call, false for synchronous \r\n         * @param {function} onSuccess function to call on success\r\n         * @param {function(errorText)} onFail function to call on failure\r\n         */\r\n        getFromServer: function (sPrintHtmlApi, async, onSuccess, onFail) {\r\n            getFromServer(htmlApiLocation + sPrintHtmlApi, async, onSuccess, onFail);\r\n        },\r\n\r\n        /**\r\n         * Post a request to the server to print some html and monitor the print job \r\n         * to completion. If the server prints to file then the file is opened for the user (in a new window)\r\n         * \r\n         * @function printHtml\r\n         * @memberof MeadCoScriptXPrint\r\n\r\n         * @param {ContentType} contentType enum type of content given (html snippet, url)\r\n         * @param {string} content the content - a url, html snippet or complete html\r\n         * @param {object} htmlPrintSettings the html settings to use such as headers and footers, device settings (printer to use, copies etc) are taken from this static \r\n         * @param {function({string})} fnDone function to call when printing complete (and output returned), arg is null on no error, else error message.\r\n         * @param {function(status,sInformation,data)} fnProgress function to call when job status is updated\r\n         * @param {any} data object to give pass to fnProgress\r\n         * @return {boolean} - true if a print was started (otherwise an error will be thrown)\r\n         */\r\n        printHtml: printHtmlAtServer,\r\n\r\n        /**\r\n         * Post a request to the server to generate a preview. When ready the url from which the preview can be downloaded\r\n         * is passed to the fnReady function.\r\n         * \r\n         * @function requestHtmlPreview\r\n         * @memberof MeadCoScriptXPrint\r\n         * \r\n         * @param {ContentType} contentType enum type of content given (html snippet, url)\r\n         * @param {string} content the content - a url, html snippet or complete html\r\n         * @param {object} htmlPrintSettings the html settings to use such as headers and footers, device settings (printer to use, copies etc) are taken from this static\r\n         * @param {function({string})} fnDone function to call when processing is complete arg is null on no error, else error message.\r\n         * @param {function({string})} fnReady function to call when the preview is available to download\r\n         */\r\n        requestHtmlPreview: function (contentType, content, htmlPrintSettings, fnDone, fnReady) {\r\n            var userPrinterName = printerName;\r\n            printerName = magicPrintPreviewPrinter;\r\n\r\n            funcPrintHtmlAtServer(contentType, content, htmlPrintSettings, {}, fnDone, function () { }, fnReady)();\r\n            printerName = userPrinterName;\r\n        },\r\n\r\n        /**\r\n         * Post a request to the server to print some html and monitor the print job \r\n         * to completion. If the server prints to file then the file is opened for the user (in a new window)\r\n         * \r\n         * @function printPdf\r\n         * @memberof MeadCoScriptXPrint\r\n\r\n         * @param {string} document full url to the pdf document to be printed\r\n         * @param {object} pdfPrintSettings the settings to use such as rotation, scaling. device settings (printer to use, copies etc) are taken from this static\r\n         * @param {function({string})} fnDone function to call when printing complete (and output returned), arg is null on no error, else error message.\r\n         * @param {function(status,sInformation,data)} fnProgress function to call when job status is updated\r\n         * @param {any} data object to give pass to fnProgress\r\n         * @return {boolean} - true if a print was started (otherwise an error will be thrown)\r\n         */\r\n        printPdf: printPdfAtServer,\r\n\r\n        /**\r\n         * Post a request to the server to print a string directly to the current printer. The print is synchronous at the server\r\n         * and is completed (sent to the printer) when the api returns.\r\n         *\r\n         * @function printDirect\r\n         * @memberof MeadCoScriptXPrint\r\n         *\r\n         * @param {ContentType} contentType enum type of content given (string or url)\r\n         * @param {string} content the content - a url, or string containing e.g. zpl.\r\n         * @param {function({string})} fnDone function to call when printing complete, arg is null on no error, else error message\r\n         * @return {boolean} - true if a print was started (otherwise an error will be thrown)         *\r\n         */\r\n        printDirect: printDirectAtServer,\r\n\r\n        /**\r\n         * Extract the error text from jQuery AJAX response\r\n         * \r\n         * @function parseAjaxError\r\n         * @memberof MeadCoScriptXPrint\r\n         * \r\n         * @param {string} logText The lead-in text for a console.log entry\r\n         * @param {object} jqXhr jQuery ajax header\r\n         * @param {string} textStatus textStatus result determined by jQuery\r\n         * @param {string} errorThrown The server exception dewtermined by jQuery\r\n         * @returns {string} The error text to display\r\n         */\r\n        parseAjaxError: function (logText, jqXhr, textStatus, errorThrown) {\r\n            return MeadCo.parseAjaxError(logText, jqXhr, textStatus, errorThrown);\r\n        },\r\n\r\n        /**\r\n         * Extract the error text from browser fetch response\r\n         * \r\n         * @function parseFetchError\r\n         * @memberof MeadCoScriptXPrint\r\n         * \r\n         * @param {object} errorThrown error caught from fetch \r\n         * @returns {string} The error text to display\r\n         */\r\n        parseFetchError: function (logText, errorThrown) {\r\n            return MeadCo.parseFetchError(logText, errorThrown);\r\n        },\r\n\r\n        /**\r\n         * 'derived' classes call this function to report errors, will either throw or report depending on \r\n         * value of onErrorAction.\r\n         * \r\n         * @memberof MeadCoScriptXPrint\r\n         * @function reportError \r\n         * @param {string} errorTxt the error text to display\r\n         * \r\n         */\r\n        reportError: function (errorTxt) {\r\n            MeadCo.error(\"ReportError: \" + errorTxt);\r\n            switch (errorAction) {\r\n                case enumErrorAction.REPORT:\r\n                    MeadCo.ScriptX.Print.reportServerError(errorTxt);\r\n                    break;\r\n\r\n                case enumErrorAction.THROW:\r\n                    throw new Error(errorTxt);\r\n            }\r\n        },\r\n\r\n        /**\r\n         * overridable function for reporting an error. 'derived' classes call this\r\n         * function to report errors.\r\n         * \r\n         * @memberof MeadCoScriptXPrint\r\n         * @function reportServerError \r\n         * @param {string} errorTxt the error text to display\r\n         * \r\n         * ```js\r\n         * // overload cloud print library report error\r\n         * MeadCo.ScriptX.Print.reportServerError = function (errorTxt) {\r\n         *    app.Messages.PrintErrorBox(errorTxt);\r\n         * }\r\n         * ```\r\n         */\r\n        reportServerError: function (errorTxt) {\r\n            alert(\"There was an error in the printing service\\n\\n\" + errorTxt);\r\n        },\r\n\r\n        /**\r\n         * overridable function for reporting an implementation isnt available. 'derived' classes call this\r\n         * function to report functions that are not yet implemented.\r\n         * \r\n         * @memberof MeadCoScriptXPrint\r\n         * @function reportFeatureNotImplemented\r\n         * @param {string} featureDescription descriptn of the feature that isnt available\r\n         * \r\n         * ```js\r\n         * // overload cloud print library report error\r\n         * MeadCo.ScriptX.Print.reportFeatureNotImplemented = function (featureDescription) {\r\n         *   app.Messages.PrintErrorBox(featureDescription + \" is not available yet with the ScriptX.Services.\\n\\nThis feature will be implemented soon.\");\r\n         * }\r\n         * ```\r\n         */\r\n        reportFeatureNotImplemented: function (featureDescription) {\r\n            MeadCo.log(\"Call to not implemented: \" + featureDescription);\r\n            alert(featureDescription + \"\\n\\nis not available.\");\r\n        },\r\n\r\n        /**\r\n         * The list of jobs currently active at this client or server (client 'jobs' are those waiting to be \r\n         * delivered to the server and 'locks' while asychronous UI is in progress).\r\n         * \r\n         * @memberof MeadCoScriptXPrint\r\n         * @property {object[]} queue array of jobs \r\n         * @readonly\r\n         */\r\n        get queue() {\r\n            return activePrintQueue;\r\n        },\r\n\r\n        /**\r\n         * The number of jobs there are active *at the server* for this client\r\n         * \r\n         * @memberof MeadCoScriptXPrint\r\n         * @property {int} activeJobs the number of jobs\r\n         * @readonly\r\n         */\r\n        get activeJobs() {\r\n            return this.queue.filter(j => j.jobName !== jobNameWaitingForSend && j.jobName !== jobNameSentWaitingResponse && j.jobName !== jobNameHoldEnsureSpoolingStatus).length;\r\n        },\r\n\r\n        /**\r\n         * The number of client only jobs (locks and those waiting for delivery to the server) active at this client\r\n         * \r\n         * @memberof MeadCoScriptXPrint\r\n         * @property {int} clientSideJobs the number of jobs\r\n         * @readonly\r\n         */\r\n        get clientSideJobs() {\r\n            return this.queue.filter(j => j.jobName == jobNameWaitingForSend || j.jobName == jobNameSentWaitingResponse || j.jobName == jobNameHoldEnsureSpoolingStatus).length;\r\n        },\r\n\r\n        /**\r\n         * Check if there are no jobs waiting for delivery to the server (faster than clientSideJobs==0)\r\n         * \r\n         * @memberof MeadCoScriptXPrint\r\n         * @property {bool} noJobsWaitingDelivery true if no jobs waiting\r\n         * @readonly\r\n         */\r\n        get noJobsWaitingDelivery() {\r\n            return this.queue.every(j => j.jobName !== jobNameWaitingForSend && j.jobName !== jobNameSentWaitingResponse && j.jobName !== jobNameHoldEnsureSpoolingStatus);\r\n        },\r\n\r\n        /**\r\n         * Make sure that spooling status is locked active while asynchronous UI that may start\r\n         * printing is displayed by placing a lock on the queue.\r\n         * \r\n         * @memberof MeadCoScriptXPrint\r\n         * @function ensureSpoolingStatus\r\n         * @returns {object} a fake job to lock the spooling status on\r\n         * \r\n         * @example\r\n         * var lock = MeadCo.ScriptX.Print.ensureSpoolingStatus\r\n         * ShowAsyncUI(function() {\r\n         *  MeadCo.ScriptX.Print.freeSpoolStatus(lock);\r\n         * });\r\n         */\r\n        ensureSpoolingStatus: function () {\r\n            var lock = { jobIdentifier: Date.now(), printerName: \"ensureJobsPrinter\", jobName: jobNameHoldEnsureSpoolingStatus };\r\n            queueJob(lock);\r\n            return lock;\r\n        },\r\n\r\n        /**\r\n         * Remove a lock on the queue that was created by a call to ensureSpoolingStatus().\r\n         * \r\n         * @memberof MeadCoScriptXPrint\r\n         * @function freeSpoolStatus\r\n         * @param {object} lock the lock object returned by ensureSpoolingStatus()\r\n         */\r\n        freeSpoolStatus: function (lock) {\r\n            removeJob(lock.jobIdentifier);\r\n        },\r\n\r\n        /**\r\n         * Get if print is still 'spooling', in other words still queued at the server\r\n         * \r\n         * @memberof MeadCoScriptXPrint\r\n         * @property {bool} isSpooling\r\n         * @readonly\r\n         */\r\n        get isSpooling() {\r\n            return jobCount() > 0;\r\n        },\r\n\r\n        /**\r\n         * Start (asynchronous) monitor to observe until no more jobs spooling/waiting at the server\r\n         * then call the given callback function\r\n         * \r\n         * @memberof MeadCoScriptXPrint\r\n         * @function waitForSpoolingComplete\r\n         * @param {int} iTimeout wait until complete or timeout (in ms) -1 => infinite\r\n         * @param {function({bool})} fnComplete callback function, arg is true if all jobs complete\r\n         */\r\n        waitForSpoolingComplete: function (iTimeout, fnComplete) {\r\n            MeadCo.log(\"Started WaitForSpoolingComplete(\" + iTimeout + \")\");\r\n            if (typeof fnComplete !== \"function\") {\r\n                throw \"WaitForSpoolingComplete requires a completion callback\";\r\n            }\r\n\r\n            var startTime = Date.now();\r\n            var interval = 250;\r\n\r\n            var intervalId = window.setInterval(function () {\r\n                if (jobCount() === 0) {\r\n                    MeadCo.log(\"WaitForSpoolingComplete - complete\");\r\n                    window.clearInterval(intervalId);\r\n                    fnComplete(true);\r\n                } else {\r\n                    if (iTimeout >= 0 && Date.now() - startTime > iTimeout) {\r\n                        MeadCo.log(\"WaitForSpoolingComplete - timeout\");\r\n                        window.clearInterval(intervalId);\r\n                        fnComplete(jobCount() === 0);\r\n                    }\r\n                }\r\n            }, interval);\r\n        },\r\n\r\n        /**\r\n         * Start (asynchronous) monitor to observe until all submitted jobs have been\r\n         * delivered to the server, there will probably be jobs still waiting to process/spool\r\n         * at the server. It is not safe to close the browser window until this function \r\n         * indicates completion\r\n         * \r\n         * @memberof MeadCoScriptXPrint\r\n         * @function waitForDeliveryComplete\r\n         * @param {int} iTimeout wait until complete or timeout (in ms) -1 => infinite\r\n         * @param {function({bool})} fnComplete callback function, arg is true if all jobs delivered\r\n\r\n         */\r\n        waitForDeliveryComplete: function (iTimeout, fnComplete) {\r\n            MeadCo.log(\"Started waitForDeliveryComplete(\" + iTimeout + \")\");\r\n            if (typeof fnComplete !== \"function\") {\r\n                throw \"waitForDeliveryComplete requires a completion callback\";\r\n            }\r\n\r\n            const startTime = Date.now();\r\n            const interval = 250;\r\n            const that = this;\r\n\r\n            const intervalId = window.setInterval(() => {\r\n                if (that.noJobsWaitingDelivery) {\r\n                    MeadCo.log(\"waitForDeliveryComplete - complete\");\r\n                    window.clearInterval(intervalId);\r\n                    fnComplete(true);\r\n                } else {\r\n                    if (iTimeout >= 0 && Date.now() - startTime > iTimeout) {\r\n                        MeadCo.log(\"waitForDeliveryComplete - timeout\");\r\n                        window.clearInterval(intervalId);\r\n                        fnComplete(false);\r\n                    }\r\n                }\r\n            }, interval);\r\n\r\n        },\r\n\r\n        /**\r\n          * Waits for all pending operations originated with Print, PrintHTML and BatchPrintPDF to be delivered to the server. This is useful\r\n          * to determine when it is safe to call window.close() and not loose jobs and is a significantly shorter period than waitForSpoolingComplete()\r\n          * \r\n          * @function waitForDeliveryCompleteAsync\r\n          * @memberof MeadCoScriptXPrint\r\n          * @returns {Promise} Promise object represents boolean with value true if all jobs have been delivered.\r\n          * @example \r\n          * MeadCo.ScriptX.PrintPage(false);\r\n          * await MeadCo.ScriptX.Print.waitForDeliveryCompleteAsync();\r\n          * self.close();\r\n          */\r\n        waitForDeliveryCompleteAsync: function () {\r\n            const that = this;\r\n            return new Promise(function (resolve, reject) {\r\n                that.waitForDeliveryComplete(-1, resolve);\r\n            });\r\n        },\r\n\r\n        /**\r\n         * Get/set the timeout between jobs when there is a series of print calls and maintaining the output order is required.\r\n         * The default is 750ms. On slow systems/slow connections this may need to be increased.\r\n         * \r\n         * @memberof MeadCoScriptXPrint\r\n         * @property {number} queueTimeoutSpacing\r\n         */\r\n        get queueTimeoutSpacing() {\r\n            return timeoutSpacingMSecs;\r\n        },\r\n\r\n        set queueTimeoutSpacing(msec) {\r\n            timeoutSpacingMSecs = msec;\r\n        },\r\n\r\n        /**\r\n         * Get/set the time since last print call after which the job spacing timeout is reset\r\n         * \r\n         * @memberof MeadCoScriptXPrint\r\n         * @property {number} queueGapResetTime\r\n         */\r\n        get queueGapResetTime() {\r\n            return jobGapResetTimeout;\r\n        },\r\n\r\n        set queueGapResetTime(msec) {\r\n            jobGapResetTimeout = msec;\r\n        },\r\n\r\n        /**\r\n         * Get/set the name to use on the next job\r\n         * \r\n         * @memberof MeadCoScriptXPrint\r\n         * @property {string} jobFileName\r\n         */\r\n        get jobFileName() {\r\n            return nextJobFileName;\r\n        },\r\n\r\n        set jobFileName(sname) {\r\n            nextJobFileName = sname;\r\n        },\r\n\r\n        requestService: function (sApi, method, oApiData, bLicensed, bAsync, resolve, reject) {\r\n            return callService(sApi, method, oApiData, bLicensed, bAsync, resolve, reject);\r\n        },\r\n\r\n        getService: function (sApi, oApiData, bLicensed) {\r\n            return callService(sApi, \"GET\", oApiData, bLicensed, false);\r\n        },\r\n\r\n        postService: function (sApi, oApiData, bLicensed) {\r\n            return callService(sApi, \"POST\", oApiData, bLicensed, false);\r\n        },\r\n\r\n        getServiceAsync: function (sApi, oApiData, bLicensed, resolve, reject) {\r\n            return callService(sApi, \"GET\", oApiData, bLicensed, true, resolve, reject);\r\n        },\r\n\r\n        postServiceAsync: function (sApi, oApiData, bLicensed, resolve, reject) {\r\n            return callService(sApi, \"POST\", oApiData, bLicensed, true, resolve, reject);\r\n        }\r\n\r\n    };\r\n\r\n});\r\n","/** \r\n * MeadCo.ScriptX.Print.Licensing\r\n *\r\n * A static class wrapping calls to the server API to install / manage a client \r\n * license for ScriptX.Services for Windows PC. \r\n * \r\n * The purpose of these libraries is to assist those with a body of client javascript code targetting use of the ScriptX Add-On for Internet Explorer. These libraries assist with continuing with a large part of the code\r\n * intact when transitioning to using ScriptX.Services instead/as well.\r\n * \r\n * This module is only required when working with ScriptX Services for Windows PC.\r\n * \r\n * A license must be 'applied' to the current html document/window before calls to printing APIs that \r\n * use the license can be made.\r\n *\r\n * This module is NOT required when working with Cloud or On Premise services as the license\r\n * installation and management occurs at the server. \r\n *\r\n * Requires: meadco-core.js\r\n * \r\n * @namespace MeadCoScriptXPrintLicensing\r\n * \r\n */\r\n\r\n; (function (name, definition) {\r\n    extendMeadCoNamespace(name, definition);\r\n})('MeadCo.ScriptX.Print.Licensing', function () {\r\n    const moduleversion = \"1.16.1.0\";\r\n    const apiLocation = \"v1/licensing\";\r\n\r\n    let licenseGuid = \"\";\r\n    let licenseRevision = 0;\r\n    let licensePath = \"\"; // \"\" => subscription (cloud) not client for Workstation, => value for client license\r\n    let lastError = \"No license applied\";\r\n    let applyInProgress = false;\r\n\r\n    const module = this;\r\n\r\n    /**\r\n     * The capabilities that can be licensed.\r\n     * \r\n     * @memberof MeadCoScriptXPrintLicensing\r\n     * @typedef LicenseOptions \r\n     * \r\n     * @property {boolean} basicHtmlPrinting True if Add-on compatible basic html printing is available (always true)\r\n     * @property {boolean} advancedPrinting True if Add-on compatible advanced html printing features are available\r\n     * @property {boolean} enhancedFormatting True if Add-on compatible enhanced formatting is available\r\n     * @property {boolean} printPdf True if printing PDF files is available\r\n     * @property {boolean} printRaw True if Raw printing is available\r\n     * */\r\n    var LicenseOptions; // for doc generator\r\n\r\n    /**\r\n     * License details \r\n     * @memberof MeadCoScriptXPrintLicensing\r\n     * @typedef license\r\n     * \r\n     * @property {string} guid The unique id of the license\r\n     * @property {string} company The name of the license owner\r\n     * @property {string} companyHomePage Url of company home page \r\n     * @property {Date} from Date license is valid from\r\n     * @property {Date} to Date license is vaid till \r\n     * @property {LicenseOptions} options The options enabled by the license\r\n     * @property {Array.string} domains the domains the license can be used from\r\n     * */\r\n    var license = {};\r\n\r\n    function connectToServer(serverUrl, slicenseGuid) {\r\n        // a licensing call may be made first, if the print module is available, inform it.\r\n        var p = MeadCo.ScriptX.Print;\r\n        if (typeof p !== \"undefined\" && typeof p.connectLite === \"function\") {\r\n            p.connectLite(serverUrl, slicenseGuid);\r\n        }\r\n        else {\r\n            console.error(\"MeadCo.ScriptX.Print is not available\");\r\n        }\r\n\r\n        licenseGuid = slicenseGuid;\r\n        license = {};\r\n        lastError = \"No license applied\";\r\n        licenseRevision = 0;\r\n        licensePath = \"\";\r\n    }\r\n\r\n    function getSubscriptionFromServer(resolve, reject) {\r\n        const p = MeadCo.ScriptX.Print;\r\n        if (typeof p == \"undefined\" || typeof p.connectLite !== \"function\") {\r\n            var msg = \"MeadCo.ScriptX.Licensing : MeadCo.ScriptX.Print API not available\"\r\n            if (typeof reject === \"function\") {\r\n                reject(msg);\r\n                return;\r\n            }\r\n            throw new Error(msg);\r\n        }\r\n\r\n        if (license.length > 0) {\r\n            if (typeof resolve === \"function\") {\r\n                resolve(license);\r\n            }\r\n            return license;\r\n        }\r\n\r\n        p.requestService(apiLocation, \"GET\", {}, true, typeof resolve === \"function\",\r\n            function (data) {\r\n                lastError = \"\";\r\n                license = { ...license, ...data };\r\n                if (typeof resolve === \"function\") {\r\n                    resolve(license);\r\n                    return;\r\n                }\r\n            },\r\n            function (errorText) {\r\n                lastError = errorText;\r\n                if (typeof reject === \"function\") {\r\n                    reject(lastError);\r\n                    return;\r\n                }\r\n                MeadCo.warn(\"No reject function for: \" + lastError);\r\n            }\r\n        );\r\n        return license;\r\n    }\r\n\r\n    function applyLicense(slicenseGuid, revision, path, resolve, reject) {\r\n\r\n        MeadCo.log(\"Apply license: \" + slicenseGuid + \",revision: \" + revision + \", path: \" + path);\r\n\r\n        const p = MeadCo.ScriptX.Print;\r\n        if (typeof p == \"undefined\" || typeof p.connectLite !== \"function\") {\r\n            var msg = \"MeadCo.ScriptX.Licensing : MeadCo.ScriptX.Print API not available\"\r\n            if (typeof reject === \"function\") {\r\n                reject(msg);\r\n                return;\r\n            }\r\n            MeadCo.warn(\"No reject function for: \" + msg);\r\n        }\r\n\r\n        const lcasePath = path.toLowerCase();\r\n        if (lcasePath !== \"warehouse\" && lcasePath !== \"securewarehouse\") {\r\n            const url = new URL(path, window.location.href);\r\n            path = url.href;\r\n\r\n            MeadCo.log(\"path updated to: \" + path);\r\n        }\r\n\r\n        licenseGuid = slicenseGuid;\r\n        const requestData = {\r\n            Guid: slicenseGuid,\r\n            Url: path,\r\n            Revision: revision\r\n        };\r\n\r\n        p.requestService(apiLocation, \"POST\", requestData, false, typeof resolve === \"function\",\r\n            function (data) {\r\n                lastError = \"\";\r\n                license = { ...license, ...data };\r\n                if (typeof resolve === \"function\") {\r\n                    resolve(license);\r\n                    return;\r\n                }\r\n            },\r\n            function (errorText) {\r\n                lastError = errorText;\r\n                if (typeof reject === \"function\") {\r\n                    reject(lastError);\r\n                    return;\r\n                }\r\n            });\r\n\r\n        if (typeof resolve !== \"function\") {\r\n            MeadCo.log(\"returning applied (sync) license: \" + license.company);\r\n            return license;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    MeadCo.log(\"MeadCo.ScriptX.Print.Licensing \" + moduleversion + \" loaded.\");\r\n\r\n    //////////////////////////////////////////////////\r\n    // public API\r\n    return {\r\n        /**\r\n         * Get the version of this module as a string major.minor.hotfix.build\r\n         * @property {string} version\r\n         * @memberof MeadCoScriptXPrintLicensing\r\n         */\r\n        get version() {\r\n            return moduleversion;\r\n        },\r\n\r\n        /**\r\n         * Specify the server to use and the license Guid. \r\n         * \r\n         * @function connect\r\n         * @memberof MeadCoScriptXPrintLicensing\r\n         * @param {string} serverUrl the 'root' url to the server (the api path will be added by the library)\r\n         * @param {string} slicenseGuid the license GUID as provided by MeadCo. Optional unless will call GetLicenseAsync() without calling apply\r\n         */\r\n        connect: function (serverUrl, slicenseGuid) {\r\n            connectToServer(serverUrl, slicenseGuid);\r\n        },\r\n\r\n        /**\r\n         * Specify the server to use and the license Guid in order to get details on the license via the License property\r\n         * or function GetLicenseAsync() \r\n         *\r\n         * @memberof MeadCoScriptXPrintLicensing\r\n         * @function connectLite\r\n         * @memberof MeadCoScriptXPrintLicensing\r\n         * @param {string} serverUrl the 'root' url to the server (the api path will be added by the library)\r\n         * @param {string} slicenseGuid the license GUID as provided by MeadCo. Optional unless will call GetLicenseAsync() without calling apply\r\n         * @param {number} revision the revision number of the licsnse as provided by MeadCo.\r\n         * @param {string} path fully qualified path to the license file (.mlf file). Use the value 'warehouse' to download from the public MeadCo License warehouse\r\n         *\r\n         */\r\n        connectLite: function (serverUrl, slicenseGuid, revision, path) {\r\n            connectToServer(serverUrl, slicenseGuid);\r\n            licenseRevision = revision;\r\n            licensePath = path;\r\n        },\r\n\r\n        /**\r\n         * Apply (make usable) the MeadCo ScriptX Client license for use with this content. If the license is not already cached it will be downloaded and cached. \r\n         * It is strongly suggested you request that the silent option is enabled in the license (it is by default for ScriptX.Services for Windows PC licenses)\r\n         * \r\n         * The license must list the url of the content to which it is being applied.\r\n         * \r\n         * This call is synchronous and therefore not recommended. Use applyAsync()         \r\n         * \r\n         * @memberof MeadCoScriptXPrintLicensing\r\n         * @function apply\r\n         * @param {string} licenseGuid the license GUID as provided by MeadCo.\r\n         * @param {number} revision the revision number of the licsnse as provided by MeadCo.\r\n         * @param {string} path fully qualified path to the license file (.mlf file). Use the value 'warehouse' to download from the public MeadCo License warehouse\r\n         * @returns {license} details the license that was sucessfully applied, null if none available\r\n         */\r\n        apply: function (licenseGuid, revision, path) {\r\n            return applyLicense(licenseGuid, revision, path);\r\n        },\r\n\r\n        /**\r\n         * Apply (make usable) the MeadCo ScriptX Client license for use with this content. If the license is not already cached it will be downloaded and cached.\r\n         * It is strongly suggested you request that the silent option is enabled in the license (it is by default for ScriptX.Services for Windows PC licenses)\r\n         *\r\n         * The license must list the url of the content to which it is being applied.\r\n         *\r\n         * @memberof MeadCoScriptXPrintLicensing\r\n         * @function applyAsync\r\n         * @param {string} licenseGuid the license GUID as provided by MeadCo.\r\n         * @param {number} revision the revision number of the licsnse as provided by MeadCo.\r\n         * @param {string} path fully qualified path to the license file (.mlf file). Use the value 'warehouse' to download from the public MeadCo License warehouse\r\n\r\n         * @param {function({license})} resolve function to call on success\r\n         * @param {function({string})} reject function to call on failure with reason for failure\r\n         */\r\n        applyAsync: function (licenseGuid, revision, path, resolve, reject) {\r\n            applyLicense(licenseGuid, revision, path, resolve, reject);\r\n        },\r\n\r\n        /**\r\n         * Get the result code for the last attempt to apply a license.\r\n         * \r\n         * Basically faked for the benefit of code compatibility with the add-on\r\n         * \r\n         * @property {number} result\r\n         * @memberof MeadCoScriptXPrintLicensing         \r\n         * \r\n         */\r\n        get result() {\r\n            return lastError === \"\" ? 0 : 5; // => ok or not found\r\n        },\r\n\r\n        /**\r\n         * Get whether a license has been applied successfully\r\n         * \r\n         * @property {boolean} validLicense\r\n         * @memberof MeadCoScriptXPrintLicensing\r\n         *\r\n         */\r\n        get validLicense() {\r\n            return typeof license.guid !== \"undefined\";\r\n        },\r\n\r\n        /**\r\n         * Get the text of the last error.\r\n         * \r\n         * @property {string} errorMessage\r\n         * @memberof MeadCoScriptXPrintLicensing\r\n         * \r\n         */\r\n        get errorMessage() {\r\n            return lastError;\r\n        },\r\n\r\n        get detailOnError() {\r\n            return lastError;\r\n        },\r\n\r\n        /**\r\n         * Get the details on the connected license. If it hasnt been applied yet, then query\r\n         * for the details (but dont apply it and connectLite() MUST have been called).\r\n         * \r\n         * Warning this function is synchronous, GetLicenseAsync() should be used.\r\n         *\r\n         * @property {license} License\r\n         * @memberof MeadCoScriptXPrintLicensing\r\n         * \r\n         */\r\n        get License() {\r\n            var l = typeof license.guid !== \"undefined\" ? license : getSubscriptionFromServer(null, function (e) {\r\n                throw new Error(e)\r\n            });\r\n            return l;\r\n        },\r\n\r\n        /**\r\n         * Get the details on the connected license. If it hasnt been applied yet, then query\r\n         * for the details (but dont apply it and connectLite() MUST have been called).\r\n         *\r\n         * @memberof MeadCoScriptXPrintLicensing\r\n         * @function GetLicenseAsync\r\n         * @param {function({license})} resolve function to call on success\r\n         * @param {function({string})} reject function to call on failure with reason for failure\r\n         */\r\n        GetLicenseAsync: function (resolve, reject) {\r\n            getSubscriptionFromServer(resolve, reject);\r\n        },\r\n\r\n        // helpers for wrapper MeadCoJS - we apply the license here when working\r\n        // with ScriptX Services for Windows PC\r\n        PolyfillInit: function () {\r\n            if (typeof license.guid !== \"undefined\") {\r\n                return true;\r\n            }\r\n\r\n            if (licenseGuid === \"\")\r\n                return false;\r\n\r\n            if (licensePath === \"\") //subscription only\r\n                return true;\r\n\r\n            applyLicense(licenseGuid, licenseRevision, licensePath);\r\n            return typeof license.guid !== \"undefined\";\r\n        },\r\n\r\n        PolyfillInitAsync: function (resolve, reject) {\r\n            if (typeof license.guid !== \"undefined\" || licensePath === \"\") {\r\n                resolve(license);\r\n            }\r\n            else\r\n                applyLicense(licenseGuid, licenseRevision, licensePath, resolve, reject);\r\n        }\r\n    };\r\n\r\n});\r\n","﻿/**\r\n * MeadCo ScriptX 'window.secmgr' shim (support for modern browsers and IE 11) JS client library\r\n *\r\n * The MeadCo Security Manager Add-on for Internet Explorer is included on a html document with an &lt;object id='secmgr' /&gt; element with a de-facto standard id of 'secmgr'.\r\n *\r\n * The object is referenced with the property window.secmgr which exposes properties and methods.\r\n * \r\n * The MeadCo Security Manager Add-on for Internet Explorer provided for prompting the user to accept use of the license that enabled advanced features of ScriptX.Add-on. Frequently\r\n * there was then no further reference to Security Manager and in such cases this shim is not required.\r\n * \r\n * This use case can be emulated by using appropriate attributes on an element (for example a &lt;script&gt;&lt;/script&gt;) on the page and including meadco-scriptxprint.js to process the attributes. This shim is then *not* required.\r\n * \r\n * Please note that when working with ScriptX.Services for Windows PC meadco-scriptxprintlicensing.js is required even with the use of attributes.\r\n * \r\n * This shim is required if you have code that relies upon being able to inspect the availability of a license.\r\n * \r\n * Full documentation on the properties/methods is provided by the technical reference documentation for the ScriptX Add-on for Internet Explorer: https://www.meadroid.com/Developers/KnowledgeBank/TechnicalReference/ScriptXAddOn/secmgr. That documentation is not reproduced here.\r\n *\r\n * If the startup script determines that the MeadCo Security Manager Add-on for IE is already active then it will quietly give priority to the object. In other words, the Add-on has precedence on Internet Explorer.\r\n *\r\n * This enables the same experience (almost) to be delivered to any browser on any device with the same html/javascript code.\r\n *\r\n * It is strongly recommended that the MeadCoScriptJS library (https://github.com/MeadCo/MeadCoScriptXJS) is used in conjunction with this library as it provides code (Promises) to assist\r\n * with working with the significant difference between the synchronous nature of the functions of ScriptX.Add-on (which hide the underlying asynchrony) and the asynchronous nature of javascript AJAX processing.\r\n * \r\n *  Requires: \r\n *  meadco-core.js\r\n *  meadco-scriptxprint.js\r\n *  meadco-scriptxprintlicensing.js\r\n *  \r\n * @namespace secmgr\r\n * \r\n */\r\n\r\n// we anti-polyfill &lt;object id=\"secmgr\" /&gt;\r\n// enabling old code to run in modern browsers\r\n//\r\n; (function (name, definition, undefined) {\r\n\r\n    if (this[name] !== undefined || document.getElementById(name) !== null) {\r\n        MeadCo.log(\"ScriptX.Services MeadCo Security Manager emulation believes it may not be required.\");\r\n        if (this[name] !== undefined) {\r\n            MeadCo.log(\"this[\" + name + \"] is defined\");\r\n        }\r\n        if (document.getElementById(name) !== null) {\r\n            MeadCo.log(\"document.getElementById(\" + name + \") is defined\");\r\n        }\r\n        if (this[name].object !== undefined) {\r\n            MeadCo.log(\"this[\" + name + \"].object is defined -- not required!!!\");\r\n            return;\r\n        } else {\r\n            MeadCo.log(\"this[\" + name + \"].object is *not* defined\");\r\n        }\r\n    }\r\n\r\n    MeadCo.log(\"ScriptX.Services MeadCo Security Manager emulation believes it is required.\");\r\n    var theModule = definition();\r\n\r\n    // Assign to the global object (window)\r\n    (this)[name] = theModule;\r\n\r\n})('secmgr', function () {\r\n\r\n    // protected API\r\n    const moduleversion = \"1.16.1.0\";\r\n    const emulatedVersion = \"8.2.0.0\";\r\n    const thisSpace = this;\r\n    const logApi = MeadCo;\r\n\r\n    // protected API\r\n    const printApi = MeadCo.ScriptX.Print;\r\n    const licenseApi = MeadCo.ScriptX.Print.Licensing;\r\n\r\n    function log(str) {\r\n        logApi.log(\"secmgr emulation :: \" + str);\r\n    }\r\n\r\n    // extend the namespace\r\n    thisSpace.extendSecMgrNamespace = function (name, definition) {\r\n        const theModule = definition();\r\n\r\n        log(\"MeadCo security manager extending namespace2: \" + name);\r\n        // walk/build the namespace part by part and assign the module to the leaf\r\n        const namespaces = name.split(\".\");\r\n        let scope = this;\r\n        for (let i = 0; i < namespaces.length; i++) {\r\n            const packageName = namespaces[i];\r\n            if (i === namespaces.length - 1) {\r\n                if (typeof scope[packageName] === \"undefined\") {\r\n                    log(\"installing implementation at: \" + packageName);\r\n                    scope[packageName] = theModule;\r\n                } else {\r\n                    log(\"Warning - not overwriting package: \" + packageName);\r\n                }\r\n            } else if (typeof scope[packageName] === \"undefined\") {\r\n                log(\"initialising new: \" + packageName);\r\n                scope[packageName] = {};\r\n            } else {\r\n                log(\"using existing package: \" + packageName);\r\n            }\r\n            scope = scope[packageName];\r\n        }\r\n    };\r\n\r\n    log(\"'secmgr' loaded.\");\r\n    if (typeof licenseApi.GetLicenseAsync !== \"function\") {\r\n        MeadCo.error(\"MeadCo.ScriptX.Print.Licensing not available\");\r\n    }\r\n\r\n    if (typeof printApi.useAttributes !== \"function\") {\r\n        MeadCo.warn(\"Attribute based licensing not available as MeadCo.ScriptX.Print is not available\");\r\n    } else {\r\n        printApi.useAttributes();\r\n    }\r\n\r\n    // public API.\r\n    return {\r\n        log: log,\r\n\r\n\r\n        /**\r\n         * Get the version of this module as a string major.minor.hotfix.build\r\n         * @property {string} version\r\n         * @memberof secmgr\r\n         */\r\n        get version() {\r\n            return moduleversion;\r\n        },\r\n\r\n        get result() {\r\n            return licenseApi.result;\r\n        },\r\n\r\n        get validLicense() {\r\n            return licenseApi.validLicense;\r\n        },\r\n\r\n        get License() {\r\n            return licenseApi.License;\r\n        },\r\n\r\n        /**\r\n         * Get the text of the last error.\r\n         * \r\n         * @property {string} errorMessage\r\n         * @memberof MeadCoScriptXPrintLicensing\r\n         * \r\n         */\r\n        get errorMessage() {\r\n            return licenseApi.errorMessage;\r\n        },\r\n\r\n        /**\r\n         * Get the details of the license using Asynchronous calls to the server.\r\n         * See meadco-scriptxprintlicensing.js for more detail\r\n         * @memberof secmgr\r\n         * @function GetLicenseAsync\r\n         * @param {function({license})} resolve function to call on successfulk completion\r\n         * @param {function({string})} reject function to call on failure with reason for failure\r\n         * \r\n         */\r\n        GetLicenseAsync: function (resolve, reject) {\r\n            licenseApi.GetLicenseAsync(resolve, reject);\r\n        },\r\n\r\n        // helpers for wrapper MeadCoJS - we apply the license here when working\r\n        // with ScriptX Services for Windows PC\r\n        PolyfillInit: function () {\r\n            return licenseApi.PolyfillInit();\r\n        },\r\n\r\n        PolyfillInitAsync: function (resolve, reject) {\r\n            licenseApi.PolyfillInitAsync(resolve, reject);\r\n        }\r\n    };\r\n});\r\n\r\n\r\n; (function (name, definition) {\r\n    if (typeof extendSecMgrNamespace === \"function\") {\r\n        extendSecMgrNamespace(name, definition);\r\n    }\r\n})('secmgr.object', function () {\r\n\r\n    // protected API\r\n    var outerScope = this;\r\n\r\n    outerScope.secmgr.log(\"secmgr.object loaded.\");\r\n\r\n    /*\r\n     * This completes the emulation of an  &lt;object /&gt; element\r\n     *\r\n     * Compatibility with Add-on to allow inspection of  &lt;object /&gt; and this javascript\r\n     * for the underlying object implementing 'secmgr'.\r\n     * \r\n     * @property {object} secmgr\r\n     * @memberof secmgrobject\r\n     */\r\n    return outerScope.secmgr;\r\n});\r\n"],"names":["name","theModule","outerScope","this","version","bLog","MeadCo","logEnable","bUseFetch","useFetch","log","str","console","error","extendMeadCoNamespace","definition","namespaces","split","scope","jQuery","ender","$","i","length","packageName","oldscope","newscope","prop","hasOwnProperty","warn","logEnabled","bEnable","fetchEnabled","createNS","namespace","nsparts","parent","slice","partname","s","makeApiEndPoint","serverUrl","apiLocation","p","indexOf","lastIndexOf","substring","makeServiceEndPoint","endPoint","parseAjaxError","logText","jqXhr","textStatus","errorThrown","responseText","statusText","responseJSON","Message","parseError","parseFetchError","msg","message","htmlApiLocation","pdfApiLocation","printerApiLocation","printerName","magicPrintPreviewPrinter","jobNameWaitingForSend","jobNameSentWaitingResponse","jobNameHoldEnsureSpoolingStatus","AccessControl","cookie","deviceSettings","activePrintQueue","servicesServer","serviceUrl","pendingUrl","failedUrl","verifiedUrl","orchestratorPort","orchestratorKey","portsToTry","verifying","trustVerifiedConnection","undoTrust","url","that","verifyUrl","value","IsChangingServer","setUrlAsync","resolve","reject","bAsync","thatValue","window","setTimeout","IsFailedConnection","apiEndPoint","parseInt","ajax","method","dataType","cache","async","done","data","HttpPort","urlHelper","URL","port","protocol","host","pathname","test","urlFound","fail","_","fetch","then","response","ok","Error","status","json","catch","nHuntAllowed","href","licenseApiLocation","resolvedUrl","hostname","call","sApi","oApiData","bLicensed","currentUrl","location","oPayload","jsonp","contentType","headers","btoa","licenseGuid","IsEmptyPayload","JSON","stringify","always","dataOrjqXHR","jqXHRorErrorThrown","body","referrerPolicy","mode","credentials","redirect","keepalive","text","errorTxt","aServerUrl","newUrl","e","Object","keys","constructor","bConnected","bDoneAuto","availablePrinters","cachedServiceDescription","enumContentType","HTML","INNERHTML","STRING","enumResponseStatus","enumErrorAction","REPORT","THROW","errorAction","enumServiceClass","CLOUD","ONPREMISE","WINDOWSPC","enumPrintStatus","NOTSTARTED","QUEUED","STARTING","DOWNLOADING","DOWNLOADED","PRINTING","COMPLETED","PAUSED","PRINTPDF","ERROR","ABANDONED","queueJob","push","jobIdentifier","jobName","jobCount","updateJob","j","id","find","forEach","key","removeJob","filter","previousPrintCallWasAt","progress","requestData","information","OnProgress","UserData","nextJobFileName","funcPrintHtmlAtServer","content","htmlPrintSettings","trackingData","fnDone","fnProgress","fnOnQueuedFileAvailable","devInfo","parse","ContentType","Content","Settings","Device","ProtectedContentAccess","fakeJob","Date","now","requiredOutputName","fnOnFileAvailable","printAtServer","err","ScriptX","Print","reportError","queuedToFile","monitorJob","api","queuedToDevice","softError","timeoutToJobStart","timeoutSpacingMSecs","jobGapResetTimeout","setServer","clientLicenseGuid","responseInterface","callService","jobTitle","errMsg","getFromServer","onSuccess","onFail","httpMethod","processMonitorResponse","intervalId","jobId","timeOut","functionComplete","clearInterval","counter","interval","CODEEXEPTION","bWaiting","setInterval","addOrUpdateDeviceSettings","isDefault","getDeviceSettings","oRequest","replace","encodeURIComponent","errTxt","getDeviceSettingsForAsync","sPrinterName","printerData","toLowerCase","eTxt","managePrinterConnection","sMethod","sShareName","sd","serviceDescription","serviceClass","serviceVersion","major","minor","managePrinterConnectionAsync","serviceDescriptionAsync","PrintStatus","ErrorAction","CollateOptions","DEFAULT","TRUE","FALSE","DuplexOptions","SIMPLEX","VERTICAL","HORIZONTAL","MeasurementUnits","INCHES","MM","ServiceClasses","onErrorAction","action","orchestrator","nPort","sKey","authorisationCookie","deviceRequest","setSystemDefaultPrinterAsync","sName","serviceVersionAsync","settings","deviceSettingsFor","getDeviceSettingsFor","deviceSettingsForAsync","useAttributes","printHtml","printApi","licenseApi","Licensing","cloudOrOnPremise","document","querySelector","dataset","meadcoServer","meadcoPrinthtmlserver","meadcoSubscription","meadcoSyncinit","meadcoUsefetch","syncInit","sFetchDefined","server","connect","connectLite","wPC","meadcoLicense","meadcoLicensePath","meadcoLicenseRevision","meadcoOrchestrator","meadcoOrchestratorKey","meadcoTrustVerifiedConnection","meadcoReporterror","applyLicense","meadcoApplyLicense","apply","result","errorMessage","applyAsync","processAttributes","connectToServer","connectAsync","foundUrl","connectToServerAsync","connectTestAsync","connectDeviceAndPrinters","deviceInfo","arPrinters","isConnected","availablePrinterNames","addPrinterConnection","removePrinterConnection","addPrinterConnectionAsync","removePrinterConnectionAsync","sPrintHtmlApi","t","open","requestHtmlPreview","fnReady","userPrinterName","printPdf","pdfPrintSettings","Document","Description","jobDescription","funcPrintPdfAtServer","printDirect","PrinterName","reportServerError","alert","reportFeatureNotImplemented","featureDescription","queue","activeJobs","clientSideJobs","noJobsWaitingDelivery","every","ensureSpoolingStatus","lock","freeSpoolStatus","isSpooling","waitForSpoolingComplete","iTimeout","fnComplete","startTime","waitForDeliveryComplete","waitForDeliveryCompleteAsync","Promise","queueTimeoutSpacing","msec","queueGapResetTime","jobFileName","sname","requestService","getService","postService","getServiceAsync","postServiceAsync","moduleversion","licenseRevision","licensePath","lastError","license","slicenseGuid","getSubscriptionFromServer","errorText","revision","path","lcasePath","Guid","Url","Revision","company","validLicense","guid","detailOnError","License","GetLicenseAsync","PolyfillInit","PolyfillInitAsync","undefined","getElementById","object","logApi","extendSecMgrNamespace","secmgr"],"sourceRoot":""}